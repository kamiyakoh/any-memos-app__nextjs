/*! For license information please see 108.2e512e03.iframe.bundle.js.LICENSE.txt */
(self.webpackChunkany_memos_app_nextjs=self.webpackChunkany_memos_app_nextjs||[]).push([[108],{"./node_modules/@headlessui/react/dist/components/dialog/dialog.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{l:()=>_t});var react=__webpack_require__("./node_modules/next/dist/compiled/react/index.js"),react_namespaceObject=__webpack_require__.t(react,2);function micro_task_t(e){"function"==typeof queueMicrotask?queueMicrotask(e):Promise.resolve().then(e).catch((o=>setTimeout((()=>{throw o}))))}function disposables_o(){let n=[],r={addEventListener:(e,t,s,a)=>(e.addEventListener(t,s,a),r.add((()=>e.removeEventListener(t,s,a)))),requestAnimationFrame(...e){let t=requestAnimationFrame(...e);return r.add((()=>cancelAnimationFrame(t)))},nextFrame:(...e)=>r.requestAnimationFrame((()=>r.requestAnimationFrame(...e))),setTimeout(...e){let t=setTimeout(...e);return r.add((()=>clearTimeout(t)))},microTask(...e){let t={current:!0};return micro_task_t((()=>{t.current&&e[0]()})),r.add((()=>{t.current=!1}))},style(e,t,s){let a=e.style.getPropertyValue(t);return Object.assign(e.style,{[t]:s}),this.add((()=>{Object.assign(e.style,{[t]:a})}))},group(e){let t=disposables_o();return e(t),this.add((()=>t.dispose()))},add:e=>(n.push(e),()=>{let t=n.indexOf(e);if(t>=0)for(let s of n.splice(t,1))s()}),dispose(){for(let e of n.splice(0))e()}};return r}var i=Object.defineProperty,r=(t,e,n)=>(((t,e,n)=>{e in t?i(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n})(t,"symbol"!=typeof e?e+"":e,n),n);let s=new class o{constructor(){r(this,"current",this.detect()),r(this,"handoffState","pending"),r(this,"currentId",0)}set(e){this.current!==e&&(this.handoffState="pending",this.currentId=0,this.current=e)}reset(){this.set(this.detect())}nextId(){return++this.currentId}get isServer(){return"server"===this.current}get isClient(){return"client"===this.current}detect(){return"undefined"==typeof window||"undefined"==typeof document?"server":"client"}handoff(){"pending"===this.handoffState&&(this.handoffState="complete")}get isHandoffComplete(){return"complete"===this.handoffState}},use_iso_morphic_effect_l=(e,f)=>{s.isServer?(0,react.useEffect)(e,f):(0,react.useLayoutEffect)(e,f)};function use_latest_value_s(e){let r=(0,react.useRef)(e);return use_iso_morphic_effect_l((()=>{r.current=e}),[e]),r}let use_event_o=function(t){let e=use_latest_value_s(t);return react.useCallback(((...r)=>e.current(...r)),[e])};function use_event_listener_E(n,e,a,t){let i=use_latest_value_s(a);(0,react.useEffect)((()=>{function r(o){i.current(o)}return(n=null!=n?n:window).addEventListener(e,r,t),()=>n.removeEventListener(e,r,t)}),[n,e,t])}function f(){let e=(0,react.useRef)(!1);return use_iso_morphic_effect_l((()=>(e.current=!0,()=>{e.current=!1})),[]),e}function c(t){let r=use_event_o(t),e=(0,react.useRef)(!1);(0,react.useEffect)((()=>(e.current=!1,()=>{e.current=!0,micro_task_t((()=>{e.current&&r()}))})),[r])}function owner_o(r){return s.isServer?null:r instanceof Node?r.ownerDocument:null!=r&&r.hasOwnProperty("current")&&r.current instanceof Node?r.current.ownerDocument:document}function use_owner_n(...e){return(0,react.useMemo)((()=>owner_o(...e)),[...e])}function use_server_handoff_complete_l(){let r=function use_server_handoff_complete_s(){let r="undefined"==typeof document;return(o=>o.useSyncExternalStore)(react_namespaceObject)((()=>()=>{}),(()=>!1),(()=>!r))}(),[e,n]=react.useState(s.isHandoffComplete);return e&&!1===s.isHandoffComplete&&n(!1),react.useEffect((()=>{!0!==e&&n(!0)}),[e]),react.useEffect((()=>s.handoff()),[]),!r&&e}let u=Symbol();function use_sync_refs_y(...t){let n=(0,react.useRef)(t);(0,react.useEffect)((()=>{n.current=t}),[t]);let c=use_event_o((e=>{for(let o of n.current)null!=o&&("function"==typeof o?o(e):o.current=e)}));return t.every((e=>null==e||(null==e?void 0:e[u])))?void 0:c}function use_window_event_s(e,r,n){let o=use_latest_value_s(r);(0,react.useEffect)((()=>{function t(i){o.current(i)}return window.addEventListener(e,t,n),()=>window.removeEventListener(e,t,n)}),[e,n])}var use_tab_direction_s=(r=>(r[r.Forwards=0]="Forwards",r[r.Backwards=1]="Backwards",r))(use_tab_direction_s||{});function use_watch_m(u,t){let e=(0,react.useRef)([]),r=use_event_o(u);(0,react.useEffect)((()=>{let o=[...e.current];for(let[n,a]of t.entries())if(e.current[n]!==a){let l=r(t,o);return e.current=t,l}}),[r,...t])}function class_names_t(...r){return Array.from(new Set(r.flatMap((n=>"string"==typeof n?n.split(" "):[])))).filter(Boolean).join(" ")}function match_u(r,n,...a){if(r in n){let e=n[r];return"function"==typeof e?e(...a):e}let t=new Error(`Tried to handle "${r}" but there is no handler defined. Only defined handlers are: ${Object.keys(n).map((e=>`"${e}"`)).join(", ")}.`);throw Error.captureStackTrace&&Error.captureStackTrace(t,match_u),t}var O=(n=>(n[n.None=0]="None",n[n.RenderStrategy=1]="RenderStrategy",n[n.Static=2]="Static",n))(O||{}),v=(e=>(e[e.Unmount=0]="Unmount",e[e.Hidden=1]="Hidden",e))(v||{});function C({ourProps:r,theirProps:t,slot:e,defaultTag:n,features:o,visible:a=!0,name:f,mergeRefs:l}){l=null!=l?l:k;let s=R(t,r);if(a)return render_m(s,e,n,f,l);let y=null!=o?o:0;if(2&y){let{static:u=!1,...d}=s;if(u)return render_m(d,e,n,f,l)}if(1&y){let{unmount:u=!0,...d}=s;return match_u(u?0:1,{0:()=>null,1:()=>render_m({...d,hidden:!0,style:{display:"none"}},e,n,f,l)})}return render_m(s,e,n,f,l)}function render_m(r,t={},e,n,o){let{as:a=e,children:f,refName:l="ref",...s}=F(r,["unmount","static"]),y=void 0!==r.ref?{[l]:r.ref}:{},u="function"==typeof f?f(t):f;"className"in s&&s.className&&"function"==typeof s.className&&(s.className=s.className(t));let d={};if(t){let i=!1,c=[];for(let[T,p]of Object.entries(t))"boolean"==typeof p&&(i=!0),!0===p&&c.push(T);i&&(d["data-headlessui-state"]=c.join(" "))}if(a===react.Fragment&&Object.keys(x(s)).length>0){if(!(0,react.isValidElement)(u)||Array.isArray(u)&&u.length>1)throw new Error(['Passing props on "Fragment"!',"",`The current component <${n} /> is rendering a "Fragment".`,"However we need to passthrough the following props:",Object.keys(s).map((p=>`  - ${p}`)).join("\n"),"","You can apply a few solutions:",['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".',"Render a single element as the child so that we can forward the props onto that element."].map((p=>`  - ${p}`)).join("\n")].join("\n"));let i=u.props,c="function"==typeof(null==i?void 0:i.className)?(...p)=>class_names_t(null==i?void 0:i.className(...p),s.className):class_names_t(null==i?void 0:i.className,s.className),T=c?{className:c}:{};return(0,react.cloneElement)(u,Object.assign({},R(u.props,x(F(s,["ref"]))),d,y,{ref:o(u.ref,y.ref)},T))}return(0,react.createElement)(a,Object.assign({},F(s,["ref"]),a!==react.Fragment&&y,a!==react.Fragment&&d),u)}function k(...r){return r.every((t=>null==t))?void 0:t=>{for(let e of r)null!=e&&("function"==typeof e?e(t):e.current=t)}}function R(...r){if(0===r.length)return{};if(1===r.length)return r[0];let t={},e={};for(let o of r)for(let a in o)a.startsWith("on")&&"function"==typeof o[a]?(null!=e[a]||(e[a]=[]),e[a].push(o[a])):t[a]=o[a];if(t.disabled||t["aria-disabled"])return Object.assign(t,Object.fromEntries(Object.keys(e).map((o=>[o,void 0]))));for(let o in e)Object.assign(t,{[o](a,...f){let l=e[o];for(let s of l){if((a instanceof Event||(null==a?void 0:a.nativeEvent)instanceof Event)&&a.defaultPrevented)return;s(a,...f)}}});return t}function U(r){var t;return Object.assign((0,react.forwardRef)(r),{displayName:null!=(t=r.displayName)?t:r.name})}function x(r){let t=Object.assign({},r);for(let e in t)void 0===t[e]&&delete t[e];return t}function F(r,t=[]){let e=Object.assign({},r);for(let n of t)n in e&&delete e[n];return e}var hidden_s=(e=>(e[e.None=1]="None",e[e.Focusable=2]="Focusable",e[e.Hidden=4]="Hidden",e))(hidden_s||{});let hidden_u=U((function l(d,o){var n;let{features:t=1,...e}=d;return C({ourProps:{ref:o,"aria-hidden":!(2&~t)||(null!=(n=e["aria-hidden"])?n:void 0),hidden:!(4&~t)||void 0,style:{position:"fixed",top:1,left:1,width:1,height:0,padding:0,margin:-1,overflow:"hidden",clip:"rect(0, 0, 0, 0)",whiteSpace:"nowrap",borderWidth:"0",...!(4&~t)&&!!(2&~t)&&{display:"none"}}},theirProps:e,slot:{},defaultTag:"div",name:"Hidden"})}));let active_element_history_t=[];!function document_ready_t(n){function e(){"loading"!==document.readyState&&(n(),document.removeEventListener("DOMContentLoaded",e))}"undefined"!=typeof window&&"undefined"!=typeof document&&(document.addEventListener("DOMContentLoaded",e),e())}((()=>{function e(n){n.target instanceof HTMLElement&&n.target!==document.body&&active_element_history_t[0]!==n.target&&(active_element_history_t.unshift(n.target),active_element_history_t=active_element_history_t.filter((r=>null!=r&&r.isConnected)),active_element_history_t.splice(10))}window.addEventListener("click",e,{capture:!0}),window.addEventListener("mousedown",e,{capture:!0}),window.addEventListener("focus",e,{capture:!0}),document.body.addEventListener("click",e,{capture:!0}),document.body.addEventListener("mousedown",e,{capture:!0}),document.body.addEventListener("focus",e,{capture:!0})}));let focus_management_c=["[contentEditable=true]","[tabindex]","a[href]","area[href]","button:not([disabled])","iframe","input:not([disabled])","select:not([disabled])","textarea:not([disabled])"].map((e=>`${e}:not([tabindex='-1'])`)).join(",");var focus_management_M=(n=>(n[n.First=1]="First",n[n.Previous=2]="Previous",n[n.Next=4]="Next",n[n.Last=8]="Last",n[n.WrapAround=16]="WrapAround",n[n.NoScroll=32]="NoScroll",n))(focus_management_M||{}),N=(o=>(o[o.Error=0]="Error",o[o.Overflow=1]="Overflow",o[o.Success=2]="Success",o[o.Underflow=3]="Underflow",o))(N||{}),focus_management_F=(t=>(t[t.Previous=-1]="Previous",t[t.Next=1]="Next",t))(focus_management_F||{});function focus_management_f(e=document.body){return null==e?[]:Array.from(e.querySelectorAll(focus_management_c)).sort(((r,t)=>Math.sign((r.tabIndex||Number.MAX_SAFE_INTEGER)-(t.tabIndex||Number.MAX_SAFE_INTEGER))))}var focus_management_T=(t=>(t[t.Strict=0]="Strict",t[t.Loose=1]="Loose",t))(focus_management_T||{});function h(e,r=0){var t;return e!==(null==(t=owner_o(e))?void 0:t.body)&&match_u(r,{0:()=>e.matches(focus_management_c),1(){let l=e;for(;null!==l;){if(l.matches(focus_management_c))return!0;l=l.parentElement}return!1}})}var w=(t=>(t[t.Keyboard=0]="Keyboard",t[t.Mouse=1]="Mouse",t))(w||{});function focus_management_y(e){null==e||e.focus({preventScroll:!0})}"undefined"!=typeof window&&"undefined"!=typeof document&&(document.addEventListener("keydown",(e=>{e.metaKey||e.altKey||e.ctrlKey||(document.documentElement.dataset.headlessuiFocusVisible="")}),!0),document.addEventListener("click",(e=>{1===e.detail?delete document.documentElement.dataset.headlessuiFocusVisible:0===e.detail&&(document.documentElement.dataset.headlessuiFocusVisible="")}),!0));let focus_management_S=["textarea","input"].join(",");function focus_management_O(e,r,{sorted:t=!0,relativeTo:l=null,skipElements:o=[]}={}){let i=Array.isArray(e)?e.length>0?e[0].ownerDocument:document:e.ownerDocument,n=Array.isArray(e)?t?function focus_management_I(e,r=(t=>t)){return e.slice().sort(((t,l)=>{let o=r(t),i=r(l);if(null===o||null===i)return 0;let n=o.compareDocumentPosition(i);return n&Node.DOCUMENT_POSITION_FOLLOWING?-1:n&Node.DOCUMENT_POSITION_PRECEDING?1:0}))}(e):e:focus_management_f(e);o.length>0&&n.length>1&&(n=n.filter((s=>!o.includes(s)))),l=null!=l?l:i.activeElement;let u,E=(()=>{if(5&r)return 1;if(10&r)return-1;throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last")})(),x=(()=>{if(1&r)return 0;if(2&r)return Math.max(0,n.indexOf(l))-1;if(4&r)return Math.max(0,n.indexOf(l))+1;if(8&r)return n.length-1;throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last")})(),p=32&r?{preventScroll:!0}:{},d=0,a=n.length;do{if(d>=a||d+a<=0)return 0;let s=x+d;if(16&r)s=(s+a)%a;else{if(s<0)return 3;if(s>=a)return 1}u=n[s],null==u||u.focus(p),d+=E}while(u!==i.activeElement);return 6&r&&function focus_management_H(e){var r,t;return null!=(t=null==(r=null==e?void 0:e.matches)?void 0:r.call(e,focus_management_S))&&t}(u)&&u.select(),2}var console=__webpack_require__("./node_modules/console-browserify/index.js");function P(t){if(!t)return new Set;if("function"==typeof t)return new Set(t());let n=new Set;for(let e of t.current)e.current instanceof HTMLElement&&n.add(e.current);return n}var focus_trap_=(r=>(r[r.None=1]="None",r[r.InitialFocus=2]="InitialFocus",r[r.TabLock=4]="TabLock",r[r.FocusLock=8]="FocusLock",r[r.RestoreFocus=16]="RestoreFocus",r[r.All=30]="All",r))(focus_trap_||{});let focus_trap_D=U((function z(t,n){let e=(0,react.useRef)(null),o=use_sync_refs_y(e,n),{initialFocus:l,containers:c,features:r=30,...s}=t;use_server_handoff_complete_l()||(r=1);let i=use_owner_n(e);Y({ownerDocument:i},Boolean(16&r));let u=function Z({ownerDocument:t,container:n,initialFocus:e},o){let l=(0,react.useRef)(null),c=f();return use_watch_m((()=>{if(!o)return;let r=n.current;r&&micro_task_t((()=>{if(!c.current)return;let s=null==t?void 0:t.activeElement;if(null!=e&&e.current){if((null==e?void 0:e.current)===s)return void(l.current=s)}else if(r.contains(s))return void(l.current=s);null!=e&&e.current?focus_management_y(e.current):focus_management_O(r,focus_management_M.First)===N.Error&&console.warn("There are no focusable elements inside the <FocusTrap />"),l.current=null==t?void 0:t.activeElement}))}),[o]),l}({ownerDocument:i,container:e,initialFocus:l},Boolean(2&r));!function $({ownerDocument:t,container:n,containers:e,previousActiveElement:o},l){let c=f();use_event_listener_E(null==t?void 0:t.defaultView,"focus",(r=>{if(!l||!c.current)return;let s=P(e);n.current instanceof HTMLElement&&s.add(n.current);let i=o.current;if(!i)return;let u=r.target;u&&u instanceof HTMLElement?focus_trap_S(s,u)?(o.current=u,focus_management_y(u)):(r.preventDefault(),r.stopPropagation(),focus_management_y(i)):focus_management_y(o.current)}),!0)}({ownerDocument:i,container:e,containers:c,previousActiveElement:u},Boolean(8&r));let y=function use_tab_direction_n(){let e=(0,react.useRef)(0);return use_window_event_s("keydown",(o=>{"Tab"===o.key&&(e.current=o.shiftKey?1:0)}),!0),e}(),R=use_event_o((a=>{let m=e.current;m&&match_u(y.current,{[use_tab_direction_s.Forwards]:()=>{focus_management_O(m,focus_management_M.First,{skipElements:[a.relatedTarget]})},[use_tab_direction_s.Backwards]:()=>{focus_management_O(m,focus_management_M.Last,{skipElements:[a.relatedTarget]})}})})),h=function p(){let[e]=(0,react.useState)(disposables_o);return(0,react.useEffect)((()=>()=>e.dispose()),[e]),e}(),H=(0,react.useRef)(!1),j={ref:o,onKeyDown(a){"Tab"==a.key&&(H.current=!0,h.requestAnimationFrame((()=>{H.current=!1})))},onBlur(a){let m=P(c);e.current instanceof HTMLElement&&m.add(e.current);let T=a.relatedTarget;T instanceof HTMLElement&&"true"!==T.dataset.headlessuiFocusGuard&&(focus_trap_S(m,T)||(H.current?focus_management_O(e.current,match_u(y.current,{[use_tab_direction_s.Forwards]:()=>focus_management_M.Next,[use_tab_direction_s.Backwards]:()=>focus_management_M.Previous})|focus_management_M.WrapAround,{relativeTo:a.target}):a.target instanceof HTMLElement&&focus_management_y(a.target)))}};return react.createElement(react.Fragment,null,Boolean(4&r)&&react.createElement(hidden_u,{as:"button",type:"button","data-headlessui-focus-guard":!0,onFocus:R,features:hidden_s.Focusable}),C({ourProps:j,theirProps:s,defaultTag:"div",name:"FocusTrap"}),Boolean(4&r)&&react.createElement(hidden_u,{as:"button",type:"button","data-headlessui-focus-guard":!0,onFocus:R,features:hidden_s.Focusable}))})),focus_trap_de=Object.assign(focus_trap_D,{features:focus_trap_});function Y({ownerDocument:t},n){let e=function Q(t=!0){let n=(0,react.useRef)(active_element_history_t.slice());return use_watch_m((([e],[o])=>{!0===o&&!1===e&&micro_task_t((()=>{n.current.splice(0)})),!1===o&&!0===e&&(n.current=active_element_history_t.slice())}),[t,active_element_history_t,n]),use_event_o((()=>{var e;return null!=(e=n.current.find((o=>null!=o&&o.isConnected)))?e:null}))}(n);use_watch_m((()=>{n||(null==t?void 0:t.activeElement)===(null==t?void 0:t.body)&&focus_management_y(e())}),[n]),c((()=>{n&&focus_management_y(e())}))}function focus_trap_S(t,n){for(let e of t)if(e.contains(n))return!0;return!1}var react_dom=__webpack_require__("./node_modules/next/dist/compiled/react-dom/index.js");let e=(0,react.createContext)(!1);function portal_force_root_a(){return(0,react.useContext)(e)}function portal_force_root_l(o){return react.createElement(e.Provider,{value:o.force},o.children)}let portal_U=react.Fragment;let portal_S=react.Fragment,portal_=(0,react.createContext)(null);let portal_f=(0,react.createContext)(null);let portal_D=U((function portal_N(p,n){let l=p,e=(0,react.useRef)(null),a=use_sync_refs_y(function use_sync_refs_T(t,n=!0){return Object.assign(t,{[u]:n})}((u=>{e.current=u})),n),o=use_owner_n(e),t=function portal_F(p){let n=portal_force_root_a(),l=(0,react.useContext)(portal_),e=use_owner_n(p),[a,o]=(0,react.useState)((()=>{if(!n&&null!==l||s.isServer)return null;let t=null==e?void 0:e.getElementById("headlessui-portal-root");if(t)return t;if(null===e)return null;let r=e.createElement("div");return r.setAttribute("id","headlessui-portal-root"),e.body.appendChild(r)}));return(0,react.useEffect)((()=>{null!==a&&(null!=e&&e.body.contains(a)||null==e||e.body.appendChild(a))}),[a,e]),(0,react.useEffect)((()=>{n||null!==l&&o(l.current)}),[l,o,n]),a}(e),[r]=(0,react.useState)((()=>{var u;return s.isServer?null:null!=(u=null==o?void 0:o.createElement("div"))?u:null})),i=(0,react.useContext)(portal_f),v=use_server_handoff_complete_l();return use_iso_morphic_effect_l((()=>{!t||!r||t.contains(r)||(r.setAttribute("data-headlessui-portal",""),t.appendChild(r))}),[t,r]),use_iso_morphic_effect_l((()=>{if(r&&i)return i.register(r)}),[i,r]),c((()=>{var u;!t||!r||(r instanceof Node&&t.contains(r)&&t.removeChild(r),t.childNodes.length<=0&&(null==(u=t.parentElement)||u.removeChild(t)))})),v&&t&&r?(0,react_dom.createPortal)(C({ourProps:{ref:a},theirProps:l,defaultTag:portal_U,name:"Portal"}),r):null})),portal_I=U((function portal_j(p,n){let{target:l,...e}=p,o={ref:use_sync_refs_y(n)};return react.createElement(portal_.Provider,{value:l},C({ourProps:o,theirProps:e,defaultTag:portal_S,name:"Popover.Group"}))})),portal_te=Object.assign(portal_D,{Group:portal_I});const useSyncExternalStoreShimClient_d="function"==typeof Object.is?Object.is:function useSyncExternalStoreShimClient_i(e,t){return e===t&&(0!==e||1/e==1/t)||e!=e&&t!=t},{useState:useSyncExternalStoreShimClient_u,useEffect:useSyncExternalStoreShimClient_h,useLayoutEffect:useSyncExternalStoreShimClient_f,useDebugValue:useSyncExternalStoreShimClient_p}=react_namespaceObject;function useSyncExternalStoreShimClient_r(e){const t=e.getSnapshot,c=e.value;try{const a=t();return!useSyncExternalStoreShimClient_d(c,a)}catch{return!0}}"undefined"!=typeof window&&void 0!==window.document&&window.document.createElement;const a=(n=>n.useSyncExternalStore)(react_namespaceObject);function adjust_scrollbar_padding_c(){let o;return{before({doc:e}){var l;let n=e.documentElement;o=(null!=(l=e.defaultView)?l:window).innerWidth-n.clientWidth},after({doc:e,d:n}){let t=e.documentElement,l=t.clientWidth-t.offsetWidth,r=o-l;n.style(t,"paddingRight",`${r}px`)}}}function platform_t(){return/iPhone/gi.test(window.navigator.platform)||/Mac/gi.test(window.navigator.platform)&&window.navigator.maxTouchPoints>0}function n(){return platform_t()||function platform_i(){return/Android/gi.test(window.navigator.userAgent)}()}function overflow_store_m(e){let n={};for(let t of e)Object.assign(n,t(n));return n}let overflow_store_a=function store_a(o,r){let t=o(),n=new Set;return{getSnapshot:()=>t,subscribe:e=>(n.add(e),()=>n.delete(e)),dispatch(e,...s){let i=r[e].call(t,...s);i&&(t=i,n.forEach((c=>c())))}}}((()=>new Map),{PUSH(e,n){var o;let t=null!=(o=this.get(e))?o:{doc:e,count:0,d:disposables_o(),meta:new Set};return t.count++,t.meta.add(n),this.set(e,t),this},POP(e,n){let t=this.get(e);return t&&(t.count--,t.meta.delete(n)),this},SCROLL_PREVENT({doc:e,d:n,meta:t}){let o={doc:e,d:n,meta:overflow_store_m(t)},c=[platform_t()?{before({doc:r,d:l,meta:c}){function o(a){return c.containers.flatMap((n=>n())).some((n=>n.contains(a)))}l.microTask((()=>{var s;if("auto"!==window.getComputedStyle(r.documentElement).scrollBehavior){let t=disposables_o();t.style(r.documentElement,"scrollBehavior","auto"),l.add((()=>l.microTask((()=>t.dispose()))))}let a=null!=(s=window.scrollY)?s:window.pageYOffset,n=null;l.addEventListener(r,"click",(t=>{if(t.target instanceof HTMLElement)try{let e=t.target.closest("a");if(!e)return;let{hash:f}=new URL(e.href),i=r.querySelector(f);i&&!o(i)&&(n=i)}catch{}}),!0),l.addEventListener(r,"touchstart",(t=>{if(t.target instanceof HTMLElement)if(o(t.target)){let e=t.target;for(;e.parentElement&&o(e.parentElement);)e=e.parentElement;l.style(e,"overscrollBehavior","contain")}else l.style(t.target,"touchAction","none")})),l.addEventListener(r,"touchmove",(t=>{if(t.target instanceof HTMLElement)if(o(t.target)){let e=t.target;for(;e.parentElement&&""!==e.dataset.headlessuiPortal&&!(e.scrollHeight>e.clientHeight||e.scrollWidth>e.clientWidth);)e=e.parentElement;""===e.dataset.headlessuiPortal&&t.preventDefault()}else t.preventDefault()}),{passive:!1}),l.add((()=>{var e;let t=null!=(e=window.scrollY)?e:window.pageYOffset;a!==t&&window.scrollTo(0,a),n&&n.isConnected&&(n.scrollIntoView({block:"nearest"}),n=null)}))}))}}:{},adjust_scrollbar_padding_c(),{before({doc:e,d:o}){o.style(e.documentElement,"overflow","hidden")}}];c.forEach((({before:r})=>null==r?void 0:r(o))),c.forEach((({after:r})=>null==r?void 0:r(o)))},SCROLL_ALLOW({d:e}){e.dispose()},TEARDOWN({doc:e}){this.delete(e)}});function use_document_overflow_p(e,r,n){let f=function use_store_S(t){return a(t.subscribe,t.getSnapshot,t.getSnapshot)}(overflow_store_a),o=e?f.get(e):void 0,i=!!o&&o.count>0;return use_iso_morphic_effect_l((()=>{if(e&&r)return overflow_store_a.dispatch("PUSH",e,n),()=>overflow_store_a.dispatch("POP",e,n)}),[r,e]),i}var use_id_o;overflow_store_a.subscribe((()=>{let e=overflow_store_a.getSnapshot(),n=new Map;for(let[t]of e)n.set(t,t.documentElement.style.overflow);for(let t of e.values()){let o="hidden"===n.get(t.doc),c=0!==t.count;(c&&!o||!c&&o)&&overflow_store_a.dispatch(t.count>0?"SCROLL_PREVENT":"SCROLL_ALLOW",t),0===t.count&&overflow_store_a.dispatch("TEARDOWN",t)}}));let use_id_I=null!=(use_id_o=react.useId)?use_id_o:function(){let n=use_server_handoff_complete_l(),[e,u]=react.useState(n?()=>s.nextId():null);return use_iso_morphic_effect_l((()=>{null===e&&u(s.nextId())}),[e]),null!=e?""+e:void 0},use_inert_u=new Map,use_inert_t=new Map;function use_inert_b(r,l=!0){use_iso_morphic_effect_l((()=>{var o;if(!l)return;let e="function"==typeof r?r():r.current;if(!e)return;let f=null!=(o=use_inert_t.get(e))?o:0;return use_inert_t.set(e,f+1),0!==f||(use_inert_u.set(e,{"aria-hidden":e.getAttribute("aria-hidden"),inert:e.inert}),e.setAttribute("aria-hidden","true"),e.inert=!0),function a(){var d;if(!e)return;let i=null!=(d=use_inert_t.get(e))?d:1;if(1===i?use_inert_t.delete(e):use_inert_t.set(e,i-1),1!==i)return;let n=use_inert_u.get(e);n&&(null===n["aria-hidden"]?e.removeAttribute("aria-hidden"):e.setAttribute("aria-hidden",n["aria-hidden"]),e.inert=n.inert,use_inert_u.delete(e))}}),[r,l])}function use_document_event_d(e,r,n){let o=use_latest_value_s(r);(0,react.useEffect)((()=>{function t(u){o.current(u)}return document.addEventListener(e,t,n),()=>document.removeEventListener(e,t,n)}),[e,n])}function use_outside_click_y(s,m,a=!0){let i=(0,react.useRef)(!1);function c(e,r){if(!i.current||e.defaultPrevented)return;let t=r(e);if(null===t||!t.getRootNode().contains(t)||!t.isConnected)return;let E=function u(n){return"function"==typeof n?u(n()):Array.isArray(n)||n instanceof Set?n:[n]}(s);for(let u of E){if(null===u)continue;let n=u instanceof HTMLElement?u:u.current;if(null!=n&&n.contains(t)||e.composed&&e.composedPath().includes(n))return}return!h(t,focus_management_T.Loose)&&-1!==t.tabIndex&&e.preventDefault(),m(e,t)}(0,react.useEffect)((()=>{requestAnimationFrame((()=>{i.current=a}))}),[a]);let o=(0,react.useRef)(null);use_document_event_d("pointerdown",(e=>{var r,t;i.current&&(o.current=(null==(t=null==(r=e.composedPath)?void 0:r.call(e))?void 0:t[0])||e.target)}),!0),use_document_event_d("mousedown",(e=>{var r,t;i.current&&(o.current=(null==(t=null==(r=e.composedPath)?void 0:r.call(e))?void 0:t[0])||e.target)}),!0),use_document_event_d("click",(e=>{n()||o.current&&(c(e,(()=>o.current)),o.current=null)}),!0),use_document_event_d("touchend",(e=>c(e,(()=>e.target instanceof HTMLElement?e.target:null))),!0),use_window_event_s("blur",(e=>c(e,(()=>window.document.activeElement instanceof HTMLIFrameElement?window.document.activeElement:null))),!0)}let open_closed_n=(0,react.createContext)(null);open_closed_n.displayName="OpenClosedContext";var open_closed_d=(e=>(e[e.Open=1]="Open",e[e.Closed=2]="Closed",e[e.Closing=4]="Closing",e[e.Opening=8]="Opening",e))(open_closed_d||{});let stack_context_a=(0,react.createContext)((()=>{}));stack_context_a.displayName="StackContext";var stack_context_s=(e=>(e[e.Add=0]="Add",e[e.Remove=1]="Remove",e))(stack_context_s||{});function stack_context_b({children:i,onUpdate:r,type:e,element:n,enabled:u}){let l=function stack_context_x(){return(0,react.useContext)(stack_context_a)}(),o=use_event_o(((...t)=>{null==r||r(...t),l(...t)}));return use_iso_morphic_effect_l((()=>{let t=void 0===u||!0===u;return t&&o(0,e,n),()=>{t&&o(1,e,n)}}),[o,e,n,u]),react.createElement(stack_context_a.Provider,{value:o},i)}function bugs_r(n){let e=n.parentElement,l=null;for(;e&&!(e instanceof HTMLFieldSetElement);)e instanceof HTMLLegendElement&&(l=e),e=e.parentElement;let t=""===(null==e?void 0:e.getAttribute("disabled"));return(!t||!function bugs_i(n){if(!n)return!1;let e=n.previousElementSibling;for(;null!==e;){if(e instanceof HTMLLegendElement)return!1;e=e.previousElementSibling}return!0}(l))&&t}let description_d=(0,react.createContext)(null);function description_f(){let r=(0,react.useContext)(description_d);if(null===r){let t=new Error("You used a <Description /> component, but it is not inside a relevant parent.");throw Error.captureStackTrace&&Error.captureStackTrace(t,description_f),t}return r}let description_h=U((function description_S(r,t){let a=use_id_I(),{id:e=`headlessui-description-${a}`,...i}=r,n=description_f(),s=use_sync_refs_y(t);return use_iso_morphic_effect_l((()=>n.register(e)),[e,n.register]),C({ourProps:{ref:s,...n.props,id:e},theirProps:i,slot:n.slot||{},defaultTag:"p",name:n.name||"Description"})})),G=Object.assign(description_h,{});var keyboard_o=(r=>(r.Space=" ",r.Enter="Enter",r.Escape="Escape",r.Backspace="Backspace",r.Delete="Delete",r.ArrowLeft="ArrowLeft",r.ArrowUp="ArrowUp",r.ArrowRight="ArrowRight",r.ArrowDown="ArrowDown",r.Home="Home",r.End="End",r.PageUp="PageUp",r.PageDown="PageDown",r.Tab="Tab",r))(keyboard_o||{}),dialog_console=__webpack_require__("./node_modules/console-browserify/index.js"),Me=(r=>(r[r.Open=0]="Open",r[r.Closed=1]="Closed",r))(Me||{}),we=(e=>(e[e.SetTitleId=0]="SetTitleId",e))(we||{});let He={0:(o,e)=>o.titleId===e.id?o:{...o,titleId:e.id}},dialog_I=(0,react.createContext)(null);function dialog_b(o){let e=(0,react.useContext)(dialog_I);if(null===e){let r=new Error(`<${o} /> is missing a parent <Dialog /> component.`);throw Error.captureStackTrace&&Error.captureStackTrace(r,dialog_b),r}return e}function Ge(o,e){return match_u(e.type,He,o,e)}dialog_I.displayName="DialogContext";let Ue=O.RenderStrategy|O.Static;let ze=U((function We(o,e){let r=use_id_I(),{id:i=`headlessui-dialog-${r}`,open:n,onClose:l,initialFocus:s,role:a="dialog",__demoMode:T=!1,...m}=o,[M,f]=(0,react.useState)(0),U=(0,react.useRef)(!1);a="dialog"===a||"alertdialog"===a?a:(U.current||(U.current=!0,dialog_console.warn(`Invalid role [${a}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)),"dialog");let E=function open_closed_u(){return(0,react.useContext)(open_closed_n)}();void 0===n&&null!==E&&(n=(E&open_closed_d.Open)===open_closed_d.Open);let D=(0,react.useRef)(null),ee=use_sync_refs_y(D,e),g=use_owner_n(D),W=o.hasOwnProperty("open")||null!==E,$=o.hasOwnProperty("onClose");if(!W&&!$)throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");if(!W)throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");if(!$)throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");if("boolean"!=typeof n)throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${n}`);if("function"!=typeof l)throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${l}`);let p=n?0:1,[h,te]=(0,react.useReducer)(Ge,{titleId:null,descriptionId:null,panelRef:(0,react.createRef)()}),P=use_event_o((()=>l(!1))),Y=use_event_o((t=>te({type:0,id:t}))),S=!!use_server_handoff_complete_l()&&(!T&&0===p),x=M>1,j=null!==(0,react.useContext)(dialog_I),[oe,re]=function portal_ee(){let p=(0,react.useContext)(portal_f),n=(0,react.useRef)([]),l=use_event_o((o=>(n.current.push(o),p&&p.register(o),()=>e(o)))),e=use_event_o((o=>{let t=n.current.indexOf(o);-1!==t&&n.current.splice(t,1),p&&p.unregister(o)})),a=(0,react.useMemo)((()=>({register:l,unregister:e,portals:n})),[l,e,n]);return[n,(0,react.useMemo)((()=>function({children:t}){return react.createElement(portal_f.Provider,{value:a},t)}),[a])]}(),ne={get current(){var t;return null!=(t=h.panelRef.current)?t:D.current}},{resolveContainers:w,mainTreeNodeRef:L,MainTreeNode:le}=function use_root_containers_N({defaultContainers:o=[],portals:r,mainTreeNodeRef:u}={}){var f;let t=(0,react.useRef)(null!=(f=null==u?void 0:u.current)?f:null),l=use_owner_n(t),c=use_event_o((()=>{var i,s,a;let n=[];for(let e of o)null!==e&&(e instanceof HTMLElement?n.push(e):"current"in e&&e.current instanceof HTMLElement&&n.push(e.current));if(null!=r&&r.current)for(let e of r.current)n.push(e);for(let e of null!=(i=null==l?void 0:l.querySelectorAll("html > *, body > *"))?i:[])e!==document.body&&e!==document.head&&e instanceof HTMLElement&&"headlessui-portal-root"!==e.id&&(e.contains(t.current)||e.contains(null==(a=null==(s=t.current)?void 0:s.getRootNode())?void 0:a.host)||n.some((L=>e.contains(L)))||n.push(e));return n}));return{resolveContainers:c,contains:use_event_o((n=>c().some((i=>i.contains(n))))),mainTreeNodeRef:t,MainTreeNode:(0,react.useMemo)((()=>function(){return null!=u?null:react.createElement(hidden_u,{features:hidden_s.Hidden,ref:t})}),[t,u])}}({portals:oe,defaultContainers:[ne]}),ae=x?"parent":"leaf",J=null!==E&&(E&open_closed_d.Closing)===open_closed_d.Closing,ie=!j&&!J&&S,se=(0,react.useCallback)((()=>{var t,c;return null!=(c=Array.from(null!=(t=null==g?void 0:g.querySelectorAll("body > *"))?t:[]).find((d=>"headlessui-portal-root"!==d.id&&(d.contains(L.current)&&d instanceof HTMLElement))))?c:null}),[L]);use_inert_b(se,ie);let pe=!!x||S,de=(0,react.useCallback)((()=>{var t,c;return null!=(c=Array.from(null!=(t=null==g?void 0:g.querySelectorAll("[data-headlessui-portal]"))?t:[]).find((d=>d.contains(L.current)&&d instanceof HTMLElement)))?c:null}),[L]);use_inert_b(de,pe),use_outside_click_y(w,(t=>{t.preventDefault(),P()}),!(!S||x));let fe=!(x||0!==p);use_event_listener_E(null==g?void 0:g.defaultView,"keydown",(t=>{fe&&(t.defaultPrevented||t.key===keyboard_o.Escape&&(t.preventDefault(),t.stopPropagation(),P()))})),function Be(o,e,r=(()=>[document.body])){use_document_overflow_p(o,e,(i=>{var n;return{containers:[...null!=(n=i.containers)?n:[],r]}}))}(g,!(J||0!==p||j),w),(0,react.useEffect)((()=>{if(0!==p||!D.current)return;let t=new ResizeObserver((c=>{for(let d of c){let F=d.target.getBoundingClientRect();0===F.x&&0===F.y&&0===F.width&&0===F.height&&P()}}));return t.observe(D.current),()=>t.disconnect()}),[p,D,P]);let[Te,ce]=function description_w(){let[r,t]=(0,react.useState)([]);return[r.length>0?r.join(" "):void 0,(0,react.useMemo)((()=>function(e){let i=use_event_o((s=>(t((o=>[...o,s])),()=>t((o=>{let p=o.slice(),c=p.indexOf(s);return-1!==c&&p.splice(c,1),p}))))),n=(0,react.useMemo)((()=>({register:i,slot:e.slot,name:e.name,props:e.props})),[i,e.slot,e.name,e.props]);return react.createElement(description_d.Provider,{value:n},e.children)}),[t])]}(),De=(0,react.useMemo)((()=>[{dialogState:p,close:P,setTitleId:Y},h]),[p,h,P,Y]),X=(0,react.useMemo)((()=>({open:0===p})),[p]),me={ref:ee,id:i,role:a,"aria-modal":0===p||void 0,"aria-labelledby":h.titleId,"aria-describedby":Te};return react.createElement(stack_context_b,{type:"Dialog",enabled:0===p,element:D,onUpdate:use_event_o(((t,c)=>{"Dialog"===c&&match_u(t,{[stack_context_s.Add]:()=>f((d=>d+1)),[stack_context_s.Remove]:()=>f((d=>d-1))})}))},react.createElement(portal_force_root_l,{force:!0},react.createElement(portal_te,null,react.createElement(dialog_I.Provider,{value:De},react.createElement(portal_te.Group,{target:D},react.createElement(portal_force_root_l,{force:!1},react.createElement(ce,{slot:X,name:"Dialog.Description"},react.createElement(focus_trap_de,{initialFocus:s,containers:w,features:S?match_u(ae,{parent:focus_trap_de.features.RestoreFocus,leaf:focus_trap_de.features.All&~focus_trap_de.features.FocusLock}):focus_trap_de.features.None},react.createElement(re,null,C({ourProps:me,theirProps:m,slot:X,defaultTag:"div",features:Ue,visible:0===p,name:"Dialog"}))))))))),react.createElement(le,null))})),Qe=U((function Je(o,e){let r=use_id_I(),{id:i=`headlessui-dialog-backdrop-${r}`,...n}=o,[{dialogState:l},s]=dialog_b("Dialog.Backdrop"),a=use_sync_refs_y(e);(0,react.useEffect)((()=>{if(null===s.panelRef.current)throw new Error("A <Dialog.Backdrop /> component is being used, but a <Dialog.Panel /> component is missing.")}),[s.panelRef]);let T=(0,react.useMemo)((()=>({open:0===l})),[l]);return react.createElement(portal_force_root_l,{force:!0},react.createElement(portal_te,null,C({ourProps:{ref:a,id:i,"aria-hidden":!0},theirProps:n,slot:T,defaultTag:"div",name:"Dialog.Backdrop"})))})),Ze=U((function Ke(o,e){let r=use_id_I(),{id:i=`headlessui-dialog-panel-${r}`,...n}=o,[{dialogState:l},s]=dialog_b("Dialog.Panel"),a=use_sync_refs_y(e,s.panelRef),T=(0,react.useMemo)((()=>({open:0===l})),[l]),m=use_event_o((f=>{f.stopPropagation()}));return C({ourProps:{ref:a,id:i,onClick:m},theirProps:n,slot:T,defaultTag:"div",name:"Dialog.Panel"})})),et=U((function Ye(o,e){let r=use_id_I(),{id:i=`headlessui-dialog-overlay-${r}`,...n}=o,[{dialogState:l,close:s}]=dialog_b("Dialog.Overlay"),a=use_sync_refs_y(e),T=use_event_o((f=>{if(f.target===f.currentTarget){if(bugs_r(f.currentTarget))return f.preventDefault();f.preventDefault(),f.stopPropagation(),s()}}));return C({ourProps:{ref:a,id:i,"aria-hidden":!0,onClick:T},theirProps:n,slot:(0,react.useMemo)((()=>({open:0===l})),[l]),defaultTag:"div",name:"Dialog.Overlay"})})),tt=U((function qe(o,e){let r=use_id_I(),{id:i=`headlessui-dialog-title-${r}`,...n}=o,[{dialogState:l,setTitleId:s}]=dialog_b("Dialog.Title"),a=use_sync_refs_y(e);(0,react.useEffect)((()=>(s(i),()=>s(null))),[i,s]);let T=(0,react.useMemo)((()=>({open:0===l})),[l]);return C({ourProps:{ref:a,id:i},theirProps:n,slot:T,defaultTag:"h2",name:"Dialog.Title"})})),_t=Object.assign(ze,{Backdrop:Qe,Panel:Ze,Overlay:et,Title:tt,Description:G})},"./node_modules/axios/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{F0:()=>isAxiosError});var _lib_axios_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/axios/lib/axios.js");const{Axios,AxiosError,CanceledError,isCancel,CancelToken,VERSION,all,Cancel,isAxiosError,spread,toFormData,AxiosHeaders,HttpStatusCode,formToJSON,getAdapter,mergeConfig}=_lib_axios_js__WEBPACK_IMPORTED_MODULE_0__.A},"./node_modules/axios/lib/axios.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{A:()=>lib_axios});var common_utils_namespaceObject={};function bind(fn,thisArg){return function wrap(){return fn.apply(thisArg,arguments)}}__webpack_require__.r(common_utils_namespaceObject),__webpack_require__.d(common_utils_namespaceObject,{hasBrowserEnv:()=>hasBrowserEnv,hasStandardBrowserEnv:()=>hasStandardBrowserEnv,hasStandardBrowserWebWorkerEnv:()=>hasStandardBrowserWebWorkerEnv});const{toString:utils_toString}=Object.prototype,{getPrototypeOf}=Object,kindOf=(cache=Object.create(null),thing=>{const str=utils_toString.call(thing);return cache[str]||(cache[str]=str.slice(8,-1).toLowerCase())});var cache;const kindOfTest=type=>(type=type.toLowerCase(),thing=>kindOf(thing)===type),typeOfTest=type=>thing=>typeof thing===type,{isArray}=Array,isUndefined=typeOfTest("undefined");const isArrayBuffer=kindOfTest("ArrayBuffer");const isString=typeOfTest("string"),isFunction=typeOfTest("function"),isNumber=typeOfTest("number"),isObject=thing=>null!==thing&&"object"==typeof thing,isPlainObject=val=>{if("object"!==kindOf(val))return!1;const prototype=getPrototypeOf(val);return!(null!==prototype&&prototype!==Object.prototype&&null!==Object.getPrototypeOf(prototype)||Symbol.toStringTag in val||Symbol.iterator in val)},isDate=kindOfTest("Date"),isFile=kindOfTest("File"),isBlob=kindOfTest("Blob"),isFileList=kindOfTest("FileList"),isURLSearchParams=kindOfTest("URLSearchParams");function forEach(obj,fn,{allOwnKeys=!1}={}){if(null==obj)return;let i,l;if("object"!=typeof obj&&(obj=[obj]),isArray(obj))for(i=0,l=obj.length;i<l;i++)fn.call(null,obj[i],i,obj);else{const keys=allOwnKeys?Object.getOwnPropertyNames(obj):Object.keys(obj),len=keys.length;let key;for(i=0;i<len;i++)key=keys[i],fn.call(null,obj[key],key,obj)}}function findKey(obj,key){key=key.toLowerCase();const keys=Object.keys(obj);let _key,i=keys.length;for(;i-- >0;)if(_key=keys[i],key===_key.toLowerCase())return _key;return null}const _global="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:__webpack_require__.g,isContextDefined=context=>!isUndefined(context)&&context!==_global;const isTypedArray=(TypedArray="undefined"!=typeof Uint8Array&&getPrototypeOf(Uint8Array),thing=>TypedArray&&thing instanceof TypedArray);var TypedArray;const isHTMLForm=kindOfTest("HTMLFormElement"),utils_hasOwnProperty=(({hasOwnProperty})=>(obj,prop)=>hasOwnProperty.call(obj,prop))(Object.prototype),isRegExp=kindOfTest("RegExp"),reduceDescriptors=(obj,reducer)=>{const descriptors=Object.getOwnPropertyDescriptors(obj),reducedDescriptors={};forEach(descriptors,((descriptor,name)=>{let ret;!1!==(ret=reducer(descriptor,name,obj))&&(reducedDescriptors[name]=ret||descriptor)})),Object.defineProperties(obj,reducedDescriptors)},ALPHA="abcdefghijklmnopqrstuvwxyz",ALPHABET={DIGIT:"0123456789",ALPHA,ALPHA_DIGIT:ALPHA+ALPHA.toUpperCase()+"0123456789"};const isAsyncFn=kindOfTest("AsyncFunction"),utils={isArray,isArrayBuffer,isBuffer:function isBuffer(val){return null!==val&&!isUndefined(val)&&null!==val.constructor&&!isUndefined(val.constructor)&&isFunction(val.constructor.isBuffer)&&val.constructor.isBuffer(val)},isFormData:thing=>{let kind;return thing&&("function"==typeof FormData&&thing instanceof FormData||isFunction(thing.append)&&("formdata"===(kind=kindOf(thing))||"object"===kind&&isFunction(thing.toString)&&"[object FormData]"===thing.toString()))},isArrayBufferView:function isArrayBufferView(val){let result;return result="undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(val):val&&val.buffer&&isArrayBuffer(val.buffer),result},isString,isNumber,isBoolean:thing=>!0===thing||!1===thing,isObject,isPlainObject,isUndefined,isDate,isFile,isBlob,isRegExp,isFunction,isStream:val=>isObject(val)&&isFunction(val.pipe),isURLSearchParams,isTypedArray,isFileList,forEach,merge:function merge(){const{caseless}=isContextDefined(this)&&this||{},result={},assignValue=(val,key)=>{const targetKey=caseless&&findKey(result,key)||key;isPlainObject(result[targetKey])&&isPlainObject(val)?result[targetKey]=merge(result[targetKey],val):isPlainObject(val)?result[targetKey]=merge({},val):isArray(val)?result[targetKey]=val.slice():result[targetKey]=val};for(let i=0,l=arguments.length;i<l;i++)arguments[i]&&forEach(arguments[i],assignValue);return result},extend:(a,b,thisArg,{allOwnKeys}={})=>(forEach(b,((val,key)=>{thisArg&&isFunction(val)?a[key]=bind(val,thisArg):a[key]=val}),{allOwnKeys}),a),trim:str=>str.trim?str.trim():str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,""),stripBOM:content=>(65279===content.charCodeAt(0)&&(content=content.slice(1)),content),inherits:(constructor,superConstructor,props,descriptors)=>{constructor.prototype=Object.create(superConstructor.prototype,descriptors),constructor.prototype.constructor=constructor,Object.defineProperty(constructor,"super",{value:superConstructor.prototype}),props&&Object.assign(constructor.prototype,props)},toFlatObject:(sourceObj,destObj,filter,propFilter)=>{let props,i,prop;const merged={};if(destObj=destObj||{},null==sourceObj)return destObj;do{for(props=Object.getOwnPropertyNames(sourceObj),i=props.length;i-- >0;)prop=props[i],propFilter&&!propFilter(prop,sourceObj,destObj)||merged[prop]||(destObj[prop]=sourceObj[prop],merged[prop]=!0);sourceObj=!1!==filter&&getPrototypeOf(sourceObj)}while(sourceObj&&(!filter||filter(sourceObj,destObj))&&sourceObj!==Object.prototype);return destObj},kindOf,kindOfTest,endsWith:(str,searchString,position)=>{str=String(str),(void 0===position||position>str.length)&&(position=str.length),position-=searchString.length;const lastIndex=str.indexOf(searchString,position);return-1!==lastIndex&&lastIndex===position},toArray:thing=>{if(!thing)return null;if(isArray(thing))return thing;let i=thing.length;if(!isNumber(i))return null;const arr=new Array(i);for(;i-- >0;)arr[i]=thing[i];return arr},forEachEntry:(obj,fn)=>{const iterator=(obj&&obj[Symbol.iterator]).call(obj);let result;for(;(result=iterator.next())&&!result.done;){const pair=result.value;fn.call(obj,pair[0],pair[1])}},matchAll:(regExp,str)=>{let matches;const arr=[];for(;null!==(matches=regExp.exec(str));)arr.push(matches);return arr},isHTMLForm,hasOwnProperty:utils_hasOwnProperty,hasOwnProp:utils_hasOwnProperty,reduceDescriptors,freezeMethods:obj=>{reduceDescriptors(obj,((descriptor,name)=>{if(isFunction(obj)&&-1!==["arguments","caller","callee"].indexOf(name))return!1;const value=obj[name];isFunction(value)&&(descriptor.enumerable=!1,"writable"in descriptor?descriptor.writable=!1:descriptor.set||(descriptor.set=()=>{throw Error("Can not rewrite read-only method '"+name+"'")}))}))},toObjectSet:(arrayOrString,delimiter)=>{const obj={},define=arr=>{arr.forEach((value=>{obj[value]=!0}))};return isArray(arrayOrString)?define(arrayOrString):define(String(arrayOrString).split(delimiter)),obj},toCamelCase:str=>str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,(function replacer(m,p1,p2){return p1.toUpperCase()+p2})),noop:()=>{},toFiniteNumber:(value,defaultValue)=>(value=+value,Number.isFinite(value)?value:defaultValue),findKey,global:_global,isContextDefined,ALPHABET,generateString:(size=16,alphabet=ALPHABET.ALPHA_DIGIT)=>{let str="";const{length}=alphabet;for(;size--;)str+=alphabet[Math.random()*length|0];return str},isSpecCompliantForm:function isSpecCompliantForm(thing){return!!(thing&&isFunction(thing.append)&&"FormData"===thing[Symbol.toStringTag]&&thing[Symbol.iterator])},toJSONObject:obj=>{const stack=new Array(10),visit=(source,i)=>{if(isObject(source)){if(stack.indexOf(source)>=0)return;if(!("toJSON"in source)){stack[i]=source;const target=isArray(source)?[]:{};return forEach(source,((value,key)=>{const reducedValue=visit(value,i+1);!isUndefined(reducedValue)&&(target[key]=reducedValue)})),stack[i]=void 0,target}}return source};return visit(obj,0)},isAsyncFn,isThenable:thing=>thing&&(isObject(thing)||isFunction(thing))&&isFunction(thing.then)&&isFunction(thing.catch)};function AxiosError(message,code,config,request,response){Error.call(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=(new Error).stack,this.message=message,this.name="AxiosError",code&&(this.code=code),config&&(this.config=config),request&&(this.request=request),response&&(this.response=response)}utils.inherits(AxiosError,Error,{toJSON:function toJSON(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:utils.toJSONObject(this.config),code:this.code,status:this.response&&this.response.status?this.response.status:null}}});const AxiosError_prototype=AxiosError.prototype,descriptors={};["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED","ERR_NOT_SUPPORT","ERR_INVALID_URL"].forEach((code=>{descriptors[code]={value:code}})),Object.defineProperties(AxiosError,descriptors),Object.defineProperty(AxiosError_prototype,"isAxiosError",{value:!0}),AxiosError.from=(error,code,config,request,response,customProps)=>{const axiosError=Object.create(AxiosError_prototype);return utils.toFlatObject(error,axiosError,(function filter(obj){return obj!==Error.prototype}),(prop=>"isAxiosError"!==prop)),AxiosError.call(axiosError,error.message,code,config,request,response),axiosError.cause=error,axiosError.name=error.name,customProps&&Object.assign(axiosError,customProps),axiosError};const core_AxiosError=AxiosError;var Buffer=__webpack_require__("./node_modules/buffer/index.js").hp;function isVisitable(thing){return utils.isPlainObject(thing)||utils.isArray(thing)}function removeBrackets(key){return utils.endsWith(key,"[]")?key.slice(0,-2):key}function renderKey(path,key,dots){return path?path.concat(key).map((function each(token,i){return token=removeBrackets(token),!dots&&i?"["+token+"]":token})).join(dots?".":""):key}const predicates=utils.toFlatObject(utils,{},null,(function filter(prop){return/^is[A-Z]/.test(prop)}));const helpers_toFormData=function toFormData(obj,formData,options){if(!utils.isObject(obj))throw new TypeError("target must be an object");formData=formData||new FormData;const metaTokens=(options=utils.toFlatObject(options,{metaTokens:!0,dots:!1,indexes:!1},!1,(function defined(option,source){return!utils.isUndefined(source[option])}))).metaTokens,visitor=options.visitor||defaultVisitor,dots=options.dots,indexes=options.indexes,useBlob=(options.Blob||"undefined"!=typeof Blob&&Blob)&&utils.isSpecCompliantForm(formData);if(!utils.isFunction(visitor))throw new TypeError("visitor must be a function");function convertValue(value){if(null===value)return"";if(utils.isDate(value))return value.toISOString();if(!useBlob&&utils.isBlob(value))throw new core_AxiosError("Blob is not supported. Use a Buffer instead.");return utils.isArrayBuffer(value)||utils.isTypedArray(value)?useBlob&&"function"==typeof Blob?new Blob([value]):Buffer.from(value):value}function defaultVisitor(value,key,path){let arr=value;if(value&&!path&&"object"==typeof value)if(utils.endsWith(key,"{}"))key=metaTokens?key:key.slice(0,-2),value=JSON.stringify(value);else if(utils.isArray(value)&&function isFlatArray(arr){return utils.isArray(arr)&&!arr.some(isVisitable)}(value)||(utils.isFileList(value)||utils.endsWith(key,"[]"))&&(arr=utils.toArray(value)))return key=removeBrackets(key),arr.forEach((function each(el,index){!utils.isUndefined(el)&&null!==el&&formData.append(!0===indexes?renderKey([key],index,dots):null===indexes?key:key+"[]",convertValue(el))})),!1;return!!isVisitable(value)||(formData.append(renderKey(path,key,dots),convertValue(value)),!1)}const stack=[],exposedHelpers=Object.assign(predicates,{defaultVisitor,convertValue,isVisitable});if(!utils.isObject(obj))throw new TypeError("data must be an object");return function build(value,path){if(!utils.isUndefined(value)){if(-1!==stack.indexOf(value))throw Error("Circular reference detected in "+path.join("."));stack.push(value),utils.forEach(value,(function each(el,key){!0===(!(utils.isUndefined(el)||null===el)&&visitor.call(formData,el,utils.isString(key)?key.trim():key,path,exposedHelpers))&&build(el,path?path.concat(key):[key])})),stack.pop()}}(obj),formData};function encode(str){const charMap={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+","%00":"\0"};return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g,(function replacer(match){return charMap[match]}))}function AxiosURLSearchParams(params,options){this._pairs=[],params&&helpers_toFormData(params,this,options)}const AxiosURLSearchParams_prototype=AxiosURLSearchParams.prototype;AxiosURLSearchParams_prototype.append=function append(name,value){this._pairs.push([name,value])},AxiosURLSearchParams_prototype.toString=function toString(encoder){const _encode=encoder?function(value){return encoder.call(this,value,encode)}:encode;return this._pairs.map((function each(pair){return _encode(pair[0])+"="+_encode(pair[1])}),"").join("&")};const helpers_AxiosURLSearchParams=AxiosURLSearchParams;function buildURL_encode(val){return encodeURIComponent(val).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}function buildURL(url,params,options){if(!params)return url;const _encode=options&&options.encode||buildURL_encode,serializeFn=options&&options.serialize;let serializedParams;if(serializedParams=serializeFn?serializeFn(params,options):utils.isURLSearchParams(params)?params.toString():new helpers_AxiosURLSearchParams(params,options).toString(_encode),serializedParams){const hashmarkIndex=url.indexOf("#");-1!==hashmarkIndex&&(url=url.slice(0,hashmarkIndex)),url+=(-1===url.indexOf("?")?"?":"&")+serializedParams}return url}const core_InterceptorManager=class InterceptorManager{constructor(){this.handlers=[]}use(fulfilled,rejected,options){return this.handlers.push({fulfilled,rejected,synchronous:!!options&&options.synchronous,runWhen:options?options.runWhen:null}),this.handlers.length-1}eject(id){this.handlers[id]&&(this.handlers[id]=null)}clear(){this.handlers&&(this.handlers=[])}forEach(fn){utils.forEach(this.handlers,(function forEachHandler(h){null!==h&&fn(h)}))}},defaults_transitional={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},browser={isBrowser:!0,classes:{URLSearchParams:"undefined"!=typeof URLSearchParams?URLSearchParams:helpers_AxiosURLSearchParams,FormData:"undefined"!=typeof FormData?FormData:null,Blob:"undefined"!=typeof Blob?Blob:null},protocols:["http","https","file","blob","url","data"]},hasBrowserEnv="undefined"!=typeof window&&"undefined"!=typeof document,hasStandardBrowserEnv=(product="undefined"!=typeof navigator&&navigator.product,hasBrowserEnv&&["ReactNative","NativeScript","NS"].indexOf(product)<0);var product;const hasStandardBrowserWebWorkerEnv="undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&"function"==typeof self.importScripts,platform={...common_utils_namespaceObject,...browser};const helpers_formDataToJSON=function formDataToJSON(formData){function buildPath(path,value,target,index){let name=path[index++];if("__proto__"===name)return!0;const isNumericKey=Number.isFinite(+name),isLast=index>=path.length;if(name=!name&&utils.isArray(target)?target.length:name,isLast)return utils.hasOwnProp(target,name)?target[name]=[target[name],value]:target[name]=value,!isNumericKey;target[name]&&utils.isObject(target[name])||(target[name]=[]);return buildPath(path,value,target[name],index)&&utils.isArray(target[name])&&(target[name]=function arrayToObject(arr){const obj={},keys=Object.keys(arr);let i;const len=keys.length;let key;for(i=0;i<len;i++)key=keys[i],obj[key]=arr[key];return obj}(target[name])),!isNumericKey}if(utils.isFormData(formData)&&utils.isFunction(formData.entries)){const obj={};return utils.forEachEntry(formData,((name,value)=>{buildPath(function parsePropPath(name){return utils.matchAll(/\w+|\[(\w*)]/g,name).map((match=>"[]"===match[0]?"":match[1]||match[0]))}(name),value,obj,0)})),obj}return null};const defaults={transitional:defaults_transitional,adapter:["xhr","http"],transformRequest:[function transformRequest(data,headers){const contentType=headers.getContentType()||"",hasJSONContentType=contentType.indexOf("application/json")>-1,isObjectPayload=utils.isObject(data);isObjectPayload&&utils.isHTMLForm(data)&&(data=new FormData(data));if(utils.isFormData(data))return hasJSONContentType?JSON.stringify(helpers_formDataToJSON(data)):data;if(utils.isArrayBuffer(data)||utils.isBuffer(data)||utils.isStream(data)||utils.isFile(data)||utils.isBlob(data))return data;if(utils.isArrayBufferView(data))return data.buffer;if(utils.isURLSearchParams(data))return headers.setContentType("application/x-www-form-urlencoded;charset=utf-8",!1),data.toString();let isFileList;if(isObjectPayload){if(contentType.indexOf("application/x-www-form-urlencoded")>-1)return function toURLEncodedForm(data,options){return helpers_toFormData(data,new platform.classes.URLSearchParams,Object.assign({visitor:function(value,key,path,helpers){return platform.isNode&&utils.isBuffer(value)?(this.append(key,value.toString("base64")),!1):helpers.defaultVisitor.apply(this,arguments)}},options))}(data,this.formSerializer).toString();if((isFileList=utils.isFileList(data))||contentType.indexOf("multipart/form-data")>-1){const _FormData=this.env&&this.env.FormData;return helpers_toFormData(isFileList?{"files[]":data}:data,_FormData&&new _FormData,this.formSerializer)}}return isObjectPayload||hasJSONContentType?(headers.setContentType("application/json",!1),function stringifySafely(rawValue,parser,encoder){if(utils.isString(rawValue))try{return(parser||JSON.parse)(rawValue),utils.trim(rawValue)}catch(e){if("SyntaxError"!==e.name)throw e}return(encoder||JSON.stringify)(rawValue)}(data)):data}],transformResponse:[function transformResponse(data){const transitional=this.transitional||defaults.transitional,forcedJSONParsing=transitional&&transitional.forcedJSONParsing,JSONRequested="json"===this.responseType;if(data&&utils.isString(data)&&(forcedJSONParsing&&!this.responseType||JSONRequested)){const strictJSONParsing=!(transitional&&transitional.silentJSONParsing)&&JSONRequested;try{return JSON.parse(data)}catch(e){if(strictJSONParsing){if("SyntaxError"===e.name)throw core_AxiosError.from(e,core_AxiosError.ERR_BAD_RESPONSE,this,null,this.response);throw e}}}return data}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:platform.classes.FormData,Blob:platform.classes.Blob},validateStatus:function validateStatus(status){return status>=200&&status<300},headers:{common:{Accept:"application/json, text/plain, */*","Content-Type":void 0}}};utils.forEach(["delete","get","head","post","put","patch"],(method=>{defaults.headers[method]={}}));const lib_defaults=defaults,ignoreDuplicateOf=utils.toObjectSet(["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"]),$internals=Symbol("internals");function normalizeHeader(header){return header&&String(header).trim().toLowerCase()}function normalizeValue(value){return!1===value||null==value?value:utils.isArray(value)?value.map(normalizeValue):String(value)}function matchHeaderValue(context,value,header,filter,isHeaderNameFilter){return utils.isFunction(filter)?filter.call(this,value,header):(isHeaderNameFilter&&(value=header),utils.isString(value)?utils.isString(filter)?-1!==value.indexOf(filter):utils.isRegExp(filter)?filter.test(value):void 0:void 0)}class AxiosHeaders{constructor(headers){headers&&this.set(headers)}set(header,valueOrRewrite,rewrite){const self=this;function setHeader(_value,_header,_rewrite){const lHeader=normalizeHeader(_header);if(!lHeader)throw new Error("header name must be a non-empty string");const key=utils.findKey(self,lHeader);(!key||void 0===self[key]||!0===_rewrite||void 0===_rewrite&&!1!==self[key])&&(self[key||_header]=normalizeValue(_value))}const setHeaders=(headers,_rewrite)=>utils.forEach(headers,((_value,_header)=>setHeader(_value,_header,_rewrite)));return utils.isPlainObject(header)||header instanceof this.constructor?setHeaders(header,valueOrRewrite):utils.isString(header)&&(header=header.trim())&&!/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(header.trim())?setHeaders((rawHeaders=>{const parsed={};let key,val,i;return rawHeaders&&rawHeaders.split("\n").forEach((function parser(line){i=line.indexOf(":"),key=line.substring(0,i).trim().toLowerCase(),val=line.substring(i+1).trim(),!key||parsed[key]&&ignoreDuplicateOf[key]||("set-cookie"===key?parsed[key]?parsed[key].push(val):parsed[key]=[val]:parsed[key]=parsed[key]?parsed[key]+", "+val:val)})),parsed})(header),valueOrRewrite):null!=header&&setHeader(valueOrRewrite,header,rewrite),this}get(header,parser){if(header=normalizeHeader(header)){const key=utils.findKey(this,header);if(key){const value=this[key];if(!parser)return value;if(!0===parser)return function parseTokens(str){const tokens=Object.create(null),tokensRE=/([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;let match;for(;match=tokensRE.exec(str);)tokens[match[1]]=match[2];return tokens}(value);if(utils.isFunction(parser))return parser.call(this,value,key);if(utils.isRegExp(parser))return parser.exec(value);throw new TypeError("parser must be boolean|regexp|function")}}}has(header,matcher){if(header=normalizeHeader(header)){const key=utils.findKey(this,header);return!(!key||void 0===this[key]||matcher&&!matchHeaderValue(0,this[key],key,matcher))}return!1}delete(header,matcher){const self=this;let deleted=!1;function deleteHeader(_header){if(_header=normalizeHeader(_header)){const key=utils.findKey(self,_header);!key||matcher&&!matchHeaderValue(0,self[key],key,matcher)||(delete self[key],deleted=!0)}}return utils.isArray(header)?header.forEach(deleteHeader):deleteHeader(header),deleted}clear(matcher){const keys=Object.keys(this);let i=keys.length,deleted=!1;for(;i--;){const key=keys[i];matcher&&!matchHeaderValue(0,this[key],key,matcher,!0)||(delete this[key],deleted=!0)}return deleted}normalize(format){const self=this,headers={};return utils.forEach(this,((value,header)=>{const key=utils.findKey(headers,header);if(key)return self[key]=normalizeValue(value),void delete self[header];const normalized=format?function formatHeader(header){return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g,((w,char,str)=>char.toUpperCase()+str))}(header):String(header).trim();normalized!==header&&delete self[header],self[normalized]=normalizeValue(value),headers[normalized]=!0})),this}concat(...targets){return this.constructor.concat(this,...targets)}toJSON(asStrings){const obj=Object.create(null);return utils.forEach(this,((value,header)=>{null!=value&&!1!==value&&(obj[header]=asStrings&&utils.isArray(value)?value.join(", "):value)})),obj}[Symbol.iterator](){return Object.entries(this.toJSON())[Symbol.iterator]()}toString(){return Object.entries(this.toJSON()).map((([header,value])=>header+": "+value)).join("\n")}get[Symbol.toStringTag](){return"AxiosHeaders"}static from(thing){return thing instanceof this?thing:new this(thing)}static concat(first,...targets){const computed=new this(first);return targets.forEach((target=>computed.set(target))),computed}static accessor(header){const accessors=(this[$internals]=this[$internals]={accessors:{}}).accessors,prototype=this.prototype;function defineAccessor(_header){const lHeader=normalizeHeader(_header);accessors[lHeader]||(!function buildAccessors(obj,header){const accessorName=utils.toCamelCase(" "+header);["get","set","has"].forEach((methodName=>{Object.defineProperty(obj,methodName+accessorName,{value:function(arg1,arg2,arg3){return this[methodName].call(this,header,arg1,arg2,arg3)},configurable:!0})}))}(prototype,_header),accessors[lHeader]=!0)}return utils.isArray(header)?header.forEach(defineAccessor):defineAccessor(header),this}}AxiosHeaders.accessor(["Content-Type","Content-Length","Accept","Accept-Encoding","User-Agent","Authorization"]),utils.reduceDescriptors(AxiosHeaders.prototype,(({value},key)=>{let mapped=key[0].toUpperCase()+key.slice(1);return{get:()=>value,set(headerValue){this[mapped]=headerValue}}})),utils.freezeMethods(AxiosHeaders);const core_AxiosHeaders=AxiosHeaders;function transformData(fns,response){const config=this||lib_defaults,context=response||config,headers=core_AxiosHeaders.from(context.headers);let data=context.data;return utils.forEach(fns,(function transform(fn){data=fn.call(config,data,headers.normalize(),response?response.status:void 0)})),headers.normalize(),data}function isCancel(value){return!(!value||!value.__CANCEL__)}function CanceledError(message,config,request){core_AxiosError.call(this,null==message?"canceled":message,core_AxiosError.ERR_CANCELED,config,request),this.name="CanceledError"}utils.inherits(CanceledError,core_AxiosError,{__CANCEL__:!0});const cancel_CanceledError=CanceledError;const cookies=platform.hasStandardBrowserEnv?{write(name,value,expires,path,domain,secure){const cookie=[name+"="+encodeURIComponent(value)];utils.isNumber(expires)&&cookie.push("expires="+new Date(expires).toGMTString()),utils.isString(path)&&cookie.push("path="+path),utils.isString(domain)&&cookie.push("domain="+domain),!0===secure&&cookie.push("secure"),document.cookie=cookie.join("; ")},read(name){const match=document.cookie.match(new RegExp("(^|;\\s*)("+name+")=([^;]*)"));return match?decodeURIComponent(match[3]):null},remove(name){this.write(name,"",Date.now()-864e5)}}:{write(){},read:()=>null,remove(){}};function buildFullPath(baseURL,requestedURL){return baseURL&&!function isAbsoluteURL(url){return/^([a-z][a-z\d+\-.]*:)?\/\//i.test(url)}(requestedURL)?function combineURLs(baseURL,relativeURL){return relativeURL?baseURL.replace(/\/?\/$/,"")+"/"+relativeURL.replace(/^\/+/,""):baseURL}(baseURL,requestedURL):requestedURL}const isURLSameOrigin=platform.hasStandardBrowserEnv?function standardBrowserEnv(){const msie=/(msie|trident)/i.test(navigator.userAgent),urlParsingNode=document.createElement("a");let originURL;function resolveURL(url){let href=url;return msie&&(urlParsingNode.setAttribute("href",href),href=urlParsingNode.href),urlParsingNode.setAttribute("href",href),{href:urlParsingNode.href,protocol:urlParsingNode.protocol?urlParsingNode.protocol.replace(/:$/,""):"",host:urlParsingNode.host,search:urlParsingNode.search?urlParsingNode.search.replace(/^\?/,""):"",hash:urlParsingNode.hash?urlParsingNode.hash.replace(/^#/,""):"",hostname:urlParsingNode.hostname,port:urlParsingNode.port,pathname:"/"===urlParsingNode.pathname.charAt(0)?urlParsingNode.pathname:"/"+urlParsingNode.pathname}}return originURL=resolveURL(window.location.href),function isURLSameOrigin(requestURL){const parsed=utils.isString(requestURL)?resolveURL(requestURL):requestURL;return parsed.protocol===originURL.protocol&&parsed.host===originURL.host}}():function isURLSameOrigin(){return!0};const helpers_speedometer=function speedometer(samplesCount,min){samplesCount=samplesCount||10;const bytes=new Array(samplesCount),timestamps=new Array(samplesCount);let firstSampleTS,head=0,tail=0;return min=void 0!==min?min:1e3,function push(chunkLength){const now=Date.now(),startedAt=timestamps[tail];firstSampleTS||(firstSampleTS=now),bytes[head]=chunkLength,timestamps[head]=now;let i=tail,bytesCount=0;for(;i!==head;)bytesCount+=bytes[i++],i%=samplesCount;if(head=(head+1)%samplesCount,head===tail&&(tail=(tail+1)%samplesCount),now-firstSampleTS<min)return;const passed=startedAt&&now-startedAt;return passed?Math.round(1e3*bytesCount/passed):void 0}};function progressEventReducer(listener,isDownloadStream){let bytesNotified=0;const _speedometer=helpers_speedometer(50,250);return e=>{const loaded=e.loaded,total=e.lengthComputable?e.total:void 0,progressBytes=loaded-bytesNotified,rate=_speedometer(progressBytes);bytesNotified=loaded;const data={loaded,total,progress:total?loaded/total:void 0,bytes:progressBytes,rate:rate||void 0,estimated:rate&&total&&loaded<=total?(total-loaded)/rate:void 0,event:e};data[isDownloadStream?"download":"upload"]=!0,listener(data)}}const knownAdapters={http:null,xhr:"undefined"!=typeof XMLHttpRequest&&function(config){return new Promise((function dispatchXhrRequest(resolve,reject){let requestData=config.data;const requestHeaders=core_AxiosHeaders.from(config.headers).normalize();let onCanceled,contentType,{responseType,withXSRFToken}=config;function done(){config.cancelToken&&config.cancelToken.unsubscribe(onCanceled),config.signal&&config.signal.removeEventListener("abort",onCanceled)}if(utils.isFormData(requestData))if(platform.hasStandardBrowserEnv||platform.hasStandardBrowserWebWorkerEnv)requestHeaders.setContentType(!1);else if(!1!==(contentType=requestHeaders.getContentType())){const[type,...tokens]=contentType?contentType.split(";").map((token=>token.trim())).filter(Boolean):[];requestHeaders.setContentType([type||"multipart/form-data",...tokens].join("; "))}let request=new XMLHttpRequest;if(config.auth){const username=config.auth.username||"",password=config.auth.password?unescape(encodeURIComponent(config.auth.password)):"";requestHeaders.set("Authorization","Basic "+btoa(username+":"+password))}const fullPath=buildFullPath(config.baseURL,config.url);function onloadend(){if(!request)return;const responseHeaders=core_AxiosHeaders.from("getAllResponseHeaders"in request&&request.getAllResponseHeaders());!function settle(resolve,reject,response){const validateStatus=response.config.validateStatus;response.status&&validateStatus&&!validateStatus(response.status)?reject(new core_AxiosError("Request failed with status code "+response.status,[core_AxiosError.ERR_BAD_REQUEST,core_AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status/100)-4],response.config,response.request,response)):resolve(response)}((function _resolve(value){resolve(value),done()}),(function _reject(err){reject(err),done()}),{data:responseType&&"text"!==responseType&&"json"!==responseType?request.response:request.responseText,status:request.status,statusText:request.statusText,headers:responseHeaders,config,request}),request=null}if(request.open(config.method.toUpperCase(),buildURL(fullPath,config.params,config.paramsSerializer),!0),request.timeout=config.timeout,"onloadend"in request?request.onloadend=onloadend:request.onreadystatechange=function handleLoad(){request&&4===request.readyState&&(0!==request.status||request.responseURL&&0===request.responseURL.indexOf("file:"))&&setTimeout(onloadend)},request.onabort=function handleAbort(){request&&(reject(new core_AxiosError("Request aborted",core_AxiosError.ECONNABORTED,config,request)),request=null)},request.onerror=function handleError(){reject(new core_AxiosError("Network Error",core_AxiosError.ERR_NETWORK,config,request)),request=null},request.ontimeout=function handleTimeout(){let timeoutErrorMessage=config.timeout?"timeout of "+config.timeout+"ms exceeded":"timeout exceeded";const transitional=config.transitional||defaults_transitional;config.timeoutErrorMessage&&(timeoutErrorMessage=config.timeoutErrorMessage),reject(new core_AxiosError(timeoutErrorMessage,transitional.clarifyTimeoutError?core_AxiosError.ETIMEDOUT:core_AxiosError.ECONNABORTED,config,request)),request=null},platform.hasStandardBrowserEnv&&(withXSRFToken&&utils.isFunction(withXSRFToken)&&(withXSRFToken=withXSRFToken(config)),withXSRFToken||!1!==withXSRFToken&&isURLSameOrigin(fullPath))){const xsrfValue=config.xsrfHeaderName&&config.xsrfCookieName&&cookies.read(config.xsrfCookieName);xsrfValue&&requestHeaders.set(config.xsrfHeaderName,xsrfValue)}void 0===requestData&&requestHeaders.setContentType(null),"setRequestHeader"in request&&utils.forEach(requestHeaders.toJSON(),(function setRequestHeader(val,key){request.setRequestHeader(key,val)})),utils.isUndefined(config.withCredentials)||(request.withCredentials=!!config.withCredentials),responseType&&"json"!==responseType&&(request.responseType=config.responseType),"function"==typeof config.onDownloadProgress&&request.addEventListener("progress",progressEventReducer(config.onDownloadProgress,!0)),"function"==typeof config.onUploadProgress&&request.upload&&request.upload.addEventListener("progress",progressEventReducer(config.onUploadProgress)),(config.cancelToken||config.signal)&&(onCanceled=cancel=>{request&&(reject(!cancel||cancel.type?new cancel_CanceledError(null,config,request):cancel),request.abort(),request=null)},config.cancelToken&&config.cancelToken.subscribe(onCanceled),config.signal&&(config.signal.aborted?onCanceled():config.signal.addEventListener("abort",onCanceled)));const protocol=function parseProtocol(url){const match=/^([-+\w]{1,25})(:?\/\/|:)/.exec(url);return match&&match[1]||""}(fullPath);protocol&&-1===platform.protocols.indexOf(protocol)?reject(new core_AxiosError("Unsupported protocol "+protocol+":",core_AxiosError.ERR_BAD_REQUEST,config)):request.send(requestData||null)}))}};utils.forEach(knownAdapters,((fn,value)=>{if(fn){try{Object.defineProperty(fn,"name",{value})}catch(e){}Object.defineProperty(fn,"adapterName",{value})}}));const renderReason=reason=>`- ${reason}`,isResolvedHandle=adapter=>utils.isFunction(adapter)||null===adapter||!1===adapter,adapters_getAdapter=adapters=>{adapters=utils.isArray(adapters)?adapters:[adapters];const{length}=adapters;let nameOrAdapter,adapter;const rejectedReasons={};for(let i=0;i<length;i++){let id;if(nameOrAdapter=adapters[i],adapter=nameOrAdapter,!isResolvedHandle(nameOrAdapter)&&(adapter=knownAdapters[(id=String(nameOrAdapter)).toLowerCase()],void 0===adapter))throw new core_AxiosError(`Unknown adapter '${id}'`);if(adapter)break;rejectedReasons[id||"#"+i]=adapter}if(!adapter){const reasons=Object.entries(rejectedReasons).map((([id,state])=>`adapter ${id} `+(!1===state?"is not supported by the environment":"is not available in the build")));let s=length?reasons.length>1?"since :\n"+reasons.map(renderReason).join("\n"):" "+renderReason(reasons[0]):"as no adapter specified";throw new core_AxiosError("There is no suitable adapter to dispatch the request "+s,"ERR_NOT_SUPPORT")}return adapter};function throwIfCancellationRequested(config){if(config.cancelToken&&config.cancelToken.throwIfRequested(),config.signal&&config.signal.aborted)throw new cancel_CanceledError(null,config)}function dispatchRequest(config){throwIfCancellationRequested(config),config.headers=core_AxiosHeaders.from(config.headers),config.data=transformData.call(config,config.transformRequest),-1!==["post","put","patch"].indexOf(config.method)&&config.headers.setContentType("application/x-www-form-urlencoded",!1);return adapters_getAdapter(config.adapter||lib_defaults.adapter)(config).then((function onAdapterResolution(response){return throwIfCancellationRequested(config),response.data=transformData.call(config,config.transformResponse,response),response.headers=core_AxiosHeaders.from(response.headers),response}),(function onAdapterRejection(reason){return isCancel(reason)||(throwIfCancellationRequested(config),reason&&reason.response&&(reason.response.data=transformData.call(config,config.transformResponse,reason.response),reason.response.headers=core_AxiosHeaders.from(reason.response.headers))),Promise.reject(reason)}))}const headersToObject=thing=>thing instanceof core_AxiosHeaders?{...thing}:thing;function mergeConfig(config1,config2){config2=config2||{};const config={};function getMergedValue(target,source,caseless){return utils.isPlainObject(target)&&utils.isPlainObject(source)?utils.merge.call({caseless},target,source):utils.isPlainObject(source)?utils.merge({},source):utils.isArray(source)?source.slice():source}function mergeDeepProperties(a,b,caseless){return utils.isUndefined(b)?utils.isUndefined(a)?void 0:getMergedValue(void 0,a,caseless):getMergedValue(a,b,caseless)}function valueFromConfig2(a,b){if(!utils.isUndefined(b))return getMergedValue(void 0,b)}function defaultToConfig2(a,b){return utils.isUndefined(b)?utils.isUndefined(a)?void 0:getMergedValue(void 0,a):getMergedValue(void 0,b)}function mergeDirectKeys(a,b,prop){return prop in config2?getMergedValue(a,b):prop in config1?getMergedValue(void 0,a):void 0}const mergeMap={url:valueFromConfig2,method:valueFromConfig2,data:valueFromConfig2,baseURL:defaultToConfig2,transformRequest:defaultToConfig2,transformResponse:defaultToConfig2,paramsSerializer:defaultToConfig2,timeout:defaultToConfig2,timeoutMessage:defaultToConfig2,withCredentials:defaultToConfig2,withXSRFToken:defaultToConfig2,adapter:defaultToConfig2,responseType:defaultToConfig2,xsrfCookieName:defaultToConfig2,xsrfHeaderName:defaultToConfig2,onUploadProgress:defaultToConfig2,onDownloadProgress:defaultToConfig2,decompress:defaultToConfig2,maxContentLength:defaultToConfig2,maxBodyLength:defaultToConfig2,beforeRedirect:defaultToConfig2,transport:defaultToConfig2,httpAgent:defaultToConfig2,httpsAgent:defaultToConfig2,cancelToken:defaultToConfig2,socketPath:defaultToConfig2,responseEncoding:defaultToConfig2,validateStatus:mergeDirectKeys,headers:(a,b)=>mergeDeepProperties(headersToObject(a),headersToObject(b),!0)};return utils.forEach(Object.keys(Object.assign({},config1,config2)),(function computeConfigValue(prop){const merge=mergeMap[prop]||mergeDeepProperties,configValue=merge(config1[prop],config2[prop],prop);utils.isUndefined(configValue)&&merge!==mergeDirectKeys||(config[prop]=configValue)})),config}var console=__webpack_require__("./node_modules/console-browserify/index.js");const validators={};["object","boolean","number","function","string","symbol"].forEach(((type,i)=>{validators[type]=function validator(thing){return typeof thing===type||"a"+(i<1?"n ":" ")+type}}));const deprecatedWarnings={};validators.transitional=function transitional(validator,version,message){function formatMessage(opt,desc){return"[Axios v1.6.8] Transitional option '"+opt+"'"+desc+(message?". "+message:"")}return(value,opt,opts)=>{if(!1===validator)throw new core_AxiosError(formatMessage(opt," has been removed"+(version?" in "+version:"")),core_AxiosError.ERR_DEPRECATED);return version&&!deprecatedWarnings[opt]&&(deprecatedWarnings[opt]=!0,console.warn(formatMessage(opt," has been deprecated since v"+version+" and will be removed in the near future"))),!validator||validator(value,opt,opts)}};const validator={assertOptions:function assertOptions(options,schema,allowUnknown){if("object"!=typeof options)throw new core_AxiosError("options must be an object",core_AxiosError.ERR_BAD_OPTION_VALUE);const keys=Object.keys(options);let i=keys.length;for(;i-- >0;){const opt=keys[i],validator=schema[opt];if(validator){const value=options[opt],result=void 0===value||validator(value,opt,options);if(!0!==result)throw new core_AxiosError("option "+opt+" must be "+result,core_AxiosError.ERR_BAD_OPTION_VALUE)}else if(!0!==allowUnknown)throw new core_AxiosError("Unknown option "+opt,core_AxiosError.ERR_BAD_OPTION)}},validators},Axios_validators=validator.validators;class Axios{constructor(instanceConfig){this.defaults=instanceConfig,this.interceptors={request:new core_InterceptorManager,response:new core_InterceptorManager}}async request(configOrUrl,config){try{return await this._request(configOrUrl,config)}catch(err){if(err instanceof Error){let dummy;Error.captureStackTrace?Error.captureStackTrace(dummy={}):dummy=new Error;const stack=dummy.stack?dummy.stack.replace(/^.+\n/,""):"";err.stack?stack&&!String(err.stack).endsWith(stack.replace(/^.+\n.+\n/,""))&&(err.stack+="\n"+stack):err.stack=stack}throw err}}_request(configOrUrl,config){"string"==typeof configOrUrl?(config=config||{}).url=configOrUrl:config=configOrUrl||{},config=mergeConfig(this.defaults,config);const{transitional,paramsSerializer,headers}=config;void 0!==transitional&&validator.assertOptions(transitional,{silentJSONParsing:Axios_validators.transitional(Axios_validators.boolean),forcedJSONParsing:Axios_validators.transitional(Axios_validators.boolean),clarifyTimeoutError:Axios_validators.transitional(Axios_validators.boolean)},!1),null!=paramsSerializer&&(utils.isFunction(paramsSerializer)?config.paramsSerializer={serialize:paramsSerializer}:validator.assertOptions(paramsSerializer,{encode:Axios_validators.function,serialize:Axios_validators.function},!0)),config.method=(config.method||this.defaults.method||"get").toLowerCase();let contextHeaders=headers&&utils.merge(headers.common,headers[config.method]);headers&&utils.forEach(["delete","get","head","post","put","patch","common"],(method=>{delete headers[method]})),config.headers=core_AxiosHeaders.concat(contextHeaders,headers);const requestInterceptorChain=[];let synchronousRequestInterceptors=!0;this.interceptors.request.forEach((function unshiftRequestInterceptors(interceptor){"function"==typeof interceptor.runWhen&&!1===interceptor.runWhen(config)||(synchronousRequestInterceptors=synchronousRequestInterceptors&&interceptor.synchronous,requestInterceptorChain.unshift(interceptor.fulfilled,interceptor.rejected))}));const responseInterceptorChain=[];let promise;this.interceptors.response.forEach((function pushResponseInterceptors(interceptor){responseInterceptorChain.push(interceptor.fulfilled,interceptor.rejected)}));let len,i=0;if(!synchronousRequestInterceptors){const chain=[dispatchRequest.bind(this),void 0];for(chain.unshift.apply(chain,requestInterceptorChain),chain.push.apply(chain,responseInterceptorChain),len=chain.length,promise=Promise.resolve(config);i<len;)promise=promise.then(chain[i++],chain[i++]);return promise}len=requestInterceptorChain.length;let newConfig=config;for(i=0;i<len;){const onFulfilled=requestInterceptorChain[i++],onRejected=requestInterceptorChain[i++];try{newConfig=onFulfilled(newConfig)}catch(error){onRejected.call(this,error);break}}try{promise=dispatchRequest.call(this,newConfig)}catch(error){return Promise.reject(error)}for(i=0,len=responseInterceptorChain.length;i<len;)promise=promise.then(responseInterceptorChain[i++],responseInterceptorChain[i++]);return promise}getUri(config){return buildURL(buildFullPath((config=mergeConfig(this.defaults,config)).baseURL,config.url),config.params,config.paramsSerializer)}}utils.forEach(["delete","get","head","options"],(function forEachMethodNoData(method){Axios.prototype[method]=function(url,config){return this.request(mergeConfig(config||{},{method,url,data:(config||{}).data}))}})),utils.forEach(["post","put","patch"],(function forEachMethodWithData(method){function generateHTTPMethod(isForm){return function httpMethod(url,data,config){return this.request(mergeConfig(config||{},{method,headers:isForm?{"Content-Type":"multipart/form-data"}:{},url,data}))}}Axios.prototype[method]=generateHTTPMethod(),Axios.prototype[method+"Form"]=generateHTTPMethod(!0)}));const core_Axios=Axios;class CancelToken{constructor(executor){if("function"!=typeof executor)throw new TypeError("executor must be a function.");let resolvePromise;this.promise=new Promise((function promiseExecutor(resolve){resolvePromise=resolve}));const token=this;this.promise.then((cancel=>{if(!token._listeners)return;let i=token._listeners.length;for(;i-- >0;)token._listeners[i](cancel);token._listeners=null})),this.promise.then=onfulfilled=>{let _resolve;const promise=new Promise((resolve=>{token.subscribe(resolve),_resolve=resolve})).then(onfulfilled);return promise.cancel=function reject(){token.unsubscribe(_resolve)},promise},executor((function cancel(message,config,request){token.reason||(token.reason=new cancel_CanceledError(message,config,request),resolvePromise(token.reason))}))}throwIfRequested(){if(this.reason)throw this.reason}subscribe(listener){this.reason?listener(this.reason):this._listeners?this._listeners.push(listener):this._listeners=[listener]}unsubscribe(listener){if(!this._listeners)return;const index=this._listeners.indexOf(listener);-1!==index&&this._listeners.splice(index,1)}static source(){let cancel;return{token:new CancelToken((function executor(c){cancel=c})),cancel}}}const cancel_CancelToken=CancelToken;const HttpStatusCode={Continue:100,SwitchingProtocols:101,Processing:102,EarlyHints:103,Ok:200,Created:201,Accepted:202,NonAuthoritativeInformation:203,NoContent:204,ResetContent:205,PartialContent:206,MultiStatus:207,AlreadyReported:208,ImUsed:226,MultipleChoices:300,MovedPermanently:301,Found:302,SeeOther:303,NotModified:304,UseProxy:305,Unused:306,TemporaryRedirect:307,PermanentRedirect:308,BadRequest:400,Unauthorized:401,PaymentRequired:402,Forbidden:403,NotFound:404,MethodNotAllowed:405,NotAcceptable:406,ProxyAuthenticationRequired:407,RequestTimeout:408,Conflict:409,Gone:410,LengthRequired:411,PreconditionFailed:412,PayloadTooLarge:413,UriTooLong:414,UnsupportedMediaType:415,RangeNotSatisfiable:416,ExpectationFailed:417,ImATeapot:418,MisdirectedRequest:421,UnprocessableEntity:422,Locked:423,FailedDependency:424,TooEarly:425,UpgradeRequired:426,PreconditionRequired:428,TooManyRequests:429,RequestHeaderFieldsTooLarge:431,UnavailableForLegalReasons:451,InternalServerError:500,NotImplemented:501,BadGateway:502,ServiceUnavailable:503,GatewayTimeout:504,HttpVersionNotSupported:505,VariantAlsoNegotiates:506,InsufficientStorage:507,LoopDetected:508,NotExtended:510,NetworkAuthenticationRequired:511};Object.entries(HttpStatusCode).forEach((([key,value])=>{HttpStatusCode[value]=key}));const helpers_HttpStatusCode=HttpStatusCode;const axios=function createInstance(defaultConfig){const context=new core_Axios(defaultConfig),instance=bind(core_Axios.prototype.request,context);return utils.extend(instance,core_Axios.prototype,context,{allOwnKeys:!0}),utils.extend(instance,context,null,{allOwnKeys:!0}),instance.create=function create(instanceConfig){return createInstance(mergeConfig(defaultConfig,instanceConfig))},instance}(lib_defaults);axios.Axios=core_Axios,axios.CanceledError=cancel_CanceledError,axios.CancelToken=cancel_CancelToken,axios.isCancel=isCancel,axios.VERSION="1.6.8",axios.toFormData=helpers_toFormData,axios.AxiosError=core_AxiosError,axios.Cancel=axios.CanceledError,axios.all=function all(promises){return Promise.all(promises)},axios.spread=function spread(callback){return function wrap(arr){return callback.apply(null,arr)}},axios.isAxiosError=function isAxiosError(payload){return utils.isObject(payload)&&!0===payload.isAxiosError},axios.mergeConfig=mergeConfig,axios.AxiosHeaders=core_AxiosHeaders,axios.formToJSON=thing=>helpers_formDataToJSON(utils.isHTMLForm(thing)?new FormData(thing):thing),axios.getAdapter=adapters_getAdapter,axios.HttpStatusCode=helpers_HttpStatusCode,axios.default=axios;const lib_axios=axios},"./node_modules/dayjs/dayjs.min.js":function(module){module.exports=function(){"use strict";var t=1e3,e=6e4,n=36e5,r="millisecond",i="second",s="minute",u="hour",a="day",o="week",c="month",f="quarter",h="year",d="date",l="Invalid Date",$=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,y=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),ordinal:function(t){var e=["th","st","nd","rd"],n=t%100;return"["+t+(e[(n-20)%10]||e[n]||e[0])+"]"}},m=function(t,e,n){var r=String(t);return!r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t},v={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return(e<=0?"+":"-")+m(r,2,"0")+":"+m(i,2,"0")},m:function t(e,n){if(e.date()<n.date())return-t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,c),s=n-i<0,u=e.clone().add(r+(s?-1:1),c);return+(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return{M:c,y:h,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:f}[t]||String(t||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},g="en",D={};D[g]=M;var p="$isDayjsObject",S=function(t){return t instanceof _||!(!t||!t[p])},w=function t(e,n,r){var i;if(!e)return g;if("string"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split("-");if(!i&&u.length>1)return t(u[0])}else{var a=e.name;D[a]=e,i=a}return!r&&i&&(g=i),i||!r&&g},O=function(t,e){if(S(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},b=v;b.l=w,b.i=S,b.w=function(t,e){return O(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=w(t.locale,null,!0),this.parse(t),this.$x=this.$x||t.x||{},this[p]=!0}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(b.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match($);if(r){var i=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.init()},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},m.$utils=function(){return b},m.isValid=function(){return!(this.$d.toString()===l)},m.isSame=function(t,e){var n=O(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return O(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<O(t)},m.$g=function(t,e,n){return b.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!b.u(e)||e,f=b.p(t),l=function(t,e){var i=b.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},$=function(t,e){return b.w(n.toDate()[t].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,v="set"+(this.$u?"UTC":"");switch(f){case h:return r?l(1,0):l(31,11);case c:return r?l(1,M):l(0,M+1);case o:var g=this.$locale().weekStart||0,D=(y<g?y+7:y)-g;return l(r?m-D:m+(6-D),M);case a:case d:return $(v+"Hours",0);case u:return $(v+"Minutes",1);case s:return $(v+"Seconds",2);case i:return $(v+"Milliseconds",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=b.p(t),f="set"+(this.$u?"UTC":""),l=(n={},n[a]=f+"Date",n[d]=f+"Date",n[c]=f+"Month",n[h]=f+"FullYear",n[u]=f+"Hours",n[s]=f+"Minutes",n[i]=f+"Seconds",n[r]=f+"Milliseconds",n)[o],$=o===a?this.$D+(e-this.$W):e;if(o===c||o===h){var y=this.clone().set(d,1);y.$d[l]($),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d}else l&&this.$d[l]($);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[b.p(t)]()},m.add=function(r,f){var d,l=this;r=Number(r);var $=b.p(f),y=function(t){var e=O(l);return b.w(e.date(e.date()+Math.round(t*r)),l)};if($===c)return this.set(c,this.$M+r);if($===h)return this.set(h,this.$y+r);if($===a)return y(1);if($===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[$]||1,m=this.$d.getTime()+r*M;return b.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||l;var r=t||"YYYY-MM-DDTHH:mm:ssZ",i=b.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,c=n.months,f=n.meridiem,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},d=function(t){return b.s(s%12||12,t,"0")},$=f||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r};return r.replace(y,(function(t,r){return r||function(t){switch(t){case"YY":return String(e.$y).slice(-2);case"YYYY":return b.s(e.$y,4,"0");case"M":return a+1;case"MM":return b.s(a+1,2,"0");case"MMM":return h(n.monthsShort,a,c,3);case"MMMM":return h(c,a);case"D":return e.$D;case"DD":return b.s(e.$D,2,"0");case"d":return String(e.$W);case"dd":return h(n.weekdaysMin,e.$W,o,2);case"ddd":return h(n.weekdaysShort,e.$W,o,3);case"dddd":return o[e.$W];case"H":return String(s);case"HH":return b.s(s,2,"0");case"h":return d(1);case"hh":return d(2);case"a":return $(s,u,!0);case"A":return $(s,u,!1);case"m":return String(u);case"mm":return b.s(u,2,"0");case"s":return String(e.$s);case"ss":return b.s(e.$s,2,"0");case"SSS":return b.s(e.$ms,3,"0");case"Z":return i}return null}(t)||i.replace(":","")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,l){var $,y=this,M=b.p(d),m=O(r),v=(m.utcOffset()-this.utcOffset())*e,g=this-m,D=function(){return b.m(y,m)};switch(M){case h:$=D()/12;break;case c:$=D();break;case f:$=D()/3;break;case o:$=(g-v)/6048e5;break;case a:$=(g-v)/864e5;break;case u:$=g/n;break;case s:$=g/e;break;case i:$=g/t;break;default:$=g}return l?$:b.a($)},m.daysInMonth=function(){return this.endOf(c).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=w(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return b.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),k=_.prototype;return O.prototype=k,[["$ms",r],["$s",i],["$m",s],["$H",u],["$W",a],["$M",c],["$y",h],["$D",d]].forEach((function(t){k[t[1]]=function(e){return this.$g(e,t[0],t[1])}})),O.extend=function(t,e){return t.$i||(t(e,_,O),t.$i=!0),O},O.locale=w,O.isDayjs=S,O.unix=function(t){return O(1e3*t)},O.en=D[g],O.Ls=D,O.p={},O}()},"./node_modules/dayjs/locale/ja.js":function(module,__unused_webpack_exports,__webpack_require__){module.exports=function(e){"use strict";function _(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var t=_(e),d={name:"ja",weekdays:"日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日".split("_"),weekdaysShort:"日_月_火_水_木_金_土".split("_"),weekdaysMin:"日_月_火_水_木_金_土".split("_"),months:"1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),monthsShort:"1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),ordinal:function(e){return e+"日"},formats:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY/MM/DD",LL:"YYYY年M月D日",LLL:"YYYY年M月D日 HH:mm",LLLL:"YYYY年M月D日 dddd HH:mm",l:"YYYY/MM/DD",ll:"YYYY年M月D日",lll:"YYYY年M月D日 HH:mm",llll:"YYYY年M月D日(ddd) HH:mm"},meridiem:function(e){return e<12?"午前":"午後"},relativeTime:{future:"%s後",past:"%s前",s:"数秒",m:"1分",mm:"%d分",h:"1時間",hh:"%d時間",d:"1日",dd:"%d日",M:"1ヶ月",MM:"%dヶ月",y:"1年",yy:"%d年"}};return t.default.locale(d,null,!0),d}(__webpack_require__("./node_modules/dayjs/dayjs.min.js"))},"./node_modules/next/dist/client/components/action-async-storage.external.js":(module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"actionAsyncStorage",{enumerable:!0,get:function(){return actionAsyncStorage}});const actionAsyncStorage=(0,__webpack_require__("./node_modules/next/dist/client/components/async-local-storage.js").createAsyncLocalStorage)();("function"==typeof exports.default||"object"==typeof exports.default&&null!==exports.default)&&void 0===exports.default.__esModule&&(Object.defineProperty(exports.default,"__esModule",{value:!0}),Object.assign(exports.default,exports),module.exports=exports.default)},"./node_modules/next/dist/client/components/async-local-storage.js":(module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"createAsyncLocalStorage",{enumerable:!0,get:function(){return createAsyncLocalStorage}});const sharedAsyncLocalStorageNotAvailableError=new Error("Invariant: AsyncLocalStorage accessed in runtime where it is not available");class FakeAsyncLocalStorage{disable(){throw sharedAsyncLocalStorageNotAvailableError}getStore(){}run(){throw sharedAsyncLocalStorageNotAvailableError}exit(){throw sharedAsyncLocalStorageNotAvailableError}enterWith(){throw sharedAsyncLocalStorageNotAvailableError}}const maybeGlobalAsyncLocalStorage=globalThis.AsyncLocalStorage;function createAsyncLocalStorage(){return maybeGlobalAsyncLocalStorage?new maybeGlobalAsyncLocalStorage:new FakeAsyncLocalStorage}("function"==typeof exports.default||"object"==typeof exports.default&&null!==exports.default)&&void 0===exports.default.__esModule&&(Object.defineProperty(exports.default,"__esModule",{value:!0}),Object.assign(exports.default,exports),module.exports=exports.default)},"./node_modules/next/dist/client/components/bailout-to-client-rendering.js":(module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"bailoutToClientRendering",{enumerable:!0,get:function(){return bailoutToClientRendering}});const _bailouttocsr=__webpack_require__("./node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js"),_staticgenerationasyncstorageexternal=__webpack_require__("./node_modules/next/dist/client/components/static-generation-async-storage.external.js");function bailoutToClientRendering(reason){const staticGenerationStore=_staticgenerationasyncstorageexternal.staticGenerationAsyncStorage.getStore();if(!(null==staticGenerationStore?void 0:staticGenerationStore.forceStatic)&&(null==staticGenerationStore?void 0:staticGenerationStore.isStaticGeneration))throw new _bailouttocsr.BailoutToCSRError(reason)}("function"==typeof exports.default||"object"==typeof exports.default&&null!==exports.default)&&void 0===exports.default.__esModule&&(Object.defineProperty(exports.default,"__esModule",{value:!0}),Object.assign(exports.default,exports),module.exports=exports.default)},"./node_modules/next/dist/client/components/navigation.js":(module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),function _export(target,all){for(var name in all)Object.defineProperty(target,name,{enumerable:!0,get:all[name]})}(exports,{ReadonlyURLSearchParams:function(){return _navigationreactserver.ReadonlyURLSearchParams},RedirectType:function(){return _navigationreactserver.RedirectType},ServerInsertedHTMLContext:function(){return _serverinsertedhtmlsharedruntime.ServerInsertedHTMLContext},notFound:function(){return _navigationreactserver.notFound},permanentRedirect:function(){return _navigationreactserver.permanentRedirect},redirect:function(){return _navigationreactserver.redirect},useParams:function(){return useParams},usePathname:function(){return usePathname},useRouter:function(){return useRouter},useSearchParams:function(){return useSearchParams},useSelectedLayoutSegment:function(){return useSelectedLayoutSegment},useSelectedLayoutSegments:function(){return useSelectedLayoutSegments},useServerInsertedHTML:function(){return _serverinsertedhtmlsharedruntime.useServerInsertedHTML}});const _react=__webpack_require__("./node_modules/next/dist/compiled/react/index.js"),_approutercontextsharedruntime=__webpack_require__("./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js"),_hooksclientcontextsharedruntime=__webpack_require__("./node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js"),_getsegmentvalue=__webpack_require__("./node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js"),_segment=__webpack_require__("./node_modules/next/dist/shared/lib/segment.js"),_navigationreactserver=__webpack_require__("./node_modules/next/dist/client/components/navigation.react-server.js"),_serverinsertedhtmlsharedruntime=__webpack_require__("./node_modules/next/dist/shared/lib/server-inserted-html.shared-runtime.js");function useSearchParams(){const searchParams=(0,_react.useContext)(_hooksclientcontextsharedruntime.SearchParamsContext),readonlySearchParams=(0,_react.useMemo)((()=>searchParams?new _navigationreactserver.ReadonlyURLSearchParams(searchParams):null),[searchParams]);if("undefined"==typeof window){const{bailoutToClientRendering}=__webpack_require__("./node_modules/next/dist/client/components/bailout-to-client-rendering.js");bailoutToClientRendering("useSearchParams()")}return readonlySearchParams}function usePathname(){return(0,_react.useContext)(_hooksclientcontextsharedruntime.PathnameContext)}function useRouter(){const router=(0,_react.useContext)(_approutercontextsharedruntime.AppRouterContext);if(null===router)throw new Error("invariant expected app router to be mounted");return router}function useParams(){return(0,_react.useContext)(_hooksclientcontextsharedruntime.PathParamsContext)}function getSelectedLayoutSegmentPath(tree,parallelRouteKey,first,segmentPath){let node;if(void 0===first&&(first=!0),void 0===segmentPath&&(segmentPath=[]),first)node=tree[1][parallelRouteKey];else{const parallelRoutes=tree[1];var _parallelRoutes_children;node=null!=(_parallelRoutes_children=parallelRoutes.children)?_parallelRoutes_children:Object.values(parallelRoutes)[0]}if(!node)return segmentPath;const segment=node[0],segmentValue=(0,_getsegmentvalue.getSegmentValue)(segment);return!segmentValue||segmentValue.startsWith(_segment.PAGE_SEGMENT_KEY)?segmentPath:(segmentPath.push(segmentValue),getSelectedLayoutSegmentPath(node,parallelRouteKey,!1,segmentPath))}function useSelectedLayoutSegments(parallelRouteKey){void 0===parallelRouteKey&&(parallelRouteKey="children");const context=(0,_react.useContext)(_approutercontextsharedruntime.LayoutRouterContext);return context?getSelectedLayoutSegmentPath(context.tree,parallelRouteKey):null}function useSelectedLayoutSegment(parallelRouteKey){void 0===parallelRouteKey&&(parallelRouteKey="children");const selectedLayoutSegments=useSelectedLayoutSegments(parallelRouteKey);if(!selectedLayoutSegments||0===selectedLayoutSegments.length)return null;const selectedLayoutSegment="children"===parallelRouteKey?selectedLayoutSegments[0]:selectedLayoutSegments[selectedLayoutSegments.length-1];return selectedLayoutSegment===_segment.DEFAULT_SEGMENT_KEY?null:selectedLayoutSegment}("function"==typeof exports.default||"object"==typeof exports.default&&null!==exports.default)&&void 0===exports.default.__esModule&&(Object.defineProperty(exports.default,"__esModule",{value:!0}),Object.assign(exports.default,exports),module.exports=exports.default)},"./node_modules/next/dist/client/components/navigation.react-server.js":(module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),function _export(target,all){for(var name in all)Object.defineProperty(target,name,{enumerable:!0,get:all[name]})}(exports,{ReadonlyURLSearchParams:function(){return ReadonlyURLSearchParams},RedirectType:function(){return _redirect.RedirectType},notFound:function(){return _notfound.notFound},permanentRedirect:function(){return _redirect.permanentRedirect},redirect:function(){return _redirect.redirect}});const _redirect=__webpack_require__("./node_modules/next/dist/client/components/redirect.js"),_notfound=__webpack_require__("./node_modules/next/dist/client/components/not-found.js");class ReadonlyURLSearchParamsError extends Error{constructor(){super("Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams")}}class ReadonlyURLSearchParams extends URLSearchParams{append(){throw new ReadonlyURLSearchParamsError}delete(){throw new ReadonlyURLSearchParamsError}set(){throw new ReadonlyURLSearchParamsError}sort(){throw new ReadonlyURLSearchParamsError}}("function"==typeof exports.default||"object"==typeof exports.default&&null!==exports.default)&&void 0===exports.default.__esModule&&(Object.defineProperty(exports.default,"__esModule",{value:!0}),Object.assign(exports.default,exports),module.exports=exports.default)},"./node_modules/next/dist/client/components/not-found.js":(module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),function _export(target,all){for(var name in all)Object.defineProperty(target,name,{enumerable:!0,get:all[name]})}(exports,{isNotFoundError:function(){return isNotFoundError},notFound:function(){return notFound}});const NOT_FOUND_ERROR_CODE="NEXT_NOT_FOUND";function notFound(){const error=new Error(NOT_FOUND_ERROR_CODE);throw error.digest=NOT_FOUND_ERROR_CODE,error}function isNotFoundError(error){return"object"==typeof error&&null!==error&&"digest"in error&&error.digest===NOT_FOUND_ERROR_CODE}("function"==typeof exports.default||"object"==typeof exports.default&&null!==exports.default)&&void 0===exports.default.__esModule&&(Object.defineProperty(exports.default,"__esModule",{value:!0}),Object.assign(exports.default,exports),module.exports=exports.default)},"./node_modules/next/dist/client/components/redirect-status-code.js":(module,exports)=>{"use strict";var RedirectStatusCode;Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"RedirectStatusCode",{enumerable:!0,get:function(){return RedirectStatusCode}}),function(RedirectStatusCode){RedirectStatusCode[RedirectStatusCode.SeeOther=303]="SeeOther",RedirectStatusCode[RedirectStatusCode.TemporaryRedirect=307]="TemporaryRedirect",RedirectStatusCode[RedirectStatusCode.PermanentRedirect=308]="PermanentRedirect"}(RedirectStatusCode||(RedirectStatusCode={})),("function"==typeof exports.default||"object"==typeof exports.default&&null!==exports.default)&&void 0===exports.default.__esModule&&(Object.defineProperty(exports.default,"__esModule",{value:!0}),Object.assign(exports.default,exports),module.exports=exports.default)},"./node_modules/next/dist/client/components/redirect.js":(module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),function _export(target,all){for(var name in all)Object.defineProperty(target,name,{enumerable:!0,get:all[name]})}(exports,{RedirectType:function(){return RedirectType},getRedirectError:function(){return getRedirectError},getRedirectStatusCodeFromError:function(){return getRedirectStatusCodeFromError},getRedirectTypeFromError:function(){return getRedirectTypeFromError},getURLFromRedirectError:function(){return getURLFromRedirectError},isRedirectError:function(){return isRedirectError},permanentRedirect:function(){return permanentRedirect},redirect:function(){return redirect}});const _requestasyncstorageexternal=__webpack_require__("./node_modules/next/dist/client/components/request-async-storage.external.js"),_actionasyncstorageexternal=__webpack_require__("./node_modules/next/dist/client/components/action-async-storage.external.js"),_redirectstatuscode=__webpack_require__("./node_modules/next/dist/client/components/redirect-status-code.js"),REDIRECT_ERROR_CODE="NEXT_REDIRECT";var RedirectType;function getRedirectError(url,type,statusCode){void 0===statusCode&&(statusCode=_redirectstatuscode.RedirectStatusCode.TemporaryRedirect);const error=new Error(REDIRECT_ERROR_CODE);error.digest=REDIRECT_ERROR_CODE+";"+type+";"+url+";"+statusCode+";";const requestStore=_requestasyncstorageexternal.requestAsyncStorage.getStore();return requestStore&&(error.mutableCookies=requestStore.mutableCookies),error}function redirect(url,type){void 0===type&&(type="replace");const actionStore=_actionasyncstorageexternal.actionAsyncStorage.getStore();throw getRedirectError(url,type,(null==actionStore?void 0:actionStore.isAction)?_redirectstatuscode.RedirectStatusCode.SeeOther:_redirectstatuscode.RedirectStatusCode.TemporaryRedirect)}function permanentRedirect(url,type){void 0===type&&(type="replace");const actionStore=_actionasyncstorageexternal.actionAsyncStorage.getStore();throw getRedirectError(url,type,(null==actionStore?void 0:actionStore.isAction)?_redirectstatuscode.RedirectStatusCode.SeeOther:_redirectstatuscode.RedirectStatusCode.PermanentRedirect)}function isRedirectError(error){if("object"!=typeof error||null===error||!("digest"in error)||"string"!=typeof error.digest)return!1;const[errorCode,type,destination,status]=error.digest.split(";",4),statusCode=Number(status);return errorCode===REDIRECT_ERROR_CODE&&("replace"===type||"push"===type)&&"string"==typeof destination&&!isNaN(statusCode)&&statusCode in _redirectstatuscode.RedirectStatusCode}function getURLFromRedirectError(error){return isRedirectError(error)?error.digest.split(";",3)[2]:null}function getRedirectTypeFromError(error){if(!isRedirectError(error))throw new Error("Not a redirect error");return error.digest.split(";",2)[1]}function getRedirectStatusCodeFromError(error){if(!isRedirectError(error))throw new Error("Not a redirect error");return Number(error.digest.split(";",4)[3])}!function(RedirectType){RedirectType.push="push",RedirectType.replace="replace"}(RedirectType||(RedirectType={})),("function"==typeof exports.default||"object"==typeof exports.default&&null!==exports.default)&&void 0===exports.default.__esModule&&(Object.defineProperty(exports.default,"__esModule",{value:!0}),Object.assign(exports.default,exports),module.exports=exports.default)},"./node_modules/next/dist/client/components/request-async-storage.external.js":(module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),function _export(target,all){for(var name in all)Object.defineProperty(target,name,{enumerable:!0,get:all[name]})}(exports,{getExpectedRequestStore:function(){return getExpectedRequestStore},requestAsyncStorage:function(){return requestAsyncStorage}});const requestAsyncStorage=(0,__webpack_require__("./node_modules/next/dist/client/components/async-local-storage.js").createAsyncLocalStorage)();function getExpectedRequestStore(callingExpression){const store=requestAsyncStorage.getStore();if(store)return store;throw new Error("`"+callingExpression+"` was called outside a request scope. Read more: https://nextjs.org/docs/messages/next-dynamic-api-wrong-context")}("function"==typeof exports.default||"object"==typeof exports.default&&null!==exports.default)&&void 0===exports.default.__esModule&&(Object.defineProperty(exports.default,"__esModule",{value:!0}),Object.assign(exports.default,exports),module.exports=exports.default)},"./node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js":(module,exports)=>{"use strict";function getSegmentValue(segment){return Array.isArray(segment)?segment[1]:segment}Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"getSegmentValue",{enumerable:!0,get:function(){return getSegmentValue}}),("function"==typeof exports.default||"object"==typeof exports.default&&null!==exports.default)&&void 0===exports.default.__esModule&&(Object.defineProperty(exports.default,"__esModule",{value:!0}),Object.assign(exports.default,exports),module.exports=exports.default)},"./node_modules/next/dist/client/components/static-generation-async-storage.external.js":(module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"staticGenerationAsyncStorage",{enumerable:!0,get:function(){return staticGenerationAsyncStorage}});const staticGenerationAsyncStorage=(0,__webpack_require__("./node_modules/next/dist/client/components/async-local-storage.js").createAsyncLocalStorage)();("function"==typeof exports.default||"object"==typeof exports.default&&null!==exports.default)&&void 0===exports.default.__esModule&&(Object.defineProperty(exports.default,"__esModule",{value:!0}),Object.assign(exports.default,exports),module.exports=exports.default)},"./node_modules/next/dist/compiled/react/cjs/react-jsx-runtime.production.min.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";var f=__webpack_require__("./node_modules/next/dist/compiled/react/index.js"),k=Symbol.for("react.element"),l=Symbol.for("react.fragment"),m=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;function p(c,a,g){var b,d={},e=null,h=null;for(b in void 0!==g&&(e=""+g),void 0!==a.key&&(e=""+a.key),void 0!==a.ref&&(h=a.ref),a)m.call(a,b)&&"key"!==b&&"ref"!==b&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:k,type:c,key:e,ref:h,props:d,_owner:n.current}}exports.jsx=p,exports.jsxs=p},"./node_modules/next/dist/compiled/react/jsx-runtime.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";module.exports=__webpack_require__("./node_modules/next/dist/compiled/react/cjs/react-jsx-runtime.production.min.js")},"./node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js":(__unused_webpack_module,exports)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),function _export(target,all){for(var name in all)Object.defineProperty(target,name,{enumerable:!0,get:all[name]})}(exports,{BailoutToCSRError:function(){return BailoutToCSRError},isBailoutToCSRError:function(){return isBailoutToCSRError}});const BAILOUT_TO_CSR="BAILOUT_TO_CLIENT_SIDE_RENDERING";class BailoutToCSRError extends Error{constructor(reason){super("Bail out to client-side rendering: "+reason),this.reason=reason,this.digest=BAILOUT_TO_CSR}}function isBailoutToCSRError(err){return"object"==typeof err&&null!==err&&"digest"in err&&err.digest===BAILOUT_TO_CSR}},"./node_modules/next/dist/shared/lib/segment.js":(__unused_webpack_module,exports)=>{"use strict";function isGroupSegment(segment){return"("===segment[0]&&segment.endsWith(")")}Object.defineProperty(exports,"__esModule",{value:!0}),function _export(target,all){for(var name in all)Object.defineProperty(target,name,{enumerable:!0,get:all[name]})}(exports,{DEFAULT_SEGMENT_KEY:function(){return DEFAULT_SEGMENT_KEY},PAGE_SEGMENT_KEY:function(){return PAGE_SEGMENT_KEY},isGroupSegment:function(){return isGroupSegment}});const PAGE_SEGMENT_KEY="__PAGE__",DEFAULT_SEGMENT_KEY="__DEFAULT__"},"./node_modules/next/dist/shared/lib/server-inserted-html.shared-runtime.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),function _export(target,all){for(var name in all)Object.defineProperty(target,name,{enumerable:!0,get:all[name]})}(exports,{ServerInsertedHTMLContext:function(){return ServerInsertedHTMLContext},useServerInsertedHTML:function(){return useServerInsertedHTML}});const _react=__webpack_require__("./node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs")._(__webpack_require__("./node_modules/next/dist/compiled/react/index.js")),ServerInsertedHTMLContext=_react.default.createContext(null);function useServerInsertedHTML(callback){const addInsertedServerHTMLCallback=(0,_react.useContext)(ServerInsertedHTMLContext);addInsertedServerHTMLCallback&&addInsertedServerHTMLCallback(callback)}},"./node_modules/next/navigation.js":(module,__unused_webpack_exports,__webpack_require__)=>{module.exports=__webpack_require__("./node_modules/next/dist/client/components/navigation.js")},"./node_modules/react-hook-form/dist/index.esm.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{mN:()=>useForm});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/next/dist/compiled/react/index.js"),isCheckBoxInput=element=>"checkbox"===element.type,isDateObject=value=>value instanceof Date,isNullOrUndefined=value=>null==value;const isObjectType=value=>"object"==typeof value;var isObject=value=>!isNullOrUndefined(value)&&!Array.isArray(value)&&isObjectType(value)&&!isDateObject(value),getEventValue=event=>isObject(event)&&event.target?isCheckBoxInput(event.target)?event.target.checked:event.target.value:event,isNameInFieldArray=(names,name)=>names.has((name=>name.substring(0,name.search(/\.\d+(\.|$)/))||name)(name)),isPlainObject=tempObject=>{const prototypeCopy=tempObject.constructor&&tempObject.constructor.prototype;return isObject(prototypeCopy)&&prototypeCopy.hasOwnProperty("isPrototypeOf")},isWeb="undefined"!=typeof window&&void 0!==window.HTMLElement&&"undefined"!=typeof document;function cloneObject(data){let copy;const isArray=Array.isArray(data);if(data instanceof Date)copy=new Date(data);else if(data instanceof Set)copy=new Set(data);else{if(isWeb&&(data instanceof Blob||data instanceof FileList)||!isArray&&!isObject(data))return data;if(copy=isArray?[]:{},isArray||isPlainObject(data))for(const key in data)data.hasOwnProperty(key)&&(copy[key]=cloneObject(data[key]));else copy=data}return copy}var compact=value=>Array.isArray(value)?value.filter(Boolean):[],isUndefined=val=>void 0===val,get=(object,path,defaultValue)=>{if(!path||!isObject(object))return defaultValue;const result=compact(path.split(/[,[\].]+?/)).reduce(((result,key)=>isNullOrUndefined(result)?result:result[key]),object);return isUndefined(result)||result===object?isUndefined(object[path])?defaultValue:object[path]:result},isBoolean=value=>"boolean"==typeof value;const EVENTS={BLUR:"blur",FOCUS_OUT:"focusout",CHANGE:"change"},VALIDATION_MODE={onBlur:"onBlur",onChange:"onChange",onSubmit:"onSubmit",onTouched:"onTouched",all:"all"},INPUT_VALIDATION_RULES_max="max",INPUT_VALIDATION_RULES_min="min",INPUT_VALIDATION_RULES_maxLength="maxLength",INPUT_VALIDATION_RULES_minLength="minLength",INPUT_VALIDATION_RULES_pattern="pattern",INPUT_VALIDATION_RULES_required="required",INPUT_VALIDATION_RULES_validate="validate";react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);var getProxyFormState=(formState,control,localProxyFormState,isRoot=!0)=>{const result={defaultValues:control._defaultValues};for(const key in formState)Object.defineProperty(result,key,{get:()=>{const _key=key;return control._proxyFormState[_key]!==VALIDATION_MODE.all&&(control._proxyFormState[_key]=!isRoot||VALIDATION_MODE.all),localProxyFormState&&(localProxyFormState[_key]=!0),formState[_key]}});return result},isEmptyObject=value=>isObject(value)&&!Object.keys(value).length,shouldRenderFormState=(formStateData,_proxyFormState,updateFormState,isRoot)=>{updateFormState(formStateData);const{name,...formState}=formStateData;return isEmptyObject(formState)||Object.keys(formState).length>=Object.keys(_proxyFormState).length||Object.keys(formState).find((key=>_proxyFormState[key]===(!isRoot||VALIDATION_MODE.all)))},convertToArrayPayload=value=>Array.isArray(value)?value:[value];function useSubscribe(props){const _props=react__WEBPACK_IMPORTED_MODULE_0__.useRef(props);_props.current=props,react__WEBPACK_IMPORTED_MODULE_0__.useEffect((()=>{const subscription=!props.disabled&&_props.current.subject&&_props.current.subject.subscribe({next:_props.current.next});return()=>{subscription&&subscription.unsubscribe()}}),[props.disabled])}var isString=value=>"string"==typeof value,generateWatchOutput=(names,_names,formValues,isGlobal,defaultValue)=>isString(names)?(isGlobal&&_names.watch.add(names),get(formValues,names,defaultValue)):Array.isArray(names)?names.map((fieldName=>(isGlobal&&_names.watch.add(fieldName),get(formValues,fieldName)))):(isGlobal&&(_names.watchAll=!0),formValues);var isKey=value=>/^\w*$/.test(value),stringToPath=input=>compact(input.replace(/["|']|\]/g,"").split(/\.|\[/)),set=(object,path,value)=>{let index=-1;const tempPath=isKey(path)?[path]:stringToPath(path),length=tempPath.length,lastIndex=length-1;for(;++index<length;){const key=tempPath[index];let newValue=value;if(index!==lastIndex){const objValue=object[key];newValue=isObject(objValue)||Array.isArray(objValue)?objValue:isNaN(+tempPath[index+1])?{}:[]}object[key]=newValue,object=object[key]}return object};var appendErrors=(name,validateAllFieldCriteria,errors,type,message)=>validateAllFieldCriteria?{...errors[name],types:{...errors[name]&&errors[name].types?errors[name].types:{},[type]:message||!0}}:{},getValidationModes=mode=>({isOnSubmit:!mode||mode===VALIDATION_MODE.onSubmit,isOnBlur:mode===VALIDATION_MODE.onBlur,isOnChange:mode===VALIDATION_MODE.onChange,isOnAll:mode===VALIDATION_MODE.all,isOnTouch:mode===VALIDATION_MODE.onTouched}),isWatched=(name,_names,isBlurEvent)=>!isBlurEvent&&(_names.watchAll||_names.watch.has(name)||[..._names.watch].some((watchName=>name.startsWith(watchName)&&/^\.\w+/.test(name.slice(watchName.length)))));const iterateFieldsByAction=(fields,action,fieldsNames,abortEarly)=>{for(const key of fieldsNames||Object.keys(fields)){const field=get(fields,key);if(field){const{_f,...currentField}=field;if(_f){if(_f.refs&&_f.refs[0]&&action(_f.refs[0],key)&&!abortEarly)break;if(_f.ref&&action(_f.ref,_f.name)&&!abortEarly)break;iterateFieldsByAction(currentField,action)}else isObject(currentField)&&iterateFieldsByAction(currentField,action)}}};var updateFieldArrayRootError=(errors,error,name)=>{const fieldArrayErrors=compact(get(errors,name));return set(fieldArrayErrors,"root",error[name]),set(errors,name,fieldArrayErrors),errors},isFileInput=element=>"file"===element.type,isFunction=value=>"function"==typeof value,isHTMLElement=value=>{if(!isWeb)return!1;const owner=value?value.ownerDocument:0;return value instanceof(owner&&owner.defaultView?owner.defaultView.HTMLElement:HTMLElement)},isMessage=value=>isString(value),isRadioInput=element=>"radio"===element.type,isRegex=value=>value instanceof RegExp;const defaultResult={value:!1,isValid:!1},validResult={value:!0,isValid:!0};var getCheckboxValue=options=>{if(Array.isArray(options)){if(options.length>1){const values=options.filter((option=>option&&option.checked&&!option.disabled)).map((option=>option.value));return{value:values,isValid:!!values.length}}return options[0].checked&&!options[0].disabled?options[0].attributes&&!isUndefined(options[0].attributes.value)?isUndefined(options[0].value)||""===options[0].value?validResult:{value:options[0].value,isValid:!0}:validResult:defaultResult}return defaultResult};const defaultReturn={isValid:!1,value:null};var getRadioValue=options=>Array.isArray(options)?options.reduce(((previous,option)=>option&&option.checked&&!option.disabled?{isValid:!0,value:option.value}:previous),defaultReturn):defaultReturn;function getValidateError(result,ref,type="validate"){if(isMessage(result)||Array.isArray(result)&&result.every(isMessage)||isBoolean(result)&&!result)return{type,message:isMessage(result)?result:"",ref}}var getValueAndMessage=validationData=>isObject(validationData)&&!isRegex(validationData)?validationData:{value:validationData,message:""},validateField=async(field,formValues,validateAllFieldCriteria,shouldUseNativeValidation,isFieldArray)=>{const{ref,refs,required,maxLength,minLength,min,max,pattern,validate,name,valueAsNumber,mount,disabled}=field._f,inputValue=get(formValues,name);if(!mount||disabled)return{};const inputRef=refs?refs[0]:ref,setCustomValidity=message=>{shouldUseNativeValidation&&inputRef.reportValidity&&(inputRef.setCustomValidity(isBoolean(message)?"":message||""),inputRef.reportValidity())},error={},isRadio=isRadioInput(ref),isCheckBox=isCheckBoxInput(ref),isRadioOrCheckbox=isRadio||isCheckBox,isEmpty=(valueAsNumber||isFileInput(ref))&&isUndefined(ref.value)&&isUndefined(inputValue)||isHTMLElement(ref)&&""===ref.value||""===inputValue||Array.isArray(inputValue)&&!inputValue.length,appendErrorsCurry=appendErrors.bind(null,name,validateAllFieldCriteria,error),getMinMaxMessage=(exceedMax,maxLengthMessage,minLengthMessage,maxType=INPUT_VALIDATION_RULES_maxLength,minType=INPUT_VALIDATION_RULES_minLength)=>{const message=exceedMax?maxLengthMessage:minLengthMessage;error[name]={type:exceedMax?maxType:minType,message,ref,...appendErrorsCurry(exceedMax?maxType:minType,message)}};if(isFieldArray?!Array.isArray(inputValue)||!inputValue.length:required&&(!isRadioOrCheckbox&&(isEmpty||isNullOrUndefined(inputValue))||isBoolean(inputValue)&&!inputValue||isCheckBox&&!getCheckboxValue(refs).isValid||isRadio&&!getRadioValue(refs).isValid)){const{value,message}=isMessage(required)?{value:!!required,message:required}:getValueAndMessage(required);if(value&&(error[name]={type:INPUT_VALIDATION_RULES_required,message,ref:inputRef,...appendErrorsCurry(INPUT_VALIDATION_RULES_required,message)},!validateAllFieldCriteria))return setCustomValidity(message),error}if(!(isEmpty||isNullOrUndefined(min)&&isNullOrUndefined(max))){let exceedMax,exceedMin;const maxOutput=getValueAndMessage(max),minOutput=getValueAndMessage(min);if(isNullOrUndefined(inputValue)||isNaN(inputValue)){const valueDate=ref.valueAsDate||new Date(inputValue),convertTimeToDate=time=>new Date((new Date).toDateString()+" "+time),isTime="time"==ref.type,isWeek="week"==ref.type;isString(maxOutput.value)&&inputValue&&(exceedMax=isTime?convertTimeToDate(inputValue)>convertTimeToDate(maxOutput.value):isWeek?inputValue>maxOutput.value:valueDate>new Date(maxOutput.value)),isString(minOutput.value)&&inputValue&&(exceedMin=isTime?convertTimeToDate(inputValue)<convertTimeToDate(minOutput.value):isWeek?inputValue<minOutput.value:valueDate<new Date(minOutput.value))}else{const valueNumber=ref.valueAsNumber||(inputValue?+inputValue:inputValue);isNullOrUndefined(maxOutput.value)||(exceedMax=valueNumber>maxOutput.value),isNullOrUndefined(minOutput.value)||(exceedMin=valueNumber<minOutput.value)}if((exceedMax||exceedMin)&&(getMinMaxMessage(!!exceedMax,maxOutput.message,minOutput.message,INPUT_VALIDATION_RULES_max,INPUT_VALIDATION_RULES_min),!validateAllFieldCriteria))return setCustomValidity(error[name].message),error}if((maxLength||minLength)&&!isEmpty&&(isString(inputValue)||isFieldArray&&Array.isArray(inputValue))){const maxLengthOutput=getValueAndMessage(maxLength),minLengthOutput=getValueAndMessage(minLength),exceedMax=!isNullOrUndefined(maxLengthOutput.value)&&inputValue.length>+maxLengthOutput.value,exceedMin=!isNullOrUndefined(minLengthOutput.value)&&inputValue.length<+minLengthOutput.value;if((exceedMax||exceedMin)&&(getMinMaxMessage(exceedMax,maxLengthOutput.message,minLengthOutput.message),!validateAllFieldCriteria))return setCustomValidity(error[name].message),error}if(pattern&&!isEmpty&&isString(inputValue)){const{value:patternValue,message}=getValueAndMessage(pattern);if(isRegex(patternValue)&&!inputValue.match(patternValue)&&(error[name]={type:INPUT_VALIDATION_RULES_pattern,message,ref,...appendErrorsCurry(INPUT_VALIDATION_RULES_pattern,message)},!validateAllFieldCriteria))return setCustomValidity(message),error}if(validate)if(isFunction(validate)){const validateError=getValidateError(await validate(inputValue,formValues),inputRef);if(validateError&&(error[name]={...validateError,...appendErrorsCurry(INPUT_VALIDATION_RULES_validate,validateError.message)},!validateAllFieldCriteria))return setCustomValidity(validateError.message),error}else if(isObject(validate)){let validationResult={};for(const key in validate){if(!isEmptyObject(validationResult)&&!validateAllFieldCriteria)break;const validateError=getValidateError(await validate[key](inputValue,formValues),inputRef,key);validateError&&(validationResult={...validateError,...appendErrorsCurry(key,validateError.message)},setCustomValidity(validateError.message),validateAllFieldCriteria&&(error[name]=validationResult))}if(!isEmptyObject(validationResult)&&(error[name]={ref:inputRef,...validationResult},!validateAllFieldCriteria))return error}return setCustomValidity(!0),error};function unset(object,path){const paths=Array.isArray(path)?path:isKey(path)?[path]:stringToPath(path),childObject=1===paths.length?object:function baseGet(object,updatePath){const length=updatePath.slice(0,-1).length;let index=0;for(;index<length;)object=isUndefined(object)?index++:object[updatePath[index++]];return object}(object,paths),index=paths.length-1,key=paths[index];return childObject&&delete childObject[key],0!==index&&(isObject(childObject)&&isEmptyObject(childObject)||Array.isArray(childObject)&&function isEmptyArray(obj){for(const key in obj)if(obj.hasOwnProperty(key)&&!isUndefined(obj[key]))return!1;return!0}(childObject))&&unset(object,paths.slice(0,-1)),object}var createSubject=()=>{let _observers=[];return{get observers(){return _observers},next:value=>{for(const observer of _observers)observer.next&&observer.next(value)},subscribe:observer=>(_observers.push(observer),{unsubscribe:()=>{_observers=_observers.filter((o=>o!==observer))}}),unsubscribe:()=>{_observers=[]}}},isPrimitive=value=>isNullOrUndefined(value)||!isObjectType(value);function deepEqual(object1,object2){if(isPrimitive(object1)||isPrimitive(object2))return object1===object2;if(isDateObject(object1)&&isDateObject(object2))return object1.getTime()===object2.getTime();const keys1=Object.keys(object1),keys2=Object.keys(object2);if(keys1.length!==keys2.length)return!1;for(const key of keys1){const val1=object1[key];if(!keys2.includes(key))return!1;if("ref"!==key){const val2=object2[key];if(isDateObject(val1)&&isDateObject(val2)||isObject(val1)&&isObject(val2)||Array.isArray(val1)&&Array.isArray(val2)?!deepEqual(val1,val2):val1!==val2)return!1}}return!0}var isMultipleSelect=element=>"select-multiple"===element.type,isRadioOrCheckbox=ref=>isRadioInput(ref)||isCheckBoxInput(ref),live=ref=>isHTMLElement(ref)&&ref.isConnected,objectHasFunction=data=>{for(const key in data)if(isFunction(data[key]))return!0;return!1};function markFieldsDirty(data,fields={}){const isParentNodeArray=Array.isArray(data);if(isObject(data)||isParentNodeArray)for(const key in data)Array.isArray(data[key])||isObject(data[key])&&!objectHasFunction(data[key])?(fields[key]=Array.isArray(data[key])?[]:{},markFieldsDirty(data[key],fields[key])):isNullOrUndefined(data[key])||(fields[key]=!0);return fields}function getDirtyFieldsFromDefaultValues(data,formValues,dirtyFieldsFromValues){const isParentNodeArray=Array.isArray(data);if(isObject(data)||isParentNodeArray)for(const key in data)Array.isArray(data[key])||isObject(data[key])&&!objectHasFunction(data[key])?isUndefined(formValues)||isPrimitive(dirtyFieldsFromValues[key])?dirtyFieldsFromValues[key]=Array.isArray(data[key])?markFieldsDirty(data[key],[]):{...markFieldsDirty(data[key])}:getDirtyFieldsFromDefaultValues(data[key],isNullOrUndefined(formValues)?{}:formValues[key],dirtyFieldsFromValues[key]):dirtyFieldsFromValues[key]=!deepEqual(data[key],formValues[key]);return dirtyFieldsFromValues}var getDirtyFields=(defaultValues,formValues)=>getDirtyFieldsFromDefaultValues(defaultValues,formValues,markFieldsDirty(formValues)),getFieldValueAs=(value,{valueAsNumber,valueAsDate,setValueAs})=>isUndefined(value)?value:valueAsNumber?""===value?NaN:value?+value:value:valueAsDate&&isString(value)?new Date(value):setValueAs?setValueAs(value):value;function getFieldValue(_f){const ref=_f.ref;if(!(_f.refs?_f.refs.every((ref=>ref.disabled)):ref.disabled))return isFileInput(ref)?ref.files:isRadioInput(ref)?getRadioValue(_f.refs).value:isMultipleSelect(ref)?[...ref.selectedOptions].map((({value})=>value)):isCheckBoxInput(ref)?getCheckboxValue(_f.refs).value:getFieldValueAs(isUndefined(ref.value)?_f.ref.value:ref.value,_f)}var getResolverOptions=(fieldsNames,_fields,criteriaMode,shouldUseNativeValidation)=>{const fields={};for(const name of fieldsNames){const field=get(_fields,name);field&&set(fields,name,field._f)}return{criteriaMode,names:[...fieldsNames],fields,shouldUseNativeValidation}},getRuleValue=rule=>isUndefined(rule)?rule:isRegex(rule)?rule.source:isObject(rule)?isRegex(rule.value)?rule.value.source:rule.value:rule,hasValidation=options=>options.mount&&(options.required||options.min||options.max||options.maxLength||options.minLength||options.pattern||options.validate);function schemaErrorLookup(errors,_fields,name){const error=get(errors,name);if(error||isKey(name))return{error,name};const names=name.split(".");for(;names.length;){const fieldName=names.join("."),field=get(_fields,fieldName),foundError=get(errors,fieldName);if(field&&!Array.isArray(field)&&name!==fieldName)return{name};if(foundError&&foundError.type)return{name:fieldName,error:foundError};names.pop()}return{name}}var skipValidation=(isBlurEvent,isTouched,isSubmitted,reValidateMode,mode)=>!mode.isOnAll&&(!isSubmitted&&mode.isOnTouch?!(isTouched||isBlurEvent):(isSubmitted?reValidateMode.isOnBlur:mode.isOnBlur)?!isBlurEvent:!(isSubmitted?reValidateMode.isOnChange:mode.isOnChange)||isBlurEvent),unsetEmptyArray=(ref,name)=>!compact(get(ref,name)).length&&unset(ref,name);const defaultOptions={mode:VALIDATION_MODE.onSubmit,reValidateMode:VALIDATION_MODE.onChange,shouldFocusError:!0};function createFormControl(props={}){let delayErrorCallback,_options={...defaultOptions,...props},_formState={submitCount:0,isDirty:!1,isLoading:isFunction(_options.defaultValues),isValidating:!1,isSubmitted:!1,isSubmitting:!1,isSubmitSuccessful:!1,isValid:!1,touchedFields:{},dirtyFields:{},validatingFields:{},errors:_options.errors||{},disabled:_options.disabled||!1},_fields={},_defaultValues=(isObject(_options.defaultValues)||isObject(_options.values))&&cloneObject(_options.defaultValues||_options.values)||{},_formValues=_options.shouldUnregister?{}:cloneObject(_defaultValues),_state={action:!1,mount:!1,watch:!1},_names={mount:new Set,unMount:new Set,array:new Set,watch:new Set},timer=0;const _proxyFormState={isDirty:!1,dirtyFields:!1,validatingFields:!1,touchedFields:!1,isValidating:!1,isValid:!1,errors:!1},_subjects={values:createSubject(),array:createSubject(),state:createSubject()},validationModeBeforeSubmit=getValidationModes(_options.mode),validationModeAfterSubmit=getValidationModes(_options.reValidateMode),shouldDisplayAllAssociatedErrors=_options.criteriaMode===VALIDATION_MODE.all,_updateValid=async shouldUpdateValid=>{if(_proxyFormState.isValid||shouldUpdateValid){const isValid=_options.resolver?isEmptyObject((await _executeSchema()).errors):await executeBuiltInValidation(_fields,!0);isValid!==_formState.isValid&&_subjects.state.next({isValid})}},_updateIsValidating=(names,isValidating)=>{(_proxyFormState.isValidating||_proxyFormState.validatingFields)&&((names||Array.from(_names.mount)).forEach((name=>{name&&(isValidating?set(_formState.validatingFields,name,isValidating):unset(_formState.validatingFields,name))})),_subjects.state.next({validatingFields:_formState.validatingFields,isValidating:!isEmptyObject(_formState.validatingFields)}))},updateValidAndValue=(name,shouldSkipSetValueAs,value,ref)=>{const field=get(_fields,name);if(field){const defaultValue=get(_formValues,name,isUndefined(value)?get(_defaultValues,name):value);isUndefined(defaultValue)||ref&&ref.defaultChecked||shouldSkipSetValueAs?set(_formValues,name,shouldSkipSetValueAs?defaultValue:getFieldValue(field._f)):setFieldValue(name,defaultValue),_state.mount&&_updateValid()}},updateTouchAndDirty=(name,fieldValue,isBlurEvent,shouldDirty,shouldRender)=>{let shouldUpdateField=!1,isPreviousDirty=!1;const output={name},disabledField=!(!get(_fields,name)||!get(_fields,name)._f.disabled);if(!isBlurEvent||shouldDirty){_proxyFormState.isDirty&&(isPreviousDirty=_formState.isDirty,_formState.isDirty=output.isDirty=_getDirty(),shouldUpdateField=isPreviousDirty!==output.isDirty);const isCurrentFieldPristine=disabledField||deepEqual(get(_defaultValues,name),fieldValue);isPreviousDirty=!(disabledField||!get(_formState.dirtyFields,name)),isCurrentFieldPristine||disabledField?unset(_formState.dirtyFields,name):set(_formState.dirtyFields,name,!0),output.dirtyFields=_formState.dirtyFields,shouldUpdateField=shouldUpdateField||_proxyFormState.dirtyFields&&isPreviousDirty!==!isCurrentFieldPristine}if(isBlurEvent){const isPreviousFieldTouched=get(_formState.touchedFields,name);isPreviousFieldTouched||(set(_formState.touchedFields,name,isBlurEvent),output.touchedFields=_formState.touchedFields,shouldUpdateField=shouldUpdateField||_proxyFormState.touchedFields&&isPreviousFieldTouched!==isBlurEvent)}return shouldUpdateField&&shouldRender&&_subjects.state.next(output),shouldUpdateField?output:{}},shouldRenderByError=(name,isValid,error,fieldState)=>{const previousFieldError=get(_formState.errors,name),shouldUpdateValid=_proxyFormState.isValid&&isBoolean(isValid)&&_formState.isValid!==isValid;var callback;if(props.delayError&&error?(callback=()=>((name,error)=>{set(_formState.errors,name,error),_subjects.state.next({errors:_formState.errors})})(name,error),delayErrorCallback=wait=>{clearTimeout(timer),timer=setTimeout(callback,wait)},delayErrorCallback(props.delayError)):(clearTimeout(timer),delayErrorCallback=null,error?set(_formState.errors,name,error):unset(_formState.errors,name)),(error?!deepEqual(previousFieldError,error):previousFieldError)||!isEmptyObject(fieldState)||shouldUpdateValid){const updatedFormState={...fieldState,...shouldUpdateValid&&isBoolean(isValid)?{isValid}:{},errors:_formState.errors,name};_formState={..._formState,...updatedFormState},_subjects.state.next(updatedFormState)}},_executeSchema=async name=>{_updateIsValidating(name,!0);const result=await _options.resolver(_formValues,_options.context,getResolverOptions(name||_names.mount,_fields,_options.criteriaMode,_options.shouldUseNativeValidation));return _updateIsValidating(name),result},executeBuiltInValidation=async(fields,shouldOnlyCheckValid,context={valid:!0})=>{for(const name in fields){const field=fields[name];if(field){const{_f,...fieldValue}=field;if(_f){const isFieldArrayRoot=_names.array.has(_f.name);_updateIsValidating([name],!0);const fieldError=await validateField(field,_formValues,shouldDisplayAllAssociatedErrors,_options.shouldUseNativeValidation&&!shouldOnlyCheckValid,isFieldArrayRoot);if(_updateIsValidating([name]),fieldError[_f.name]&&(context.valid=!1,shouldOnlyCheckValid))break;!shouldOnlyCheckValid&&(get(fieldError,_f.name)?isFieldArrayRoot?updateFieldArrayRootError(_formState.errors,fieldError,_f.name):set(_formState.errors,_f.name,fieldError[_f.name]):unset(_formState.errors,_f.name))}fieldValue&&await executeBuiltInValidation(fieldValue,shouldOnlyCheckValid,context)}}return context.valid},_getDirty=(name,data)=>(name&&data&&set(_formValues,name,data),!deepEqual(getValues(),_defaultValues)),_getWatch=(names,defaultValue,isGlobal)=>generateWatchOutput(names,_names,{..._state.mount?_formValues:isUndefined(defaultValue)?_defaultValues:isString(names)?{[names]:defaultValue}:defaultValue},isGlobal,defaultValue),setFieldValue=(name,value,options={})=>{const field=get(_fields,name);let fieldValue=value;if(field){const fieldReference=field._f;fieldReference&&(!fieldReference.disabled&&set(_formValues,name,getFieldValueAs(value,fieldReference)),fieldValue=isHTMLElement(fieldReference.ref)&&isNullOrUndefined(value)?"":value,isMultipleSelect(fieldReference.ref)?[...fieldReference.ref.options].forEach((optionRef=>optionRef.selected=fieldValue.includes(optionRef.value))):fieldReference.refs?isCheckBoxInput(fieldReference.ref)?fieldReference.refs.length>1?fieldReference.refs.forEach((checkboxRef=>(!checkboxRef.defaultChecked||!checkboxRef.disabled)&&(checkboxRef.checked=Array.isArray(fieldValue)?!!fieldValue.find((data=>data===checkboxRef.value)):fieldValue===checkboxRef.value))):fieldReference.refs[0]&&(fieldReference.refs[0].checked=!!fieldValue):fieldReference.refs.forEach((radioRef=>radioRef.checked=radioRef.value===fieldValue)):isFileInput(fieldReference.ref)?fieldReference.ref.value="":(fieldReference.ref.value=fieldValue,fieldReference.ref.type||_subjects.values.next({name,values:{..._formValues}})))}(options.shouldDirty||options.shouldTouch)&&updateTouchAndDirty(name,fieldValue,options.shouldTouch,options.shouldDirty,!0),options.shouldValidate&&trigger(name)},setValues=(name,value,options)=>{for(const fieldKey in value){const fieldValue=value[fieldKey],fieldName=`${name}.${fieldKey}`,field=get(_fields,fieldName);!_names.array.has(name)&&isPrimitive(fieldValue)&&(!field||field._f)||isDateObject(fieldValue)?setFieldValue(fieldName,fieldValue,options):setValues(fieldName,fieldValue,options)}},setValue=(name,value,options={})=>{const field=get(_fields,name),isFieldArray=_names.array.has(name),cloneValue=cloneObject(value);set(_formValues,name,cloneValue),isFieldArray?(_subjects.array.next({name,values:{..._formValues}}),(_proxyFormState.isDirty||_proxyFormState.dirtyFields)&&options.shouldDirty&&_subjects.state.next({name,dirtyFields:getDirtyFields(_defaultValues,_formValues),isDirty:_getDirty(name,cloneValue)})):!field||field._f||isNullOrUndefined(cloneValue)?setFieldValue(name,cloneValue,options):setValues(name,cloneValue,options),isWatched(name,_names)&&_subjects.state.next({..._formState}),_subjects.values.next({name:_state.mount?name:void 0,values:{..._formValues}})},onChange=async event=>{_state.mount=!0;const target=event.target;let name=target.name,isFieldValueUpdated=!0;const field=get(_fields,name),_updateIsFieldValueUpdated=fieldValue=>{isFieldValueUpdated=Number.isNaN(fieldValue)||fieldValue===get(_formValues,name,fieldValue)};if(field){let error,isValid;const fieldValue=target.type?getFieldValue(field._f):getEventValue(event),isBlurEvent=event.type===EVENTS.BLUR||event.type===EVENTS.FOCUS_OUT,shouldSkipValidation=!hasValidation(field._f)&&!_options.resolver&&!get(_formState.errors,name)&&!field._f.deps||skipValidation(isBlurEvent,get(_formState.touchedFields,name),_formState.isSubmitted,validationModeAfterSubmit,validationModeBeforeSubmit),watched=isWatched(name,_names,isBlurEvent);set(_formValues,name,fieldValue),isBlurEvent?(field._f.onBlur&&field._f.onBlur(event),delayErrorCallback&&delayErrorCallback(0)):field._f.onChange&&field._f.onChange(event);const fieldState=updateTouchAndDirty(name,fieldValue,isBlurEvent,!1),shouldRender=!isEmptyObject(fieldState)||watched;if(!isBlurEvent&&_subjects.values.next({name,type:event.type,values:{..._formValues}}),shouldSkipValidation)return _proxyFormState.isValid&&_updateValid(),shouldRender&&_subjects.state.next({name,...watched?{}:fieldState});if(!isBlurEvent&&watched&&_subjects.state.next({..._formState}),_options.resolver){const{errors}=await _executeSchema([name]);if(_updateIsFieldValueUpdated(fieldValue),isFieldValueUpdated){const previousErrorLookupResult=schemaErrorLookup(_formState.errors,_fields,name),errorLookupResult=schemaErrorLookup(errors,_fields,previousErrorLookupResult.name||name);error=errorLookupResult.error,name=errorLookupResult.name,isValid=isEmptyObject(errors)}}else _updateIsValidating([name],!0),error=(await validateField(field,_formValues,shouldDisplayAllAssociatedErrors,_options.shouldUseNativeValidation))[name],_updateIsValidating([name]),_updateIsFieldValueUpdated(fieldValue),isFieldValueUpdated&&(error?isValid=!1:_proxyFormState.isValid&&(isValid=await executeBuiltInValidation(_fields,!0)));isFieldValueUpdated&&(field._f.deps&&trigger(field._f.deps),shouldRenderByError(name,isValid,error,fieldState))}},_focusInput=(ref,key)=>{if(get(_formState.errors,key)&&ref.focus)return ref.focus(),1},trigger=async(name,options={})=>{let isValid,validationResult;const fieldNames=convertToArrayPayload(name);if(_options.resolver){const errors=await(async names=>{const{errors}=await _executeSchema(names);if(names)for(const name of names){const error=get(errors,name);error?set(_formState.errors,name,error):unset(_formState.errors,name)}else _formState.errors=errors;return errors})(isUndefined(name)?name:fieldNames);isValid=isEmptyObject(errors),validationResult=name?!fieldNames.some((name=>get(errors,name))):isValid}else name?(validationResult=(await Promise.all(fieldNames.map((async fieldName=>{const field=get(_fields,fieldName);return await executeBuiltInValidation(field&&field._f?{[fieldName]:field}:field)})))).every(Boolean),(validationResult||_formState.isValid)&&_updateValid()):validationResult=isValid=await executeBuiltInValidation(_fields);return _subjects.state.next({...!isString(name)||_proxyFormState.isValid&&isValid!==_formState.isValid?{}:{name},..._options.resolver||!name?{isValid}:{},errors:_formState.errors}),options.shouldFocus&&!validationResult&&iterateFieldsByAction(_fields,_focusInput,name?fieldNames:_names.mount),validationResult},getValues=fieldNames=>{const values={..._defaultValues,..._state.mount?_formValues:{}};return isUndefined(fieldNames)?values:isString(fieldNames)?get(values,fieldNames):fieldNames.map((name=>get(values,name)))},getFieldState=(name,formState)=>({invalid:!!get((formState||_formState).errors,name),isDirty:!!get((formState||_formState).dirtyFields,name),isTouched:!!get((formState||_formState).touchedFields,name),isValidating:!!get((formState||_formState).validatingFields,name),error:get((formState||_formState).errors,name)}),setError=(name,error,options)=>{const ref=(get(_fields,name,{_f:{}})._f||{}).ref;set(_formState.errors,name,{...error,ref}),_subjects.state.next({name,errors:_formState.errors,isValid:!1}),options&&options.shouldFocus&&ref&&ref.focus&&ref.focus()},unregister=(name,options={})=>{for(const fieldName of name?convertToArrayPayload(name):_names.mount)_names.mount.delete(fieldName),_names.array.delete(fieldName),options.keepValue||(unset(_fields,fieldName),unset(_formValues,fieldName)),!options.keepError&&unset(_formState.errors,fieldName),!options.keepDirty&&unset(_formState.dirtyFields,fieldName),!options.keepTouched&&unset(_formState.touchedFields,fieldName),!options.keepIsValidating&&unset(_formState.validatingFields,fieldName),!_options.shouldUnregister&&!options.keepDefaultValue&&unset(_defaultValues,fieldName);_subjects.values.next({values:{..._formValues}}),_subjects.state.next({..._formState,...options.keepDirty?{isDirty:_getDirty()}:{}}),!options.keepIsValid&&_updateValid()},_updateDisabledField=({disabled,name,field,fields,value})=>{if(isBoolean(disabled)){const inputValue=disabled?void 0:isUndefined(value)?getFieldValue(field?field._f:get(fields,name)._f):value;set(_formValues,name,inputValue),updateTouchAndDirty(name,inputValue,!1,!1,!0)}},register=(name,options={})=>{let field=get(_fields,name);const disabledIsDefined=isBoolean(options.disabled);return set(_fields,name,{...field||{},_f:{...field&&field._f?field._f:{ref:{name}},name,mount:!0,...options}}),_names.mount.add(name),field?_updateDisabledField({field,disabled:options.disabled,name,value:options.value}):updateValidAndValue(name,!0,options.value),{...disabledIsDefined?{disabled:options.disabled}:{},..._options.progressive?{required:!!options.required,min:getRuleValue(options.min),max:getRuleValue(options.max),minLength:getRuleValue(options.minLength),maxLength:getRuleValue(options.maxLength),pattern:getRuleValue(options.pattern)}:{},name,onChange,onBlur:onChange,ref:ref=>{if(ref){register(name,options),field=get(_fields,name);const fieldRef=isUndefined(ref.value)&&ref.querySelectorAll&&ref.querySelectorAll("input,select,textarea")[0]||ref,radioOrCheckbox=isRadioOrCheckbox(fieldRef),refs=field._f.refs||[];if(radioOrCheckbox?refs.find((option=>option===fieldRef)):fieldRef===field._f.ref)return;set(_fields,name,{_f:{...field._f,...radioOrCheckbox?{refs:[...refs.filter(live),fieldRef,...Array.isArray(get(_defaultValues,name))?[{}]:[]],ref:{type:fieldRef.type,name}}:{ref:fieldRef}}}),updateValidAndValue(name,!1,void 0,fieldRef)}else field=get(_fields,name,{}),field._f&&(field._f.mount=!1),(_options.shouldUnregister||options.shouldUnregister)&&(!isNameInFieldArray(_names.array,name)||!_state.action)&&_names.unMount.add(name)}}},_focusError=()=>_options.shouldFocusError&&iterateFieldsByAction(_fields,_focusInput,_names.mount),handleSubmit=(onValid,onInvalid)=>async e=>{let onValidError;e&&(e.preventDefault&&e.preventDefault(),e.persist&&e.persist());let fieldValues=cloneObject(_formValues);if(_subjects.state.next({isSubmitting:!0}),_options.resolver){const{errors,values}=await _executeSchema();_formState.errors=errors,fieldValues=values}else await executeBuiltInValidation(_fields);if(unset(_formState.errors,"root"),isEmptyObject(_formState.errors)){_subjects.state.next({errors:{}});try{await onValid(fieldValues,e)}catch(error){onValidError=error}}else onInvalid&&await onInvalid({..._formState.errors},e),_focusError(),setTimeout(_focusError);if(_subjects.state.next({isSubmitted:!0,isSubmitting:!1,isSubmitSuccessful:isEmptyObject(_formState.errors)&&!onValidError,submitCount:_formState.submitCount+1,errors:_formState.errors}),onValidError)throw onValidError},_reset=(formValues,keepStateOptions={})=>{const updatedValues=formValues?cloneObject(formValues):_defaultValues,cloneUpdatedValues=cloneObject(updatedValues),isEmptyResetValues=isEmptyObject(formValues),values=isEmptyResetValues?_defaultValues:cloneUpdatedValues;if(keepStateOptions.keepDefaultValues||(_defaultValues=updatedValues),!keepStateOptions.keepValues){if(keepStateOptions.keepDirtyValues)for(const fieldName of _names.mount)get(_formState.dirtyFields,fieldName)?set(values,fieldName,get(_formValues,fieldName)):setValue(fieldName,get(values,fieldName));else{if(isWeb&&isUndefined(formValues))for(const name of _names.mount){const field=get(_fields,name);if(field&&field._f){const fieldReference=Array.isArray(field._f.refs)?field._f.refs[0]:field._f.ref;if(isHTMLElement(fieldReference)){const form=fieldReference.closest("form");if(form){form.reset();break}}}}_fields={}}_formValues=props.shouldUnregister?keepStateOptions.keepDefaultValues?cloneObject(_defaultValues):{}:cloneObject(values),_subjects.array.next({values:{...values}}),_subjects.values.next({values:{...values}})}_names={mount:keepStateOptions.keepDirtyValues?_names.mount:new Set,unMount:new Set,array:new Set,watch:new Set,watchAll:!1,focus:""},_state.mount=!_proxyFormState.isValid||!!keepStateOptions.keepIsValid||!!keepStateOptions.keepDirtyValues,_state.watch=!!props.shouldUnregister,_subjects.state.next({submitCount:keepStateOptions.keepSubmitCount?_formState.submitCount:0,isDirty:!isEmptyResetValues&&(keepStateOptions.keepDirty?_formState.isDirty:!(!keepStateOptions.keepDefaultValues||deepEqual(formValues,_defaultValues))),isSubmitted:!!keepStateOptions.keepIsSubmitted&&_formState.isSubmitted,dirtyFields:isEmptyResetValues?[]:keepStateOptions.keepDirtyValues?keepStateOptions.keepDefaultValues&&_formValues?getDirtyFields(_defaultValues,_formValues):_formState.dirtyFields:keepStateOptions.keepDefaultValues&&formValues?getDirtyFields(_defaultValues,formValues):{},touchedFields:keepStateOptions.keepTouched?_formState.touchedFields:{},errors:keepStateOptions.keepErrors?_formState.errors:{},isSubmitSuccessful:!!keepStateOptions.keepIsSubmitSuccessful&&_formState.isSubmitSuccessful,isSubmitting:!1})},reset=(formValues,keepStateOptions)=>_reset(isFunction(formValues)?formValues(_formValues):formValues,keepStateOptions);return{control:{register,unregister,getFieldState,handleSubmit,setError,_executeSchema,_getWatch,_getDirty,_updateValid,_removeUnmounted:()=>{for(const name of _names.unMount){const field=get(_fields,name);field&&(field._f.refs?field._f.refs.every((ref=>!live(ref))):!live(field._f.ref))&&unregister(name)}_names.unMount=new Set},_updateFieldArray:(name,values=[],method,args,shouldSetValues=!0,shouldUpdateFieldsAndState=!0)=>{if(args&&method){if(_state.action=!0,shouldUpdateFieldsAndState&&Array.isArray(get(_fields,name))){const fieldValues=method(get(_fields,name),args.argA,args.argB);shouldSetValues&&set(_fields,name,fieldValues)}if(shouldUpdateFieldsAndState&&Array.isArray(get(_formState.errors,name))){const errors=method(get(_formState.errors,name),args.argA,args.argB);shouldSetValues&&set(_formState.errors,name,errors),unsetEmptyArray(_formState.errors,name)}if(_proxyFormState.touchedFields&&shouldUpdateFieldsAndState&&Array.isArray(get(_formState.touchedFields,name))){const touchedFields=method(get(_formState.touchedFields,name),args.argA,args.argB);shouldSetValues&&set(_formState.touchedFields,name,touchedFields)}_proxyFormState.dirtyFields&&(_formState.dirtyFields=getDirtyFields(_defaultValues,_formValues)),_subjects.state.next({name,isDirty:_getDirty(name,values),dirtyFields:_formState.dirtyFields,errors:_formState.errors,isValid:_formState.isValid})}else set(_formValues,name,values)},_updateDisabledField,_getFieldArray:name=>compact(get(_state.mount?_formValues:_defaultValues,name,props.shouldUnregister?get(_defaultValues,name,[]):[])),_reset,_resetDefaultValues:()=>isFunction(_options.defaultValues)&&_options.defaultValues().then((values=>{reset(values,_options.resetOptions),_subjects.state.next({isLoading:!1})})),_updateFormState:updatedFormState=>{_formState={..._formState,...updatedFormState}},_disableForm:disabled=>{isBoolean(disabled)&&(_subjects.state.next({disabled}),iterateFieldsByAction(_fields,((ref,name)=>{let requiredDisabledState=disabled;const currentField=get(_fields,name);currentField&&isBoolean(currentField._f.disabled)&&(requiredDisabledState||(requiredDisabledState=currentField._f.disabled)),ref.disabled=requiredDisabledState}),0,!1))},_subjects,_proxyFormState,_setErrors:errors=>{_formState.errors=errors,_subjects.state.next({errors:_formState.errors,isValid:!1})},get _fields(){return _fields},get _formValues(){return _formValues},get _state(){return _state},set _state(value){_state=value},get _defaultValues(){return _defaultValues},get _names(){return _names},set _names(value){_names=value},get _formState(){return _formState},set _formState(value){_formState=value},get _options(){return _options},set _options(value){_options={..._options,...value}}},trigger,register,handleSubmit,watch:(name,defaultValue)=>isFunction(name)?_subjects.values.subscribe({next:payload=>name(_getWatch(void 0,defaultValue),payload)}):_getWatch(name,defaultValue,!0),setValue,getValues,reset,resetField:(name,options={})=>{get(_fields,name)&&(isUndefined(options.defaultValue)?setValue(name,cloneObject(get(_defaultValues,name))):(setValue(name,options.defaultValue),set(_defaultValues,name,cloneObject(options.defaultValue))),options.keepTouched||unset(_formState.touchedFields,name),options.keepDirty||(unset(_formState.dirtyFields,name),_formState.isDirty=options.defaultValue?_getDirty(name,cloneObject(get(_defaultValues,name))):_getDirty()),options.keepError||(unset(_formState.errors,name),_proxyFormState.isValid&&_updateValid()),_subjects.state.next({..._formState}))},clearErrors:name=>{name&&convertToArrayPayload(name).forEach((inputName=>unset(_formState.errors,inputName))),_subjects.state.next({errors:name?_formState.errors:{}})},unregister,setError,setFocus:(name,options={})=>{const field=get(_fields,name),fieldReference=field&&field._f;if(fieldReference){const fieldRef=fieldReference.refs?fieldReference.refs[0]:fieldReference.ref;fieldRef.focus&&(fieldRef.focus(),options.shouldSelect&&fieldRef.select())}},getFieldState}}function useForm(props={}){const _formControl=react__WEBPACK_IMPORTED_MODULE_0__.useRef(),_values=react__WEBPACK_IMPORTED_MODULE_0__.useRef(),[formState,updateFormState]=react__WEBPACK_IMPORTED_MODULE_0__.useState({isDirty:!1,isValidating:!1,isLoading:isFunction(props.defaultValues),isSubmitted:!1,isSubmitting:!1,isSubmitSuccessful:!1,isValid:!1,submitCount:0,dirtyFields:{},touchedFields:{},validatingFields:{},errors:props.errors||{},disabled:props.disabled||!1,defaultValues:isFunction(props.defaultValues)?void 0:props.defaultValues});_formControl.current||(_formControl.current={...createFormControl(props),formState});const control=_formControl.current.control;return control._options=props,useSubscribe({subject:control._subjects.state,next:value=>{shouldRenderFormState(value,control._proxyFormState,control._updateFormState,!0)&&updateFormState({...control._formState})}}),react__WEBPACK_IMPORTED_MODULE_0__.useEffect((()=>control._disableForm(props.disabled)),[control,props.disabled]),react__WEBPACK_IMPORTED_MODULE_0__.useEffect((()=>{if(control._proxyFormState.isDirty){const isDirty=control._getDirty();isDirty!==formState.isDirty&&control._subjects.state.next({isDirty})}}),[control,formState.isDirty]),react__WEBPACK_IMPORTED_MODULE_0__.useEffect((()=>{props.values&&!deepEqual(props.values,_values.current)?(control._reset(props.values,control._options.resetOptions),_values.current=props.values,updateFormState((state=>({...state})))):control._resetDefaultValues()}),[props.values,control]),react__WEBPACK_IMPORTED_MODULE_0__.useEffect((()=>{props.errors&&control._setErrors(props.errors)}),[props.errors,control]),react__WEBPACK_IMPORTED_MODULE_0__.useEffect((()=>{control._state.mount||(control._updateValid(),control._state.mount=!0),control._state.watch&&(control._state.watch=!1,control._subjects.state.next({...control._formState})),control._removeUnmounted()})),react__WEBPACK_IMPORTED_MODULE_0__.useEffect((()=>{props.shouldUnregister&&control._subjects.values.next({values:control._getWatch()})}),[props.shouldUnregister,control]),_formControl.current.formState=getProxyFormState(formState,control),_formControl.current}},"./node_modules/react-hot-toast/dist/index.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{l$:()=>Ie,Ay:()=>_t,oR:()=>dist_n});var react=__webpack_require__("./node_modules/next/dist/compiled/react/index.js");let e={data:""},t=t=>"object"==typeof window?((t?t.querySelector("#_goober"):window._goober)||Object.assign((t||document.head).appendChild(document.createElement("style")),{innerHTML:" ",id:"_goober"})).firstChild:t||e,l=/(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g,a=/\/\*[^]*?\*\/|  +/g,n=/\n+/g,o=(e,t)=>{let r="",l="",a="";for(let n in e){let c=e[n];"@"==n[0]?"i"==n[1]?r=n+" "+c+";":l+="f"==n[1]?o(c,n):n+"{"+o(c,"k"==n[1]?"":t)+"}":"object"==typeof c?l+=o(c,t?t.replace(/([^,])+/g,(e=>n.replace(/(^:.*)|([^,])+/g,(t=>/&/.test(t)?t.replace(/&/g,e):e?e+" "+t:t)))):n):null!=c&&(n=/^--/.test(n)?n:n.replace(/[A-Z]/g,"-$&").toLowerCase(),a+=o.p?o.p(n,c):n+":"+c+";")}return r+(t&&a?t+"{"+a+"}":a)+l},c={},s=e=>{if("object"==typeof e){let t="";for(let r in e)t+=r+s(e[r]);return t}return e},i=(e,t,r,i,p)=>{let u=s(e),d=c[u]||(c[u]=(e=>{let t=0,r=11;for(;t<e.length;)r=101*r+e.charCodeAt(t++)>>>0;return"go"+r})(u));if(!c[d]){let t=u!==e?e:(e=>{let t,r,o=[{}];for(;t=l.exec(e.replace(a,""));)t[4]?o.shift():t[3]?(r=t[3].replace(n," ").trim(),o.unshift(o[0][r]=o[0][r]||{})):o[0][t[1]]=t[2].replace(n," ").trim();return o[0]})(e);c[d]=o(p?{["@keyframes "+d]:t}:t,r?"":"."+d)}let f=r&&c.g?c.g:null;return r&&(c.g=c[d]),((e,t,r,l)=>{l?t.data=t.data.replace(l,e):-1===t.data.indexOf(e)&&(t.data=r?e+t.data:t.data+e)})(c[d],t,i,f),d},p=(e,t,r)=>e.reduce(((e,l,a)=>{let n=t[a];if(n&&n.call){let e=n(r),t=e&&e.props&&e.props.className||/^go/.test(e)&&e;n=t?"."+t:e&&"object"==typeof e?e.props?"":o(e,""):!1===e?"":e}return e+l+(null==n?"":n)}),"");function u(e){let r=this||{},l=e.call?e(r.p):e;return i(l.unshift?l.raw?p(l,[].slice.call(arguments,1),r.p):l.reduce(((e,t)=>Object.assign(e,t&&t.call?t(r.p):t)),{}):l,t(r.target),r.g,r.o,r.k)}u.bind({g:1});let d,f,g,h=u.bind({k:1});function j(e,t){let r=this||{};return function(){let l=arguments;function a(n,o){let c=Object.assign({},n),s=c.className||a.className;r.p=Object.assign({theme:f&&f()},c),r.o=/ *go\d+/.test(s),c.className=u.apply(r,l)+(s?" "+s:""),t&&(c.ref=o);let i=e;return e[0]&&(i=c.as||e,delete c.as),g&&i[0]&&g(c),d(i,c)}return t?t(a):a}}var T=(e,t)=>(e=>"function"==typeof e)(e)?e(t):e,U=(()=>{let e=0;return()=>(++e).toString()})(),dist_b=(()=>{let e;return()=>{if(void 0===e&&typeof window<"u"){let t=matchMedia("(prefers-reduced-motion: reduce)");e=!t||t.matches}return e}})(),S=new Map,$=e=>{if(S.has(e))return;let t=setTimeout((()=>{S.delete(e),dist_u({type:4,toastId:e})}),1e3);S.set(e,t)},v=(e,t)=>{switch(t.type){case 0:return{...e,toasts:[t.toast,...e.toasts].slice(0,20)};case 1:return t.toast.id&&(e=>{let t=S.get(e);t&&clearTimeout(t)})(t.toast.id),{...e,toasts:e.toasts.map((r=>r.id===t.toast.id?{...r,...t.toast}:r))};case 2:let{toast:o}=t;return e.toasts.find((r=>r.id===o.id))?v(e,{type:1,toast:o}):v(e,{type:0,toast:o});case 3:let{toastId:s}=t;return s?$(s):e.toasts.forEach((r=>{$(r.id)})),{...e,toasts:e.toasts.map((r=>r.id===s||void 0===s?{...r,visible:!1}:r))};case 4:return void 0===t.toastId?{...e,toasts:[]}:{...e,toasts:e.toasts.filter((r=>r.id!==t.toastId))};case 5:return{...e,pausedAt:t.time};case 6:let a=t.time-(e.pausedAt||0);return{...e,pausedAt:void 0,toasts:e.toasts.map((r=>({...r,pauseDuration:r.pauseDuration+a})))}}},A=[],P={toasts:[],pausedAt:void 0},dist_u=e=>{P=v(P,e),A.forEach((t=>{t(P)}))},Y={blank:4e3,error:4e3,success:2e3,loading:1/0,custom:4e3},dist_h=e=>(t,o)=>{let s=((e,t="blank",o)=>({createdAt:Date.now(),visible:!0,type:t,ariaProps:{role:"status","aria-live":"polite"},message:e,pauseDuration:0,...o,id:(null==o?void 0:o.id)||U()}))(t,e,o);return dist_u({type:2,toast:s}),s.id},dist_n=(e,t)=>dist_h("blank")(e,t);dist_n.error=dist_h("error"),dist_n.success=dist_h("success"),dist_n.loading=dist_h("loading"),dist_n.custom=dist_h("custom"),dist_n.dismiss=e=>{dist_u({type:3,toastId:e})},dist_n.remove=e=>dist_u({type:4,toastId:e}),dist_n.promise=(e,t,o)=>{let s=dist_n.loading(t.loading,{...o,...null==o?void 0:o.loading});return e.then((a=>(dist_n.success(T(t.success,a),{id:s,...o,...null==o?void 0:o.success}),a))).catch((a=>{dist_n.error(T(t.error,a),{id:s,...o,...null==o?void 0:o.error})})),e};var Z=(e,t)=>{dist_u({type:1,toast:{id:e,height:t}})},ee=()=>{dist_u({type:5,time:Date.now()})},D=e=>{let{toasts:t,pausedAt:o}=((e={})=>{let[t,o]=(0,react.useState)(P);(0,react.useEffect)((()=>(A.push(o),()=>{let a=A.indexOf(o);a>-1&&A.splice(a,1)})),[t]);let s=t.toasts.map((a=>{var r,c;return{...e,...e[a.type],...a,duration:a.duration||(null==(r=e[a.type])?void 0:r.duration)||(null==e?void 0:e.duration)||Y[a.type],style:{...e.style,...null==(c=e[a.type])?void 0:c.style,...a.style}}}));return{...t,toasts:s}})(e);(0,react.useEffect)((()=>{if(o)return;let r=Date.now(),c=t.map((i=>{if(i.duration===1/0)return;let d=(i.duration||0)+i.pauseDuration-(r-i.createdAt);if(!(d<0))return setTimeout((()=>dist_n.dismiss(i.id)),d);i.visible&&dist_n.dismiss(i.id)}));return()=>{c.forEach((i=>i&&clearTimeout(i)))}}),[t,o]);let s=(0,react.useCallback)((()=>{o&&dist_u({type:6,time:Date.now()})}),[o]),a=(0,react.useCallback)(((r,c)=>{let{reverseOrder:i=!1,gutter:d=8,defaultPosition:p}=c||{},g=t.filter((m=>(m.position||p)===(r.position||p)&&m.height)),E=g.findIndex((m=>m.id===r.id)),x=g.filter(((m,R)=>R<E&&m.visible)).length;return g.filter((m=>m.visible)).slice(...i?[x+1]:[0,x]).reduce(((m,R)=>m+(R.height||0)+d),0)}),[t]);return{toasts:t,handlers:{updateHeight:Z,startPause:ee,endPause:s,calculateOffset:a}}},oe=h`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`,re=h`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`,se=h`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`,_=j("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${e=>e.primary||"#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${oe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${re} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${e=>e.secondary||"#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${se} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`,ne=h`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`,V=j("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${e=>e.secondary||"#e0e0e0"};
  border-right-color: ${e=>e.primary||"#616161"};
  animation: ${ne} 1s linear infinite;
`,pe=h`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`,de=h`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`,w=j("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${e=>e.primary||"#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${pe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${de} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${e=>e.secondary||"#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`,ue=j("div")`
  position: absolute;
`,le=j("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`,Te=h`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`,fe=j("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${Te} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`,M=({toast:e})=>{let{icon:t,type:o,iconTheme:s}=e;return void 0!==t?"string"==typeof t?react.createElement(fe,null,t):t:"blank"===o?null:react.createElement(le,null,react.createElement(V,{...s}),"loading"!==o&&react.createElement(ue,null,"error"===o?react.createElement(_,{...s}):react.createElement(w,{...s})))},ye=e=>`\n0% {transform: translate3d(0,${-200*e}%,0) scale(.6); opacity:.5;}\n100% {transform: translate3d(0,0,0) scale(1); opacity:1;}\n`,ge=e=>`\n0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}\n100% {transform: translate3d(0,${-150*e}%,-1px) scale(.6); opacity:0;}\n`,be=j("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`,Se=j("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`,F=react.memo((({toast:e,position:t,style:o,children:s})=>{let a=e.height?((e,t)=>{let s=e.includes("top")?1:-1,[a,r]=dist_b()?["0%{opacity:0;} 100%{opacity:1;}","0%{opacity:1;} 100%{opacity:0;}"]:[ye(s),ge(s)];return{animation:t?`${h(a)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards`:`${h(r)} 0.4s forwards cubic-bezier(.06,.71,.55,1)`}})(e.position||t||"top-center",e.visible):{opacity:0},r=react.createElement(M,{toast:e}),c=react.createElement(Se,{...e.ariaProps},T(e.message,e));return react.createElement(be,{className:e.className,style:{...a,...o,...e.style}},"function"==typeof s?s({icon:r,message:c}):react.createElement(react.Fragment,null,r,c))}));!function m(e,t,r,l){o.p=t,d=e,f=r,g=l}(react.createElement);var Ee=({id:e,className:t,style:o,onHeightUpdate:s,children:a})=>{let r=react.useCallback((c=>{if(c){let i=()=>{let d=c.getBoundingClientRect().height;s(e,d)};i(),new MutationObserver(i).observe(c,{subtree:!0,childList:!0,characterData:!0})}}),[e,s]);return react.createElement("div",{ref:r,className:t,style:o},a)},ve=u`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`,Ie=({reverseOrder:e,position:t="top-center",toastOptions:o,gutter:s,children:a,containerStyle:r,containerClassName:c})=>{let{toasts:i,handlers:d}=D(o);return react.createElement("div",{style:{position:"fixed",zIndex:9999,top:16,left:16,right:16,bottom:16,pointerEvents:"none",...r},className:c,onMouseEnter:d.startPause,onMouseLeave:d.endPause},i.map((p=>{let g=p.position||t,x=((e,t)=>{let o=e.includes("top"),s=o?{top:0}:{bottom:0},a=e.includes("center")?{justifyContent:"center"}:e.includes("right")?{justifyContent:"flex-end"}:{};return{left:0,right:0,display:"flex",position:"absolute",transition:dist_b()?void 0:"all 230ms cubic-bezier(.21,1.02,.73,1)",transform:`translateY(${t*(o?1:-1)}px)`,...s,...a}})(g,d.calculateOffset(p,{reverseOrder:e,gutter:s,defaultPosition:t}));return react.createElement(Ee,{id:p.id,key:p.id,onHeightUpdate:d.updateHeight,className:p.visible?ve:"",style:x},"custom"===p.type?T(p.message,p):a?a(p):react.createElement(F,{toast:p,position:g}))})))},_t=dist_n},"./node_modules/recoil/es/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{L4:()=>Recoil_index_22,bi:()=>Recoil_index_5,eU:()=>Recoil_index_8,vc:()=>Recoil_index_20});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/next/dist/compiled/react/index.js"),react_dom__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/next/dist/compiled/react-dom/index.js"),process=__webpack_require__("./node_modules/process/browser.js"),console=__webpack_require__("./node_modules/console-browserify/index.js");var Recoil_err=function err(message){const error=new Error(message);if(void 0===error.stack)try{throw error}catch(_){}return error};var Recoil_isPromise=function isPromise(p){return!!p&&"function"==typeof p.then};var Recoil_nullthrows=function nullthrows(x,message){if(null!=x)return x;throw Recoil_err(null!=message?message:"Got unexpected null or undefined")};function _defineProperty(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}class BaseLoadable{getValue(){throw Recoil_err("BaseLoadable")}toPromise(){throw Recoil_err("BaseLoadable")}valueMaybe(){throw Recoil_err("BaseLoadable")}valueOrThrow(){throw Recoil_err(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw Recoil_err("BaseLoadable")}promiseOrThrow(){throw Recoil_err(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw Recoil_err("BaseLoadable")}errorOrThrow(){throw Recoil_err(`Loadable expected error, but in "${this.state}" state`)}is(other){return other.state===this.state&&other.contents===this.contents}map(_map){throw Recoil_err("BaseLoadable")}}class ValueLoadable extends BaseLoadable{constructor(value){super(),_defineProperty(this,"state","hasValue"),_defineProperty(this,"contents",void 0),this.contents=value}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(map){try{const next=map(this.contents);return Recoil_isPromise(next)?loadableWithPromise(next):isLoadable(next)?next:loadableWithValue(next)}catch(e){return Recoil_isPromise(e)?loadableWithPromise(e.next((()=>this.map(map)))):loadableWithError(e)}}}class ErrorLoadable extends BaseLoadable{constructor(error){super(),_defineProperty(this,"state","hasError"),_defineProperty(this,"contents",void 0),this.contents=error}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(_map){return this}}class LoadingLoadable extends BaseLoadable{constructor(promise){super(),_defineProperty(this,"state","loading"),_defineProperty(this,"contents",void 0),this.contents=promise}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(map){return loadableWithPromise(this.contents.then((value=>{const next=map(value);if(isLoadable(next)){const nextLoadable=next;switch(nextLoadable.state){case"hasValue":case"loading":return nextLoadable.contents;case"hasError":throw nextLoadable.contents}}return next})).catch((e=>{if(Recoil_isPromise(e))return e.then((()=>this.map(map).contents));throw e})))}}function loadableWithValue(value){return Object.freeze(new ValueLoadable(value))}function loadableWithError(error){return Object.freeze(new ErrorLoadable(error))}function loadableWithPromise(promise){return Object.freeze(new LoadingLoadable(promise))}function loadableLoading(){return Object.freeze(new LoadingLoadable(new Promise((()=>{}))))}function loadableAll(inputs){const output=function loadableAllArray(inputs){return inputs.every((i=>"hasValue"===i.state))?loadableWithValue(inputs.map((i=>i.contents))):inputs.some((i=>"hasError"===i.state))?loadableWithError(Recoil_nullthrows(inputs.find((i=>"hasError"===i.state)),"Invalid loadable passed to loadableAll").contents):loadableWithPromise(Promise.all(inputs.map((i=>i.contents))))}((Array.isArray(inputs)?inputs:Object.getOwnPropertyNames(inputs).map((key=>inputs[key]))).map((x=>isLoadable(x)?x:Recoil_isPromise(x)?loadableWithPromise(x):loadableWithValue(x))));return Array.isArray(inputs)?output:output.map((outputs=>Object.getOwnPropertyNames(inputs).reduce(((out,key,idx)=>({...out,[key]:outputs[idx]})),{})))}function isLoadable(x){return x instanceof BaseLoadable}const LoadableStaticInterface={of:value=>Recoil_isPromise(value)?loadableWithPromise(value):isLoadable(value)?value:loadableWithValue(value),error:error=>loadableWithError(error),loading:()=>loadableLoading(),all:loadableAll,isLoadable};var Recoil_Loadable={loadableWithValue,loadableWithError,loadableWithPromise,loadableLoading,loadableAll,isLoadable,RecoilLoadable:LoadableStaticInterface},Recoil_Loadable_1=Recoil_Loadable.loadableWithValue,Recoil_Loadable_2=Recoil_Loadable.loadableWithError,Recoil_Loadable_3=Recoil_Loadable.loadableWithPromise,Recoil_Loadable_4=Recoil_Loadable.loadableLoading,Recoil_Loadable_5=Recoil_Loadable.loadableAll,Recoil_Loadable_6=Recoil_Loadable.isLoadable,Recoil_Loadable_7=Recoil_Loadable.RecoilLoadable,Recoil_Loadable$1=Object.freeze({__proto__:null,loadableWithValue:Recoil_Loadable_1,loadableWithError:Recoil_Loadable_2,loadableWithPromise:Recoil_Loadable_3,loadableLoading:Recoil_Loadable_4,loadableAll:Recoil_Loadable_5,isLoadable:Recoil_Loadable_6,RecoilLoadable:Recoil_Loadable_7});const env={RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED:!0,RECOIL_GKS_ENABLED:new Set(["recoil_hamt_2020","recoil_sync_external_store","recoil_suppress_rerender_in_callback","recoil_memory_managament_2020"])};!function applyProcessEnvFlagOverrides(){void 0!==process&&null!=(null===process||void 0===process?void 0:process.env)&&(!function readProcessEnvBooleanFlag(name,set){var _process$env$name,_process$env$name$toL;const sanitizedValue=null===(_process$env$name=process.env[name])||void 0===_process$env$name||null===(_process$env$name$toL=_process$env$name.toLowerCase())||void 0===_process$env$name$toL?void 0:_process$env$name$toL.trim();if(null==sanitizedValue||""===sanitizedValue)return;if(!["true","false"].includes(sanitizedValue))throw Recoil_err(`process.env.${name} value must be 'true', 'false', or empty: ${sanitizedValue}`);set("true"===sanitizedValue)}("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED",(value=>{env.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED=value})),function readProcessEnvStringArrayFlag(name,set){var _process$env$name2;const sanitizedValue=null===(_process$env$name2=process.env[name])||void 0===_process$env$name2?void 0:_process$env$name2.trim();null!=sanitizedValue&&""!==sanitizedValue&&set(sanitizedValue.split(/\s*,\s*|\s+/))}("RECOIL_GKS_ENABLED",(value=>{value.forEach((gk=>{env.RECOIL_GKS_ENABLED.add(gk)}))})))}();var Recoil_RecoilEnv=env;function Recoil_gkx_OSS(gk){return Recoil_RecoilEnv.RECOIL_GKS_ENABLED.has(gk)}Recoil_gkx_OSS.setPass=gk=>{Recoil_RecoilEnv.RECOIL_GKS_ENABLED.add(gk)},Recoil_gkx_OSS.setFail=gk=>{Recoil_RecoilEnv.RECOIL_GKS_ENABLED.delete(gk)},Recoil_gkx_OSS.clear=()=>{Recoil_RecoilEnv.RECOIL_GKS_ENABLED.clear()};var Recoil_gkx=Recoil_gkx_OSS;var _createMutableSource,_useMutableSource,_useSyncExternalStore,Recoil_recoverableViolation=function recoverableViolation(message,_projectName,{error}={}){return null};const createMutableSource=null!==(_createMutableSource=react__WEBPACK_IMPORTED_MODULE_0__.createMutableSource)&&void 0!==_createMutableSource?_createMutableSource:react__WEBPACK_IMPORTED_MODULE_0__.unstable_createMutableSource,useMutableSource=null!==(_useMutableSource=react__WEBPACK_IMPORTED_MODULE_0__.useMutableSource)&&void 0!==_useMutableSource?_useMutableSource:react__WEBPACK_IMPORTED_MODULE_0__.unstable_useMutableSource,useSyncExternalStore=null!==(_useSyncExternalStore=react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)&&void 0!==_useSyncExternalStore?_useSyncExternalStore:react__WEBPACK_IMPORTED_MODULE_0__.unstable_useSyncExternalStore;let ReactRendererVersionMismatchWarnOnce=!1;var Recoil_ReactMode={createMutableSource,useMutableSource,useSyncExternalStore,currentRendererSupportsUseSyncExternalStore:function currentRendererSupportsUseSyncExternalStore(){var _ReactCurrentDispatch;const{ReactCurrentDispatcher,ReactCurrentOwner}=react__WEBPACK_IMPORTED_MODULE_0__.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,isUseSyncExternalStoreSupported=null!=(null!==(_ReactCurrentDispatch=null==ReactCurrentDispatcher?void 0:ReactCurrentDispatcher.current)&&void 0!==_ReactCurrentDispatch?_ReactCurrentDispatch:ReactCurrentOwner.currentDispatcher).useSyncExternalStore;return!useSyncExternalStore||isUseSyncExternalStoreSupported||ReactRendererVersionMismatchWarnOnce||(ReactRendererVersionMismatchWarnOnce=!0,Recoil_recoverableViolation("A React renderer without React 18+ API support is being used with React 18+.")),isUseSyncExternalStoreSupported},reactMode:function reactMode(){return Recoil_gkx("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:Recoil_gkx("recoil_sync_external_store")&&null!=useSyncExternalStore?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:Recoil_gkx("recoil_mutable_source")&&null!=useMutableSource&&"undefined"!=typeof window&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?Recoil_gkx("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:Recoil_gkx("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}},isFastRefreshEnabled:function isFastRefreshEnabled(){return!1}};class AbstractRecoilValue{constructor(newKey){_defineProperty(this,"key",void 0),this.key=newKey}toJSON(){return{key:this.key}}}class RecoilState extends AbstractRecoilValue{}class RecoilValueReadOnly extends AbstractRecoilValue{}var Recoil_RecoilValue={AbstractRecoilValue,RecoilState,RecoilValueReadOnly,isRecoilValue:function isRecoilValue(x){return x instanceof RecoilState||x instanceof RecoilValueReadOnly}},Recoil_RecoilValue_1=Recoil_RecoilValue.AbstractRecoilValue,Recoil_RecoilValue_2=Recoil_RecoilValue.RecoilState,Recoil_RecoilValue_3=Recoil_RecoilValue.RecoilValueReadOnly,Recoil_RecoilValue_4=Recoil_RecoilValue.isRecoilValue,Recoil_RecoilValue$1=Object.freeze({__proto__:null,AbstractRecoilValue:Recoil_RecoilValue_1,RecoilState:Recoil_RecoilValue_2,RecoilValueReadOnly:Recoil_RecoilValue_3,isRecoilValue:Recoil_RecoilValue_4});var Recoil_expectationViolation=function expectationViolation(format,...args){0};var Recoil_mapIterable=function mapIterable(iterable,callback){return function*(){let index=0;for(const value of iterable)yield callback(value,index++)}()};const{isFastRefreshEnabled:isFastRefreshEnabled$1}=Recoil_ReactMode;class DefaultValue{}const DEFAULT_VALUE=new DefaultValue,nodes=new Map,recoilValues=new Map;class NodeMissingError extends Error{}const configDeletionHandlers=new Map;function getConfigDeletionHandler(key){return configDeletionHandlers.get(key)}var Recoil_Node={nodes,recoilValues,registerNode:function registerNode(node){Recoil_RecoilEnv.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED&&function checkForDuplicateAtomKey(key){if(nodes.has(key)){const message=`Duplicate atom key "${key}". This is a FATAL ERROR in\n      production. But it is safe to ignore this warning if it occurred because of\n      hot module replacement.`;console.warn(message)}}(node.key),nodes.set(node.key,node);const recoilValue=null==node.set?new Recoil_RecoilValue$1.RecoilValueReadOnly(node.key):new Recoil_RecoilValue$1.RecoilState(node.key);return recoilValues.set(node.key,recoilValue),recoilValue},getNode:function getNode(key){const node=nodes.get(key);if(null==node)throw new NodeMissingError(`Missing definition for RecoilValue: "${key}""`);return node},getNodeMaybe:function getNodeMaybe(key){return nodes.get(key)},deleteNodeConfigIfPossible:function deleteNodeConfigIfPossible(key){var _node$shouldDeleteCon;if(!Recoil_gkx("recoil_memory_managament_2020"))return;const node=nodes.get(key);var _getConfigDeletionHan;null!=node&&null!==(_node$shouldDeleteCon=node.shouldDeleteConfigOnRelease)&&void 0!==_node$shouldDeleteCon&&_node$shouldDeleteCon.call(node)&&(nodes.delete(key),null===(_getConfigDeletionHan=getConfigDeletionHandler(key))||void 0===_getConfigDeletionHan||_getConfigDeletionHan(),configDeletionHandlers.delete(key))},setConfigDeletionHandler:function setConfigDeletionHandler(key,fn){Recoil_gkx("recoil_memory_managament_2020")&&(void 0===fn?configDeletionHandlers.delete(key):configDeletionHandlers.set(key,fn))},getConfigDeletionHandler,recoilValuesForKeys:function recoilValuesForKeys(keys){return Recoil_mapIterable(keys,(key=>Recoil_nullthrows(recoilValues.get(key))))},NodeMissingError,DefaultValue,DEFAULT_VALUE};var Recoil_Queue={enqueueExecution:function enqueueExecution(s,f){f()}};var hamt_1=function createCommonjsModule(fn,module){return fn(module={exports:{}},module.exports),module.exports}((function(module){var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},hamt={},BUCKET_SIZE=Math.pow(2,5),MASK=BUCKET_SIZE-1,MAX_INDEX_NODE=BUCKET_SIZE/2,MIN_ARRAY_NODE=BUCKET_SIZE/4,nothing={},constant=function constant(x){return function(){return x}},hash=hamt.hash=function(str){var type=void 0===str?"undefined":_typeof(str);if("number"===type)return str;"string"!==type&&(str+="");for(var hash=0,i=0,len=str.length;i<len;++i){hash=(hash<<5)-hash+str.charCodeAt(i)|0}return hash},hashFragment=function hashFragment(shift,h){return h>>>shift&MASK},toBitmap=function toBitmap(x){return 1<<x},fromBitmap=function fromBitmap(bitmap,bit){return function popcount(x){return x=(x=(858993459&(x-=x>>1&1431655765))+(x>>2&858993459))+(x>>4)&252645135,x+=x>>8,127&x+(x>>16)}(bitmap&bit-1)},arrayUpdate=function arrayUpdate(mutate,at,v,arr){var out=arr;if(!mutate){var len=arr.length;out=new Array(len);for(var i=0;i<len;++i)out[i]=arr[i]}return out[at]=v,out},arraySpliceOut=function arraySpliceOut(mutate,at,arr){var newLen=arr.length-1,i=0,g=0,out=arr;if(mutate)i=g=at;else for(out=new Array(newLen);i<at;)out[g++]=arr[i++];for(++i;i<=newLen;)out[g++]=arr[i++];return mutate&&(out.length=newLen),out},empty={__hamt_isEmpty:!0},isEmptyNode=function isEmptyNode(x){return x===empty||x&&x.__hamt_isEmpty},Leaf=function Leaf(edit,hash,key,value){return{type:1,edit,hash,key,value,_modify:Leaf__modify}},Collision=function Collision(edit,hash,children){return{type:2,edit,hash,children,_modify:Collision__modify}},IndexedNode=function IndexedNode(edit,mask,children){return{type:3,edit,mask,children,_modify:IndexedNode__modify}},ArrayNode=function ArrayNode(edit,size,children){return{type:4,edit,size,children,_modify:ArrayNode__modify}},mergeLeaves=function mergeLeaves(edit,shift,h1,n1,h2,n2){if(h1===h2)return Collision(edit,h1,[n2,n1]);var subH1=hashFragment(shift,h1),subH2=hashFragment(shift,h2);return IndexedNode(edit,toBitmap(subH1)|toBitmap(subH2),subH1===subH2?[mergeLeaves(edit,shift+5,h1,n1,h2,n2)]:subH1<subH2?[n1,n2]:[n2,n1])},canEditNode=function canEditNode(edit,node){return edit===node.edit},Leaf__modify=function Leaf__modify(edit,keyEq,shift,f,h,k,size){if(keyEq(k,this.key)){var _v=f(this.value);return _v===this.value?this:_v===nothing?(--size.value,empty):canEditNode(edit,this)?(this.value=_v,this):Leaf(edit,h,k,_v)}var v=f();return v===nothing?this:(++size.value,mergeLeaves(edit,shift,this.hash,this,h,Leaf(edit,h,k,v)))},Collision__modify=function Collision__modify(edit,keyEq,shift,f,h,k,size){if(h===this.hash){var list=function updateCollisionList(mutate,edit,keyEq,h,list,f,k,size){for(var len=list.length,i=0;i<len;++i){var child=list[i];if(keyEq(k,child.key)){var value=child.value,_newValue=f(value);return _newValue===value?list:_newValue===nothing?(--size.value,arraySpliceOut(mutate,i,list)):arrayUpdate(mutate,i,Leaf(edit,h,k,_newValue),list)}}var newValue=f();return newValue===nothing?list:(++size.value,arrayUpdate(mutate,len,Leaf(edit,h,k,newValue),list))}(canEditNode(edit,this),edit,keyEq,this.hash,this.children,f,k,size);return list===this.children?this:list.length>1?Collision(edit,this.hash,list):list[0]}var v=f();return v===nothing?this:(++size.value,mergeLeaves(edit,shift,this.hash,this,h,Leaf(edit,h,k,v)))},IndexedNode__modify=function IndexedNode__modify(edit,keyEq,shift,f,h,k,size){var mask=this.mask,children=this.children,frag=hashFragment(shift,h),bit=toBitmap(frag),indx=fromBitmap(mask,bit),exists=mask&bit,current=exists?children[indx]:empty,child=current._modify(edit,keyEq,shift+5,f,h,k,size);if(current===child)return this;var canEdit=canEditNode(edit,this),bitmap=mask,newChildren=void 0;if(exists&&isEmptyNode(child)){if(!(bitmap&=~bit))return empty;if(children.length<=2&&function isLeaf(node){return node===empty||1===node.type||2===node.type}(children[1^indx]))return children[1^indx];newChildren=arraySpliceOut(canEdit,indx,children)}else if(exists||isEmptyNode(child))newChildren=arrayUpdate(canEdit,indx,child,children);else{if(children.length>=MAX_INDEX_NODE)return function expand(edit,frag,child,bitmap,subNodes){for(var arr=[],bit=bitmap,count=0,i=0;bit;++i)1&bit&&(arr[i]=subNodes[count++]),bit>>>=1;return arr[frag]=child,ArrayNode(edit,count+1,arr)}(edit,frag,child,mask,children);bitmap|=bit,newChildren=function arraySpliceIn(mutate,at,v,arr){var len=arr.length;if(mutate){for(var _i=len;_i>=at;)arr[_i--]=arr[_i];return arr[at]=v,arr}for(var i=0,g=0,out=new Array(len+1);i<at;)out[g++]=arr[i++];for(out[at]=v;i<len;)out[++g]=arr[i++];return out}(canEdit,indx,child,children)}return canEdit?(this.mask=bitmap,this.children=newChildren,this):IndexedNode(edit,bitmap,newChildren)},ArrayNode__modify=function ArrayNode__modify(edit,keyEq,shift,f,h,k,size){var count=this.size,children=this.children,frag=hashFragment(shift,h),child=children[frag],newChild=(child||empty)._modify(edit,keyEq,shift+5,f,h,k,size);if(child===newChild)return this;var canEdit=canEditNode(edit,this),newChildren=void 0;if(isEmptyNode(child)&&!isEmptyNode(newChild))++count,newChildren=arrayUpdate(canEdit,frag,newChild,children);else if(!isEmptyNode(child)&&isEmptyNode(newChild)){if(--count<=MIN_ARRAY_NODE)return function pack(edit,count,removed,elements){for(var children=new Array(count-1),g=0,bitmap=0,i=0,len=elements.length;i<len;++i)if(i!==removed){var elem=elements[i];elem&&!isEmptyNode(elem)&&(children[g++]=elem,bitmap|=1<<i)}return IndexedNode(edit,bitmap,children)}(edit,count,frag,children);newChildren=arrayUpdate(canEdit,frag,empty,children)}else newChildren=arrayUpdate(canEdit,frag,newChild,children);return canEdit?(this.size=count,this.children=newChildren,this):ArrayNode(edit,count,newChildren)};function Map(editable,edit,config,root,size){this._editable=editable,this._edit=edit,this._config=config,this._root=root,this._size=size}empty._modify=function(edit,keyEq,shift,f,h,k,size){var v=f();return v===nothing?empty:(++size.value,Leaf(edit,h,k,v))},Map.prototype.setTree=function(newRoot,newSize){return this._editable?(this._root=newRoot,this._size=newSize,this):newRoot===this._root?this:new Map(this._editable,this._edit,this._config,newRoot,newSize)};var tryGetHash=hamt.tryGetHash=function(alt,hash,key,map){for(var node=map._root,shift=0,keyEq=map._config.keyEq;;)switch(node.type){case 1:return keyEq(key,node.key)?node.value:alt;case 2:if(hash===node.hash)for(var children=node.children,i=0,len=children.length;i<len;++i){var child=children[i];if(keyEq(key,child.key))return child.value}return alt;case 3:var frag=hashFragment(shift,hash),bit=toBitmap(frag);if(node.mask&bit){node=node.children[fromBitmap(node.mask,bit)],shift+=5;break}return alt;case 4:if(node=node.children[hashFragment(shift,hash)]){shift+=5;break}return alt;default:return alt}};Map.prototype.tryGetHash=function(alt,hash,key){return tryGetHash(alt,hash,key,this)};var tryGet=hamt.tryGet=function(alt,key,map){return tryGetHash(alt,map._config.hash(key),key,map)};Map.prototype.tryGet=function(alt,key){return tryGet(alt,key,this)};var getHash=hamt.getHash=function(hash,key,map){return tryGetHash(void 0,hash,key,map)};Map.prototype.getHash=function(hash,key){return getHash(hash,key,this)};hamt.get=function(key,map){return tryGetHash(void 0,map._config.hash(key),key,map)};Map.prototype.get=function(key,alt){return tryGet(alt,key,this)};var hasHash=hamt.has=function(hash,key,map){return tryGetHash(nothing,hash,key,map)!==nothing};Map.prototype.hasHash=function(hash,key){return hasHash(hash,key,this)};var has=hamt.has=function(key,map){return hasHash(map._config.hash(key),key,map)};Map.prototype.has=function(key){return has(key,this)};var defKeyCompare=function defKeyCompare(x,y){return x===y};hamt.make=function(config){return new Map(0,0,{keyEq:config&&config.keyEq||defKeyCompare,hash:config&&config.hash||hash},empty,0)},hamt.empty=hamt.make();var isEmpty=hamt.isEmpty=function(map){return map&&!!isEmptyNode(map._root)};Map.prototype.isEmpty=function(){return isEmpty(this)};var modifyHash=hamt.modifyHash=function(f,hash,key,map){var size={value:map._size},newRoot=map._root._modify(map._editable?map._edit:NaN,map._config.keyEq,0,f,hash,key,size);return map.setTree(newRoot,size.value)};Map.prototype.modifyHash=function(hash,key,f){return modifyHash(f,hash,key,this)};var modify=hamt.modify=function(f,key,map){return modifyHash(f,map._config.hash(key),key,map)};Map.prototype.modify=function(key,f){return modify(f,key,this)};var setHash=hamt.setHash=function(hash,key,value,map){return modifyHash(constant(value),hash,key,map)};Map.prototype.setHash=function(hash,key,value){return setHash(hash,key,value,this)};var set=hamt.set=function(key,value,map){return setHash(map._config.hash(key),key,value,map)};Map.prototype.set=function(key,value){return set(key,value,this)};var del=constant(nothing),removeHash=hamt.removeHash=function(hash,key,map){return modifyHash(del,hash,key,map)};Map.prototype.removeHash=Map.prototype.deleteHash=function(hash,key){return removeHash(hash,key,this)};var remove=hamt.remove=function(key,map){return removeHash(map._config.hash(key),key,map)};Map.prototype.remove=Map.prototype.delete=function(key){return remove(key,this)};var beginMutation=hamt.beginMutation=function(map){return new Map(map._editable+1,map._edit+1,map._config,map._root,map._size)};Map.prototype.beginMutation=function(){return beginMutation(this)};var endMutation=hamt.endMutation=function(map){return map._editable=map._editable&&map._editable-1,map};Map.prototype.endMutation=function(){return endMutation(this)};var mutate=hamt.mutate=function(f,map){var transient=beginMutation(map);return f(transient),endMutation(transient)};Map.prototype.mutate=function(f){return mutate(f,this)};var appk=function appk(k){return k&&lazyVisitChildren(k[0],k[1],k[2],k[3],k[4])},lazyVisitChildren=function lazyVisitChildren(len,children,i,f,k){for(;i<len;){var child=children[i++];if(child&&!isEmptyNode(child))return lazyVisit(child,f,[len,children,i,f,k])}return appk(k)},lazyVisit=function lazyVisit(node,f,k){switch(node.type){case 1:return{value:f(node),rest:k};case 2:case 4:case 3:var children=node.children;return lazyVisitChildren(children.length,children,0,f,k);default:return appk(k)}},DONE={done:!0};function MapIterator(v){this.v=v}MapIterator.prototype.next=function(){if(!this.v)return DONE;var v0=this.v;return this.v=appk(v0.rest),v0},MapIterator.prototype[Symbol.iterator]=function(){return this};var visit=function visit(map,f){return new MapIterator(lazyVisit(map._root,f))},buildPairs=function buildPairs(x){return[x.key,x.value]},entries=hamt.entries=function(map){return visit(map,buildPairs)};Map.prototype.entries=Map.prototype[Symbol.iterator]=function(){return entries(this)};var buildKeys=function buildKeys(x){return x.key},keys=hamt.keys=function(map){return visit(map,buildKeys)};Map.prototype.keys=function(){return keys(this)};var buildValues=function buildValues(x){return x.value},values=hamt.values=Map.prototype.values=function(map){return visit(map,buildValues)};Map.prototype.values=function(){return values(this)};var fold=hamt.fold=function(f,z,m){var root=m._root;if(1===root.type)return f(z,root.value,root.key);for(var toVisit=[root.children],children=void 0;children=toVisit.pop();)for(var i=0,len=children.length;i<len;){var child=children[i++];child&&child.type&&(1===child.type?z=f(z,child.value,child.key):toVisit.push(child.children))}return z};Map.prototype.fold=function(f,z){return fold(f,z,this)};var forEach=hamt.forEach=function(f,map){return fold((function(_,value,key){return f(value,key,map)}),null,map)};Map.prototype.forEach=function(f){return forEach(f,this)};var count=hamt.count=function(map){return map._size};Map.prototype.count=function(){return count(this)},Object.defineProperty(Map.prototype,"size",{get:Map.prototype.count}),module.exports?module.exports=hamt:(void 0).hamt=hamt}));class BuiltInMap{constructor(existing){_defineProperty(this,"_map",void 0),this._map=new Map(null==existing?void 0:existing.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(k){return this._map.get(k)}has(k){return this._map.has(k)}set(k,v){return this._map.set(k,v),this}delete(k){return this._map.delete(k),this}clone(){return persistentMap(this)}toMap(){return new Map(this._map)}}class HashArrayMappedTrieMap{constructor(existing){if(_defineProperty(this,"_hamt",hamt_1.empty.beginMutation()),existing instanceof HashArrayMappedTrieMap){const h=existing._hamt.endMutation();existing._hamt=h.beginMutation(),this._hamt=h.beginMutation()}else if(existing)for(const[k,v]of existing.entries())this._hamt.set(k,v)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(k){return this._hamt.get(k)}has(k){return this._hamt.has(k)}set(k,v){return this._hamt.set(k,v),this}delete(k){return this._hamt.delete(k),this}clone(){return persistentMap(this)}toMap(){return new Map(this._hamt)}}function persistentMap(existing){return Recoil_gkx("recoil_hamt_2020")?new HashArrayMappedTrieMap(existing):new BuiltInMap(existing)}var Recoil_PersistentMap_1=persistentMap,Recoil_PersistentMap$1=Object.freeze({__proto__:null,persistentMap:Recoil_PersistentMap_1});var Recoil_differenceSets=function differenceSets(set,...setsWithValuesToRemove){const ret=new Set;FIRST:for(const value of set){for(const otherSet of setsWithValuesToRemove)if(otherSet.has(value))continue FIRST;ret.add(value)}return ret};var Recoil_mapMap=function mapMap(map,callback){const result=new Map;return map.forEach(((value,key)=>{result.set(key,callback(value,key))})),result};function mergeDepsIntoGraph(key,newDeps,graph,olderGraph){const{nodeDeps,nodeToNodeSubscriptions}=graph,oldDeps=nodeDeps.get(key);if(oldDeps&&olderGraph&&oldDeps!==olderGraph.nodeDeps.get(key))return;nodeDeps.set(key,newDeps);const addedDeps=null==oldDeps?newDeps:Recoil_differenceSets(newDeps,oldDeps);for(const dep of addedDeps){nodeToNodeSubscriptions.has(dep)||nodeToNodeSubscriptions.set(dep,new Set);Recoil_nullthrows(nodeToNodeSubscriptions.get(dep)).add(key)}if(oldDeps){const removedDeps=Recoil_differenceSets(oldDeps,newDeps);for(const dep of removedDeps){if(!nodeToNodeSubscriptions.has(dep))return;const existing=Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));existing.delete(key),0===existing.size&&nodeToNodeSubscriptions.delete(dep)}}}var Recoil_Graph={cloneGraph:function cloneGraph(graph){return{nodeDeps:Recoil_mapMap(graph.nodeDeps,(s=>new Set(s))),nodeToNodeSubscriptions:Recoil_mapMap(graph.nodeToNodeSubscriptions,(s=>new Set(s)))}},graph:function makeGraph(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}},saveDepsToStore:function saveDepsToStore(key,deps,store,version){var _storeState$nextTree,_storeState$previousT,_storeState$previousT2,_storeState$previousT3;const storeState=store.getState();version!==storeState.currentTree.version&&version!==(null===(_storeState$nextTree=storeState.nextTree)||void 0===_storeState$nextTree?void 0:_storeState$nextTree.version)&&version!==(null===(_storeState$previousT=storeState.previousTree)||void 0===_storeState$previousT?void 0:_storeState$previousT.version)&&Recoil_recoverableViolation("Tried to save dependencies to a discarded tree");const graph=store.getGraph(version);if(mergeDepsIntoGraph(key,deps,graph),version===(null===(_storeState$previousT2=storeState.previousTree)||void 0===_storeState$previousT2?void 0:_storeState$previousT2.version)){mergeDepsIntoGraph(key,deps,store.getGraph(storeState.currentTree.version),graph)}if(version===(null===(_storeState$previousT3=storeState.previousTree)||void 0===_storeState$previousT3?void 0:_storeState$previousT3.version)||version===storeState.currentTree.version){var _storeState$nextTree2;const nextVersion=null===(_storeState$nextTree2=storeState.nextTree)||void 0===_storeState$nextTree2?void 0:_storeState$nextTree2.version;if(void 0!==nextVersion){mergeDepsIntoGraph(key,deps,store.getGraph(nextVersion),graph)}}}};let nextTreeStateVersion=0;let nextStoreID=0;let nextComponentID=0;var Recoil_Keys={getNextTreeStateVersion:()=>nextTreeStateVersion++,getNextStoreID:()=>nextStoreID++,getNextComponentID:()=>nextComponentID++};const{persistentMap:persistentMap$1}=Recoil_PersistentMap$1,{graph}=Recoil_Graph,{getNextTreeStateVersion:getNextTreeStateVersion$1}=Recoil_Keys;function makeEmptyTreeState(){const version=getNextTreeStateVersion$1();return{version,stateID:version,transactionMetadata:{},dirtyAtoms:new Set,atomValues:persistentMap$1(),nonvalidatedAtoms:persistentMap$1()}}var Recoil_State={makeEmptyTreeState,makeEmptyStoreState:function makeEmptyStoreState(){const currentTree=makeEmptyTreeState();return{currentTree,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(currentTree.version,graph()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}},getNextTreeStateVersion:getNextTreeStateVersion$1};class RetentionZone{}var Recoil_RetentionZone={RetentionZone,retentionZone:function retentionZone(){return new RetentionZone}};var Recoil_CopyOnWrite={setByAddingToSet:function setByAddingToSet(set,v){const next=new Set(set);return next.add(v),next},setByDeletingFromSet:function setByDeletingFromSet(set,v){const next=new Set(set);return next.delete(v),next},mapBySettingInMap:function mapBySettingInMap(map,k,v){const next=new Map(map);return next.set(k,v),next},mapByUpdatingInMap:function mapByUpdatingInMap(map,k,updater){const next=new Map(map);return next.set(k,updater(next.get(k))),next},mapByDeletingFromMap:function mapByDeletingFromMap(map,k){const next=new Map(map);return next.delete(k),next},mapByDeletingMultipleFromMap:function mapByDeletingMultipleFromMap(map,ks){const next=new Map(map);return ks.forEach((k=>next.delete(k))),next}};var Recoil_filterIterable=function*filterIterable(iterable,predicate){let index=0;for(const value of iterable)predicate(value,index++)&&(yield value)};var Recoil_lazyProxy=function lazyProxy(base,factories){return new Proxy(base,{get:(target,prop)=>(!(prop in target)&&prop in factories&&(target[prop]=factories[prop]()),target[prop]),ownKeys:target=>Object.keys(target)})};const{getNode:getNode$1,getNodeMaybe:getNodeMaybe$1,recoilValuesForKeys:recoilValuesForKeys$1}=Recoil_Node,{RetentionZone:RetentionZone$1}=Recoil_RetentionZone,{setByAddingToSet:setByAddingToSet$1}=Recoil_CopyOnWrite,emptySet=Object.freeze(new Set);class ReadOnlyRecoilValueError extends Error{}function initializeNodeIfNewToStore(store,treeState,key,trigger){const storeState=store.getState();if(storeState.nodeCleanupFunctions.has(key))return;const node=getNode$1(key),retentionCleanup=function initializeRetentionForNode(store,nodeKey,retainedBy){if(!Recoil_gkx("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone}=store.getState().retention;function addToZone(zone){let set=nodesRetainedByZone.get(zone);set||nodesRetainedByZone.set(zone,set=new Set),set.add(nodeKey)}if(retainedBy instanceof RetentionZone$1)addToZone(retainedBy);else if(Array.isArray(retainedBy))for(const zone of retainedBy)addToZone(zone);return()=>{if(!Recoil_gkx("recoil_memory_managament_2020"))return;const{retention}=store.getState();function deleteFromZone(zone){const set=retention.nodesRetainedByZone.get(zone);null==set||set.delete(nodeKey),set&&0===set.size&&retention.nodesRetainedByZone.delete(zone)}if(retainedBy instanceof RetentionZone$1)deleteFromZone(retainedBy);else if(Array.isArray(retainedBy))for(const zone of retainedBy)deleteFromZone(zone)}}(store,key,node.retainedBy),nodeCleanup=node.init(store,treeState,trigger);storeState.nodeCleanupFunctions.set(key,(()=>{nodeCleanup(),retentionCleanup()}))}function peekNodeLoadable(store,state,key){return getNode$1(key).peek(store,state)}function getDownstreamNodes(store,state,keys){const visitedNodes=new Set,visitingNodes=Array.from(keys),graph=store.getGraph(state.version);for(let key=visitingNodes.pop();key;key=visitingNodes.pop()){var _graph$nodeToNodeSubs;visitedNodes.add(key);const subscribedNodes=null!==(_graph$nodeToNodeSubs=graph.nodeToNodeSubscriptions.get(key))&&void 0!==_graph$nodeToNodeSubs?_graph$nodeToNodeSubs:emptySet;for(const downstreamNode of subscribedNodes)visitedNodes.has(downstreamNode)||visitingNodes.push(downstreamNode)}return visitedNodes}var Recoil_FunctionalCore={getNodeLoadable:function getNodeLoadable(store,state,key){return initializeNodeIfNewToStore(store,state,key,"get"),getNode$1(key).get(store,state)},peekNodeLoadable,setNodeValue:function setNodeValue(store,state,key,newValue){const node=getNode$1(key);if(null==node.set)throw new ReadOnlyRecoilValueError(`Attempt to set read-only RecoilValue: ${key}`);const set=node.set;return initializeNodeIfNewToStore(store,state,key,"set"),set(store,state,newValue)},initializeNode:function initializeNode(store,key,trigger){initializeNodeIfNewToStore(store,store.getState().currentTree,key,trigger)},cleanUpNode:function cleanUpNode(store,key){var _state$nodeCleanupFun;const state=store.getState();null===(_state$nodeCleanupFun=state.nodeCleanupFunctions.get(key))||void 0===_state$nodeCleanupFun||_state$nodeCleanupFun(),state.nodeCleanupFunctions.delete(key)},setUnvalidatedAtomValue_DEPRECATED:function setUnvalidatedAtomValue_DEPRECATED(state,key,newValue){var _node$invalidate;const node=getNodeMaybe$1(key);return null==node||null===(_node$invalidate=node.invalidate)||void 0===_node$invalidate||_node$invalidate.call(node,state),{...state,atomValues:state.atomValues.clone().delete(key),nonvalidatedAtoms:state.nonvalidatedAtoms.clone().set(key,newValue),dirtyAtoms:setByAddingToSet$1(state.dirtyAtoms,key)}},peekNodeInfo:function peekNodeInfo(store,state,key){const storeState=store.getState(),graph=store.getGraph(state.version),type=getNode$1(key).nodeType;return Recoil_lazyProxy({type},{loadable:()=>peekNodeLoadable(store,state,key),isActive:()=>storeState.knownAtoms.has(key)||storeState.knownSelectors.has(key),isSet:()=>"selector"!==type&&state.atomValues.has(key),isModified:()=>state.dirtyAtoms.has(key),deps:()=>{var _graph$nodeDeps$get;return recoilValuesForKeys$1(null!==(_graph$nodeDeps$get=graph.nodeDeps.get(key))&&void 0!==_graph$nodeDeps$get?_graph$nodeDeps$get:[])},subscribers:()=>{var _storeState$nodeToCom,_storeState$nodeToCom2;return{nodes:recoilValuesForKeys$1(Recoil_filterIterable(getDownstreamNodes(store,state,new Set([key])),(nodeKey=>nodeKey!==key))),components:Recoil_mapIterable(null!==(_storeState$nodeToCom=null===(_storeState$nodeToCom2=storeState.nodeToComponentSubscriptions.get(key))||void 0===_storeState$nodeToCom2?void 0:_storeState$nodeToCom2.values())&&void 0!==_storeState$nodeToCom?_storeState$nodeToCom:[],(([name])=>({name})))}}})},getDownstreamNodes};let _invalidateMemoizedSnapshot=null;var Recoil_SnapshotCache={setInvalidateMemoizedSnapshot:function setInvalidateMemoizedSnapshot(invalidate){_invalidateMemoizedSnapshot=invalidate},invalidateMemoizedSnapshot:function invalidateMemoizedSnapshot(){var _invalidateMemoizedSn;null===(_invalidateMemoizedSn=_invalidateMemoizedSnapshot)||void 0===_invalidateMemoizedSn||_invalidateMemoizedSn()}};const{getDownstreamNodes:getDownstreamNodes$1,getNodeLoadable:getNodeLoadable$1,setNodeValue:setNodeValue$1}=Recoil_FunctionalCore,{getNextComponentID:getNextComponentID$1}=Recoil_Keys,{getNode:getNode$2,getNodeMaybe:getNodeMaybe$2}=Recoil_Node,{DefaultValue:DefaultValue$1}=Recoil_Node,{reactMode:reactMode$1}=Recoil_ReactMode,{AbstractRecoilValue:AbstractRecoilValue$1,RecoilState:RecoilState$1,RecoilValueReadOnly:RecoilValueReadOnly$1,isRecoilValue:isRecoilValue$1}=Recoil_RecoilValue$1,{invalidateMemoizedSnapshot:invalidateMemoizedSnapshot$1}=Recoil_SnapshotCache;function applyAction(store,state,action){if("set"===action.type){const{recoilValue,valueOrUpdater}=action,newValue=function valueFromValueOrUpdater(store,state,{key},valueOrUpdater){if("function"==typeof valueOrUpdater){const current=getNodeLoadable$1(store,state,key);if("loading"===current.state){const msg=`Tried to set atom or selector "${key}" using an updater function while the current state is pending, this is not currently supported.`;throw Recoil_recoverableViolation(msg),Recoil_err(msg)}if("hasError"===current.state)throw current.contents;return valueOrUpdater(current.contents)}return valueOrUpdater}(store,state,recoilValue,valueOrUpdater),writes=setNodeValue$1(store,state,recoilValue.key,newValue);for(const[key,loadable]of writes.entries())writeLoadableToTreeState(state,key,loadable)}else if("setLoadable"===action.type){const{recoilValue:{key},loadable}=action;writeLoadableToTreeState(state,key,loadable)}else if("markModified"===action.type){const{recoilValue:{key}}=action;state.dirtyAtoms.add(key)}else if("setUnvalidated"===action.type){var _node$invalidate;const{recoilValue:{key},unvalidatedValue}=action,node=getNodeMaybe$2(key);null==node||null===(_node$invalidate=node.invalidate)||void 0===_node$invalidate||_node$invalidate.call(node,state),state.atomValues.delete(key),state.nonvalidatedAtoms.set(key,unvalidatedValue),state.dirtyAtoms.add(key)}else Recoil_recoverableViolation(`Unknown action ${action.type}`)}function writeLoadableToTreeState(state,key,loadable){"hasValue"===loadable.state&&loadable.contents instanceof DefaultValue$1?state.atomValues.delete(key):state.atomValues.set(key,loadable),state.dirtyAtoms.add(key),state.nonvalidatedAtoms.delete(key)}function applyActionsToStore(store,actions){store.replaceState((state=>{const newState=copyTreeState(state);for(const action of actions)applyAction(store,newState,action);return invalidateDownstreams(store,newState),invalidateMemoizedSnapshot$1(),newState}))}function queueOrPerformStateUpdate(store,action){if(batchStack.length){const actionsByStore=batchStack[batchStack.length-1];let actions=actionsByStore.get(store);actions||actionsByStore.set(store,actions=[]),actions.push(action)}else applyActionsToStore(store,[action])}const batchStack=[];function copyTreeState(state){return{...state,atomValues:state.atomValues.clone(),nonvalidatedAtoms:state.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(state.dirtyAtoms)}}function invalidateDownstreams(store,state){const downstreams=getDownstreamNodes$1(store,state,state.dirtyAtoms);for(const key of downstreams){var _getNodeMaybe,_getNodeMaybe$invalid;null===(_getNodeMaybe=getNodeMaybe$2(key))||void 0===_getNodeMaybe||null===(_getNodeMaybe$invalid=_getNodeMaybe.invalidate)||void 0===_getNodeMaybe$invalid||_getNodeMaybe$invalid.call(_getNodeMaybe,state)}}function setRecoilValue(store,recoilValue,valueOrUpdater){queueOrPerformStateUpdate(store,{type:"set",recoilValue,valueOrUpdater})}var Recoil_RecoilValueInterface={RecoilValueReadOnly:RecoilValueReadOnly$1,AbstractRecoilValue:AbstractRecoilValue$1,RecoilState:RecoilState$1,getRecoilValueAsLoadable:function getRecoilValueAsLoadable(store,{key},treeState=store.getState().currentTree){var _storeState$nextTree,_storeState$previousT;const storeState=store.getState();treeState.version!==storeState.currentTree.version&&treeState.version!==(null===(_storeState$nextTree=storeState.nextTree)||void 0===_storeState$nextTree?void 0:_storeState$nextTree.version)&&treeState.version!==(null===(_storeState$previousT=storeState.previousTree)||void 0===_storeState$previousT?void 0:_storeState$previousT.version)&&Recoil_recoverableViolation("Tried to read from a discarded tree");const loadable=getNodeLoadable$1(store,treeState,key);return"loading"===loadable.state&&loadable.contents.catch((()=>{})),loadable},setRecoilValue,setRecoilValueLoadable:function setRecoilValueLoadable(store,recoilValue,loadable){if(loadable instanceof DefaultValue$1)return setRecoilValue(store,recoilValue,loadable);queueOrPerformStateUpdate(store,{type:"setLoadable",recoilValue,loadable})},markRecoilValueModified:function markRecoilValueModified(store,recoilValue){queueOrPerformStateUpdate(store,{type:"markModified",recoilValue})},setUnvalidatedRecoilValue:function setUnvalidatedRecoilValue(store,recoilValue,unvalidatedValue){queueOrPerformStateUpdate(store,{type:"setUnvalidated",recoilValue,unvalidatedValue})},subscribeToRecoilValue:function subscribeToRecoilValue(store,{key},callback,componentDebugName=null){const subID=getNextComponentID$1(),storeState=store.getState();storeState.nodeToComponentSubscriptions.has(key)||storeState.nodeToComponentSubscriptions.set(key,new Map),Recoil_nullthrows(storeState.nodeToComponentSubscriptions.get(key)).set(subID,[null!=componentDebugName?componentDebugName:"<not captured>",callback]);const mode=reactMode$1();if(mode.early&&("LEGACY"===mode.mode||"MUTABLE_SOURCE"===mode.mode)){const nextTree=store.getState().nextTree;nextTree&&nextTree.dirtyAtoms.has(key)&&callback(nextTree)}return{release:()=>{const releaseStoreState=store.getState(),subs=releaseStoreState.nodeToComponentSubscriptions.get(key);void 0!==subs&&subs.has(subID)?(subs.delete(subID),0===subs.size&&releaseStoreState.nodeToComponentSubscriptions.delete(key)):Recoil_recoverableViolation(`Subscription missing at release time for atom ${key}. This is a bug in Recoil.`)}}},isRecoilValue:isRecoilValue$1,applyAtomValueWrites:function applyAtomValueWrites(atomValues,writes){const result=atomValues.clone();return writes.forEach(((v,k)=>{"hasValue"===v.state&&v.contents instanceof DefaultValue$1?result.delete(k):result.set(k,v)})),result},batchStart:function batchStart(){const actionsByStore=new Map;return batchStack.push(actionsByStore),()=>{for(const[store,actions]of actionsByStore)applyActionsToStore(store,actions);batchStack.pop()!==actionsByStore&&Recoil_recoverableViolation("Incorrect order of batch popping")}},writeLoadableToTreeState,invalidateDownstreams,copyTreeState,refreshRecoilValue:function refreshRecoilValue(store,recoilValue){var _node$clearCache;const{currentTree}=store.getState(),node=getNode$2(recoilValue.key);null===(_node$clearCache=node.clearCache)||void 0===_node$clearCache||_node$clearCache.call(node,store,currentTree)}};var Recoil_someSet=function someSet(set,callback,context){const iterator=set.entries();let current=iterator.next();for(;!current.done;){const entry=current.value;if(callback.call(context,entry[1],entry[0],set))return!0;current=iterator.next()}return!1};const{cleanUpNode:cleanUpNode$1}=Recoil_FunctionalCore,{deleteNodeConfigIfPossible:deleteNodeConfigIfPossible$1,getNode:getNode$3}=Recoil_Node,{RetentionZone:RetentionZone$2}=Recoil_RetentionZone,emptySet$1=new Set;function releaseRetainablesNowOnCurrentTree(store,retainables){const storeState=store.getState(),treeState=storeState.currentTree;if(storeState.nextTree)return void Recoil_recoverableViolation("releaseNodesNowOnCurrentTree should only be called at the end of a batch");const nodes=new Set;for(const r of retainables)if(r instanceof RetentionZone$2)for(const n of nodesRetainedByZone(storeState,r))nodes.add(n);else nodes.add(r);const releasableNodes=function findReleasableNodes(store,searchFromNodes){const storeState=store.getState(),treeState=storeState.currentTree,graph=store.getGraph(treeState.version),releasableNodes=new Set,nonReleasableNodes=new Set;return findReleasableNodesInner(searchFromNodes),releasableNodes;function findReleasableNodesInner(searchFromNodes){const releasableNodesFoundThisIteration=new Set,downstreams=function getDownstreamNodesInTopologicalOrder(store,treeState,nodes,doNotDescendInto1,doNotDescendInto2){const graph=store.getGraph(treeState.version),answer=[],visited=new Set;for(;nodes.size>0;)visit(Recoil_nullthrows(nodes.values().next().value));return answer;function visit(node){if(doNotDescendInto1.has(node)||doNotDescendInto2.has(node))return void nodes.delete(node);if(visited.has(node))return;const children=graph.nodeToNodeSubscriptions.get(node);if(children)for(const child of children)visit(child);visited.add(node),nodes.delete(node),answer.push(node)}}(store,treeState,searchFromNodes,releasableNodes,nonReleasableNodes);for(const node of downstreams){var _storeState$retention;if("recoilRoot"===getNode$3(node).retainedBy){nonReleasableNodes.add(node);continue}if((null!==(_storeState$retention=storeState.retention.referenceCounts.get(node))&&void 0!==_storeState$retention?_storeState$retention:0)>0){nonReleasableNodes.add(node);continue}if(zonesThatCouldRetainNode(node).some((z=>storeState.retention.referenceCounts.get(z)))){nonReleasableNodes.add(node);continue}const nodeChildren=graph.nodeToNodeSubscriptions.get(node);nodeChildren&&Recoil_someSet(nodeChildren,(child=>nonReleasableNodes.has(child)))?nonReleasableNodes.add(node):(releasableNodes.add(node),releasableNodesFoundThisIteration.add(node))}const parents=new Set;for(const node of releasableNodesFoundThisIteration)for(const parent of null!==(_graph$nodeDeps$get=graph.nodeDeps.get(node))&&void 0!==_graph$nodeDeps$get?_graph$nodeDeps$get:emptySet$1){var _graph$nodeDeps$get;releasableNodes.has(parent)||parents.add(parent)}parents.size&&findReleasableNodesInner(parents)}}(store,nodes);for(const node of releasableNodes)releaseNode(store,treeState,node)}function releaseNode(store,treeState,node){if(!Recoil_gkx("recoil_memory_managament_2020"))return;cleanUpNode$1(store,node);const storeState=store.getState();storeState.knownAtoms.delete(node),storeState.knownSelectors.delete(node),storeState.nodeTransactionSubscriptions.delete(node),storeState.retention.referenceCounts.delete(node);const zones=zonesThatCouldRetainNode(node);for(const zone of zones){var _storeState$retention2;null===(_storeState$retention2=storeState.retention.nodesRetainedByZone.get(zone))||void 0===_storeState$retention2||_storeState$retention2.delete(node)}treeState.atomValues.delete(node),treeState.dirtyAtoms.delete(node),treeState.nonvalidatedAtoms.delete(node);const graph=storeState.graphsByVersion.get(treeState.version);if(graph){const deps=graph.nodeDeps.get(node);if(void 0!==deps){graph.nodeDeps.delete(node);for(const dep of deps){var _graph$nodeToNodeSubs;null===(_graph$nodeToNodeSubs=graph.nodeToNodeSubscriptions.get(dep))||void 0===_graph$nodeToNodeSubs||_graph$nodeToNodeSubs.delete(node)}}graph.nodeToNodeSubscriptions.delete(node)}deleteNodeConfigIfPossible$1(node)}function nodesRetainedByZone(storeState,zone){var _storeState$retention3;return null!==(_storeState$retention3=storeState.retention.nodesRetainedByZone.get(zone))&&void 0!==_storeState$retention3?_storeState$retention3:emptySet$1}function zonesThatCouldRetainNode(node){const retainedBy=getNode$3(node).retainedBy;return void 0===retainedBy||"components"===retainedBy||"recoilRoot"===retainedBy?[]:retainedBy instanceof RetentionZone$2?[retainedBy]:retainedBy}function updateRetainCountToZero(store,retainable){if(!Recoil_gkx("recoil_memory_managament_2020"))return;store.getState().retention.referenceCounts.delete(retainable),function scheduleOrPerformPossibleReleaseOfRetainable(store,retainable){const state=store.getState();state.nextTree?state.retention.retainablesToCheckForRelease.add(retainable):releaseRetainablesNowOnCurrentTree(store,new Set([retainable]))}(store,retainable)}var Recoil_Retention={SUSPENSE_TIMEOUT_MS:12e4,updateRetainCount:function updateRetainCount(store,retainable,delta){var _map$get;if(!Recoil_gkx("recoil_memory_managament_2020"))return;const map=store.getState().retention.referenceCounts,newCount=(null!==(_map$get=map.get(retainable))&&void 0!==_map$get?_map$get:0)+delta;0===newCount?updateRetainCountToZero(store,retainable):map.set(retainable,newCount)},updateRetainCountToZero,releaseScheduledRetainablesNow:function releaseScheduledRetainablesNow(store){if(!Recoil_gkx("recoil_memory_managament_2020"))return;const state=store.getState();releaseRetainablesNowOnCurrentTree(store,state.retention.retainablesToCheckForRelease),state.retention.retainablesToCheckForRelease.clear()},retainedByOptionWithDefault:function retainedByOptionWithDefault(r){return void 0===r?"recoilRoot":r}};const{unstable_batchedUpdates}=react_dom__WEBPACK_IMPORTED_MODULE_1__;var ReactBatchedUpdates={unstable_batchedUpdates};const{unstable_batchedUpdates:unstable_batchedUpdates$1}=ReactBatchedUpdates;var Recoil_ReactBatchedUpdates={unstable_batchedUpdates:unstable_batchedUpdates$1};const{batchStart:batchStart$1}=Recoil_RecoilValueInterface,{unstable_batchedUpdates:unstable_batchedUpdates$2}=Recoil_ReactBatchedUpdates;let batcher=unstable_batchedUpdates$2||(batchFn=>batchFn());var Recoil_Batching={getBatcher:()=>batcher,setBatcher:newBatcher=>{batcher=newBatcher},batchUpdates:callback=>{batcher((()=>{let batchEnd=()=>{};try{batchEnd=batchStart$1(),callback()}finally{batchEnd()}}))}};var Recoil_concatIterables=function*concatIterables(iters){for(const iter of iters)for(const val of iter)yield val};const isSSR="undefined"==typeof Window||"undefined"==typeof window,isReactNative="undefined"!=typeof navigator&&"ReactNative"===navigator.product;var Recoil_Environment={isSSR,isReactNative,isWindow:value=>!isSSR&&(value===window||value instanceof Window)};var Recoil_Memoize={memoizeWithArgsHash:function memoizeWithArgsHash(fn,hashFunction){let cache;return(...args)=>{cache||(cache={});const key=hashFunction(...args);return Object.hasOwnProperty.call(cache,key)||(cache[key]=fn(...args)),cache[key]}},memoizeOneWithArgsHash:function memoizeOneWithArgsHash(fn,hashFunction){let lastKey,lastResult;return(...args)=>{const key=hashFunction(...args);return lastKey===key||(lastKey=key,lastResult=fn(...args)),lastResult}},memoizeOneWithArgsHashAndInvalidation:function memoizeOneWithArgsHashAndInvalidation(fn,hashFunction){let lastKey,lastResult;return[(...args)=>{const key=hashFunction(...args);return lastKey===key||(lastKey=key,lastResult=fn(...args)),lastResult},()=>{lastKey=null}]}};const{batchUpdates:batchUpdates$1}=Recoil_Batching,{initializeNode:initializeNode$1,peekNodeInfo:peekNodeInfo$1}=Recoil_FunctionalCore,{graph:graph$1}=Recoil_Graph,{getNextStoreID:getNextStoreID$1}=Recoil_Keys,{DEFAULT_VALUE:DEFAULT_VALUE$1,recoilValues:recoilValues$1,recoilValuesForKeys:recoilValuesForKeys$2}=Recoil_Node,{AbstractRecoilValue:AbstractRecoilValue$2,getRecoilValueAsLoadable:getRecoilValueAsLoadable$1,setRecoilValue:setRecoilValue$1,setUnvalidatedRecoilValue:setUnvalidatedRecoilValue$1}=Recoil_RecoilValueInterface,{updateRetainCount:updateRetainCount$1}=Recoil_Retention,{setInvalidateMemoizedSnapshot:setInvalidateMemoizedSnapshot$1}=Recoil_SnapshotCache,{getNextTreeStateVersion:getNextTreeStateVersion$2,makeEmptyStoreState:makeEmptyStoreState$1}=Recoil_State,{isSSR:isSSR$1}=Recoil_Environment,{memoizeOneWithArgsHashAndInvalidation:memoizeOneWithArgsHashAndInvalidation$1}=Recoil_Memoize;class Snapshot{constructor(storeState,parentStoreID){_defineProperty(this,"_store",void 0),_defineProperty(this,"_refCount",1),_defineProperty(this,"getLoadable",(recoilValue=>(this.checkRefCount_INTERNAL(),getRecoilValueAsLoadable$1(this._store,recoilValue)))),_defineProperty(this,"getPromise",(recoilValue=>(this.checkRefCount_INTERNAL(),this.getLoadable(recoilValue).toPromise()))),_defineProperty(this,"getNodes_UNSTABLE",(opt=>{if(this.checkRefCount_INTERNAL(),!0===(null==opt?void 0:opt.isModified)){if(!1===(null==opt?void 0:opt.isInitialized))return[];const state=this._store.getState().currentTree;return recoilValuesForKeys$2(state.dirtyAtoms)}const knownAtoms=this._store.getState().knownAtoms,knownSelectors=this._store.getState().knownSelectors;return null==(null==opt?void 0:opt.isInitialized)?recoilValues$1.values():!0===opt.isInitialized?recoilValuesForKeys$2(Recoil_concatIterables([knownAtoms,knownSelectors])):Recoil_filterIterable(recoilValues$1.values(),(({key})=>!knownAtoms.has(key)&&!knownSelectors.has(key)))})),_defineProperty(this,"getInfo_UNSTABLE",(({key})=>(this.checkRefCount_INTERNAL(),peekNodeInfo$1(this._store,this._store.getState().currentTree,key)))),_defineProperty(this,"map",(mapper=>{this.checkRefCount_INTERNAL();const mutableSnapshot=new MutableSnapshot(this,batchUpdates$1);return mapper(mutableSnapshot),mutableSnapshot})),_defineProperty(this,"asyncMap",(async mapper=>{this.checkRefCount_INTERNAL();const mutableSnapshot=new MutableSnapshot(this,batchUpdates$1);return mutableSnapshot.retain(),await mapper(mutableSnapshot),mutableSnapshot.autoRelease_INTERNAL(),mutableSnapshot})),this._store={storeID:getNextStoreID$1(),parentStoreID,getState:()=>storeState,replaceState:replacer=>{storeState.currentTree=replacer(storeState.currentTree)},getGraph:version=>{const graphs=storeState.graphsByVersion;if(graphs.has(version))return Recoil_nullthrows(graphs.get(version));const newGraph=graph$1();return graphs.set(version,newGraph),newGraph},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw Recoil_err("Cannot subscribe to Snapshots")}};for(const nodeKey of this._store.getState().knownAtoms)initializeNode$1(this._store,nodeKey,"get"),updateRetainCount$1(this._store,nodeKey,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0&&Recoil_recoverableViolation("Attempt to retain() Snapshot that was already released."),this._refCount++;let released=!1;return()=>{released||(released=!0,this._release())}}autoRelease_INTERNAL(){isSSR$1||window.setTimeout((()=>this._release()),10)}_release(){if(this._refCount--,0===this._refCount){if(this._store.getState().nodeCleanupFunctions.forEach((cleanup=>cleanup())),this._store.getState().nodeCleanupFunctions.clear(),!Recoil_gkx("recoil_memory_managament_2020"))return}else this._refCount}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){Recoil_gkx("recoil_memory_managament_2020")&&this._refCount}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}getStoreID(){return this.checkRefCount_INTERNAL(),this._store.storeID}}function cloneStoreState(store,treeState,bumpVersion=!1){const storeState=store.getState(),version=bumpVersion?getNextTreeStateVersion$2():treeState.version;return{currentTree:{version:bumpVersion?version:treeState.version,stateID:bumpVersion?version:treeState.stateID,transactionMetadata:{...treeState.transactionMetadata},dirtyAtoms:new Set(treeState.dirtyAtoms),atomValues:treeState.atomValues.clone(),nonvalidatedAtoms:treeState.nonvalidatedAtoms.clone()},commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(storeState.knownAtoms),knownSelectors:new Set(storeState.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(version,store.getGraph(treeState.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(Recoil_mapIterable(storeState.nodeCleanupFunctions.entries(),(([key])=>[key,()=>{}])))}}const[memoizedCloneSnapshot,invalidateMemoizedSnapshot$2]=memoizeOneWithArgsHashAndInvalidation$1(((store,version)=>{var _storeState$nextTree;const storeState=store.getState(),treeState="latest"===version?null!==(_storeState$nextTree=storeState.nextTree)&&void 0!==_storeState$nextTree?_storeState$nextTree:storeState.currentTree:Recoil_nullthrows(storeState.previousTree);return new Snapshot(cloneStoreState(store,treeState),store.storeID)}),((store,version)=>{var _store$getState$nextT,_store$getState$previ;return String(version)+String(store.storeID)+String(null===(_store$getState$nextT=store.getState().nextTree)||void 0===_store$getState$nextT?void 0:_store$getState$nextT.version)+String(store.getState().currentTree.version)+String(null===(_store$getState$previ=store.getState().previousTree)||void 0===_store$getState$previ?void 0:_store$getState$previ.version)}));setInvalidateMemoizedSnapshot$1(invalidateMemoizedSnapshot$2);class MutableSnapshot extends Snapshot{constructor(snapshot,batch){super(cloneStoreState(snapshot.getStore_INTERNAL(),snapshot.getStore_INTERNAL().getState().currentTree,!0),snapshot.getStoreID()),_defineProperty(this,"_batch",void 0),_defineProperty(this,"set",((recoilState,newValueOrUpdater)=>{this.checkRefCount_INTERNAL();const store=this.getStore_INTERNAL();this._batch((()=>{updateRetainCount$1(store,recoilState.key,1),setRecoilValue$1(this.getStore_INTERNAL(),recoilState,newValueOrUpdater)}))})),_defineProperty(this,"reset",(recoilState=>{this.checkRefCount_INTERNAL();const store=this.getStore_INTERNAL();this._batch((()=>{updateRetainCount$1(store,recoilState.key,1),setRecoilValue$1(this.getStore_INTERNAL(),recoilState,DEFAULT_VALUE$1)}))})),_defineProperty(this,"setUnvalidatedAtomValues_DEPRECATED",(values=>{this.checkRefCount_INTERNAL();const store=this.getStore_INTERNAL();batchUpdates$1((()=>{for(const[k,v]of values.entries())updateRetainCount$1(store,k,1),setUnvalidatedRecoilValue$1(store,new AbstractRecoilValue$2(k),v)}))})),this._batch=batch}}var Recoil_Snapshot={Snapshot,MutableSnapshot,freshSnapshot:function freshSnapshot(initializeState){const snapshot=new Snapshot(makeEmptyStoreState$1());return null!=initializeState?snapshot.map(initializeState):snapshot},cloneSnapshot:function cloneSnapshot(store,version="latest"){const snapshot=memoizedCloneSnapshot(store,version);return snapshot.isRetained()?snapshot:(invalidateMemoizedSnapshot$2(),memoizedCloneSnapshot(store,version))}},Recoil_Snapshot_1=Recoil_Snapshot.Snapshot,Recoil_Snapshot_2=Recoil_Snapshot.MutableSnapshot,Recoil_Snapshot_3=Recoil_Snapshot.freshSnapshot,Recoil_Snapshot_4=Recoil_Snapshot.cloneSnapshot,Recoil_Snapshot$1=Object.freeze({__proto__:null,Snapshot:Recoil_Snapshot_1,MutableSnapshot:Recoil_Snapshot_2,freshSnapshot:Recoil_Snapshot_3,cloneSnapshot:Recoil_Snapshot_4});var Recoil_unionSets=function unionSets(...sets){const result=new Set;for(const set of sets)for(const value of set)result.add(value);return result};const{useRef}=react__WEBPACK_IMPORTED_MODULE_0__;var Recoil_useRefInitOnce=function useRefInitOnce(initialValue){const ref=useRef(initialValue);return ref.current===initialValue&&"function"==typeof initialValue&&(ref.current=initialValue()),ref};const{getNextTreeStateVersion:getNextTreeStateVersion$3,makeEmptyStoreState:makeEmptyStoreState$2}=Recoil_State,{cleanUpNode:cleanUpNode$2,getDownstreamNodes:getDownstreamNodes$2,initializeNode:initializeNode$2,setNodeValue:setNodeValue$2,setUnvalidatedAtomValue_DEPRECATED:setUnvalidatedAtomValue_DEPRECATED$1}=Recoil_FunctionalCore,{graph:graph$2}=Recoil_Graph,{cloneGraph:cloneGraph$1}=Recoil_Graph,{getNextStoreID:getNextStoreID$2}=Recoil_Keys,{createMutableSource:createMutableSource$1,reactMode:reactMode$2}=Recoil_ReactMode,{applyAtomValueWrites:applyAtomValueWrites$1}=Recoil_RecoilValueInterface,{releaseScheduledRetainablesNow:releaseScheduledRetainablesNow$1}=Recoil_Retention,{freshSnapshot:freshSnapshot$1}=Recoil_Snapshot$1,{useCallback,useContext,useEffect,useMemo,useRef:useRef$1,useState}=react__WEBPACK_IMPORTED_MODULE_0__;function notInAContext(){throw Recoil_err("This component must be used inside a <RecoilRoot> component.")}const defaultStore=Object.freeze({storeID:getNextStoreID$2(),getState:notInAContext,replaceState:notInAContext,getGraph:notInAContext,subscribeToTransactions:notInAContext,addTransactionMetadata:notInAContext});let stateReplacerIsBeingExecuted=!1;function startNextTreeIfNeeded(store){if(stateReplacerIsBeingExecuted)throw Recoil_err("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const storeState=store.getState();if(null===storeState.nextTree){Recoil_gkx("recoil_memory_managament_2020")&&Recoil_gkx("recoil_release_on_cascading_update_killswitch_2021")&&storeState.commitDepth>0&&releaseScheduledRetainablesNow$1(store);const version=storeState.currentTree.version,nextVersion=getNextTreeStateVersion$3();storeState.nextTree={...storeState.currentTree,version:nextVersion,stateID:nextVersion,dirtyAtoms:new Set,transactionMetadata:{}},storeState.graphsByVersion.set(nextVersion,cloneGraph$1(Recoil_nullthrows(storeState.graphsByVersion.get(version))))}}const AppContext=react__WEBPACK_IMPORTED_MODULE_0__.createContext({current:defaultStore}),useStoreRef=()=>useContext(AppContext),MutableSourceContext=react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);function notifyComponents(store,storeState,treeState){const dependentNodes=getDownstreamNodes$2(store,treeState,treeState.dirtyAtoms);for(const key of dependentNodes){const comps=storeState.nodeToComponentSubscriptions.get(key);if(comps)for(const[_subID,[_debugName,callback]]of comps)callback(treeState)}}function sendEndOfBatchNotifications(store){const storeState=store.getState(),treeState=storeState.currentTree,dirtyAtoms=treeState.dirtyAtoms;if(dirtyAtoms.size){for(const[key,subscriptions]of storeState.nodeTransactionSubscriptions)if(dirtyAtoms.has(key))for(const[_,subscription]of subscriptions)subscription(store);for(const[_,subscription]of storeState.transactionSubscriptions)subscription(store);(!reactMode$2().early||storeState.suspendedComponentResolvers.size>0)&&(notifyComponents(store,storeState,treeState),storeState.suspendedComponentResolvers.forEach((cb=>cb())),storeState.suspendedComponentResolvers.clear())}storeState.queuedComponentCallbacks_DEPRECATED.forEach((cb=>cb(treeState))),storeState.queuedComponentCallbacks_DEPRECATED.splice(0,storeState.queuedComponentCallbacks_DEPRECATED.length)}function Batcher({setNotifyBatcherOfChange}){const storeRef=useStoreRef(),[,setState]=useState([]);return setNotifyBatcherOfChange((()=>setState({}))),useEffect((()=>(setNotifyBatcherOfChange((()=>setState({}))),()=>{setNotifyBatcherOfChange((()=>{}))})),[setNotifyBatcherOfChange]),useEffect((()=>{Recoil_Queue.enqueueExecution("Batcher",(()=>{!function endBatch(store){const storeState=store.getState();storeState.commitDepth++;try{const{nextTree}=storeState;if(null==nextTree)return;storeState.previousTree=storeState.currentTree,storeState.currentTree=nextTree,storeState.nextTree=null,sendEndOfBatchNotifications(store),null!=storeState.previousTree?storeState.graphsByVersion.delete(storeState.previousTree.version):Recoil_recoverableViolation("Ended batch with no previous state, which is unexpected","recoil"),storeState.previousTree=null,Recoil_gkx("recoil_memory_managament_2020")&&null==nextTree&&releaseScheduledRetainablesNow$1(store)}finally{storeState.commitDepth--}}(storeRef.current)}))})),null}let nextID=0;function RecoilRoot_INTERNAL({initializeState_DEPRECATED,initializeState,store_INTERNAL:storeProp,children}){let storeStateRef;const getGraph=version=>{const graphs=storeStateRef.current.graphsByVersion;if(graphs.has(version))return Recoil_nullthrows(graphs.get(version));const newGraph=graph$2();return graphs.set(version,newGraph),newGraph},subscribeToTransactions=(callback,key)=>{if(null==key){const{transactionSubscriptions}=storeRef.current.getState(),id=nextID++;return transactionSubscriptions.set(id,callback),{release:()=>{transactionSubscriptions.delete(id)}}}{const{nodeTransactionSubscriptions}=storeRef.current.getState();nodeTransactionSubscriptions.has(key)||nodeTransactionSubscriptions.set(key,new Map);const id=nextID++;return Recoil_nullthrows(nodeTransactionSubscriptions.get(key)).set(id,callback),{release:()=>{const subs=nodeTransactionSubscriptions.get(key);subs&&(subs.delete(id),0===subs.size&&nodeTransactionSubscriptions.delete(key))}}}},addTransactionMetadata=metadata=>{startNextTreeIfNeeded(storeRef.current);for(const k of Object.keys(metadata))Recoil_nullthrows(storeRef.current.getState().nextTree).transactionMetadata[k]=metadata[k]},replaceState=replacer=>{startNextTreeIfNeeded(storeRef.current);const nextTree=Recoil_nullthrows(storeStateRef.current.nextTree);let replaced;try{stateReplacerIsBeingExecuted=!0,replaced=replacer(nextTree)}finally{stateReplacerIsBeingExecuted=!1}replaced!==nextTree&&(storeStateRef.current.nextTree=replaced,reactMode$2().early&&notifyComponents(storeRef.current,storeStateRef.current,replaced),Recoil_nullthrows(notifyBatcherOfChange.current)())},notifyBatcherOfChange=useRef$1(null),setNotifyBatcherOfChange=useCallback((x=>{notifyBatcherOfChange.current=x}),[notifyBatcherOfChange]),storeRef=Recoil_useRefInitOnce((()=>null!=storeProp?storeProp:{storeID:getNextStoreID$2(),getState:()=>storeStateRef.current,replaceState,getGraph,subscribeToTransactions,addTransactionMetadata}));null!=storeProp&&(storeRef.current=storeProp),storeStateRef=Recoil_useRefInitOnce((()=>null!=initializeState_DEPRECATED?function initialStoreState_DEPRECATED(store,initializeState){const initial=makeEmptyStoreState$2();return initializeState({set:(atom,value)=>{const state=initial.currentTree,writes=setNodeValue$2(store,state,atom.key,value),writtenNodes=new Set(writes.keys()),nonvalidatedAtoms=state.nonvalidatedAtoms.clone();for(const n of writtenNodes)nonvalidatedAtoms.delete(n);initial.currentTree={...state,dirtyAtoms:Recoil_unionSets(state.dirtyAtoms,writtenNodes),atomValues:applyAtomValueWrites$1(state.atomValues,writes),nonvalidatedAtoms}},setUnvalidatedAtomValues:atomValues=>{atomValues.forEach(((v,k)=>{initial.currentTree=setUnvalidatedAtomValue_DEPRECATED$1(initial.currentTree,k,v)}))}}),initial}(storeRef.current,initializeState_DEPRECATED):null!=initializeState?function initialStoreState(initializeState){const snapshot=freshSnapshot$1(initializeState),storeState=snapshot.getStore_INTERNAL().getState();return snapshot.retain(),storeState.nodeCleanupFunctions.forEach((cleanup=>cleanup())),storeState.nodeCleanupFunctions.clear(),storeState}(initializeState):makeEmptyStoreState$2()));const mutableSource=useMemo((()=>null==createMutableSource$1?void 0:createMutableSource$1(storeStateRef,(()=>storeStateRef.current.currentTree.version))),[storeStateRef]);return useEffect((()=>{const store=storeRef.current;for(const atomKey of new Set(store.getState().knownAtoms))initializeNode$2(store,atomKey,"get");return()=>{for(const atomKey of store.getState().knownAtoms)cleanUpNode$2(store,atomKey)}}),[storeRef]),react__WEBPACK_IMPORTED_MODULE_0__.createElement(AppContext.Provider,{value:storeRef},react__WEBPACK_IMPORTED_MODULE_0__.createElement(MutableSourceContext.Provider,{value:mutableSource},react__WEBPACK_IMPORTED_MODULE_0__.createElement(Batcher,{setNotifyBatcherOfChange}),children))}var Recoil_RecoilRoot={RecoilRoot:function RecoilRoot(props){const{override,...propsExceptOverride}=props,ancestorStoreRef=useStoreRef();return!1===override&&ancestorStoreRef.current!==defaultStore?props.children:react__WEBPACK_IMPORTED_MODULE_0__.createElement(RecoilRoot_INTERNAL,propsExceptOverride)},useStoreRef,useRecoilMutableSource:function useRecoilMutableSource(){const mutableSource=useContext(MutableSourceContext);return null==mutableSource&&Recoil_expectationViolation("Attempted to use a Recoil hook outside of a <RecoilRoot>. <RecoilRoot> must be an ancestor of any component that uses Recoil hooks."),mutableSource},useRecoilStoreID:function useRecoilStoreID(){return useStoreRef().current.storeID},notifyComponents_FOR_TESTING:notifyComponents,sendEndOfBatchNotifications_FOR_TESTING:sendEndOfBatchNotifications};var Recoil_shallowArrayEqual=function shallowArrayEqual(a,b){if(a===b)return!0;if(a.length!==b.length)return!1;for(let i=0,l=a.length;i<l;i++)if(a[i]!==b[i])return!1;return!0};const{useEffect:useEffect$1,useRef:useRef$2}=react__WEBPACK_IMPORTED_MODULE_0__;var Recoil_usePrevious=function usePrevious(value){const ref=useRef$2();return useEffect$1((()=>{ref.current=value})),ref.current};const{useStoreRef:useStoreRef$1}=Recoil_RecoilRoot,{SUSPENSE_TIMEOUT_MS:SUSPENSE_TIMEOUT_MS$1}=Recoil_Retention,{updateRetainCount:updateRetainCount$2}=Recoil_Retention,{RetentionZone:RetentionZone$3}=Recoil_RetentionZone,{useEffect:useEffect$2,useRef:useRef$3}=react__WEBPACK_IMPORTED_MODULE_0__,{isSSR:isSSR$2}=Recoil_Environment;var Recoil_useRetain=function useRetain(toRetain){if(Recoil_gkx("recoil_memory_managament_2020"))return function useRetain_ACTUAL(toRetain){const array=Array.isArray(toRetain)?toRetain:[toRetain],retainables=array.map((a=>a instanceof RetentionZone$3?a:a.key)),storeRef=useStoreRef$1();useEffect$2((()=>{if(!Recoil_gkx("recoil_memory_managament_2020"))return;const store=storeRef.current;if(timeoutID.current&&!isSSR$2)window.clearTimeout(timeoutID.current),timeoutID.current=null;else for(const r of retainables)updateRetainCount$2(store,r,1);return()=>{for(const r of retainables)updateRetainCount$2(store,r,-1)}}),[storeRef,...retainables]);const timeoutID=useRef$3(),previousRetainables=Recoil_usePrevious(retainables);if(!(isSSR$2||void 0!==previousRetainables&&Recoil_shallowArrayEqual(previousRetainables,retainables))){const store=storeRef.current;for(const r of retainables)updateRetainCount$2(store,r,1);if(previousRetainables)for(const r of previousRetainables)updateRetainCount$2(store,r,-1);timeoutID.current&&window.clearTimeout(timeoutID.current),timeoutID.current=window.setTimeout((()=>{timeoutID.current=null;for(const r of retainables)updateRetainCount$2(store,r,-1)}),SUSPENSE_TIMEOUT_MS$1)}}(toRetain)};var Recoil_useComponentName=function useComponentName(){return"<component name not available>"};const{batchUpdates:batchUpdates$2}=Recoil_Batching,{DEFAULT_VALUE:DEFAULT_VALUE$2}=Recoil_Node,{currentRendererSupportsUseSyncExternalStore:currentRendererSupportsUseSyncExternalStore$1,reactMode:reactMode$3,useMutableSource:useMutableSource$1,useSyncExternalStore:useSyncExternalStore$1}=Recoil_ReactMode,{useRecoilMutableSource:useRecoilMutableSource$1,useStoreRef:useStoreRef$2}=Recoil_RecoilRoot,{isRecoilValue:isRecoilValue$2}=Recoil_RecoilValue$1,{AbstractRecoilValue:AbstractRecoilValue$3,getRecoilValueAsLoadable:getRecoilValueAsLoadable$2,setRecoilValue:setRecoilValue$2,setUnvalidatedRecoilValue:setUnvalidatedRecoilValue$2,subscribeToRecoilValue:subscribeToRecoilValue$1}=Recoil_RecoilValueInterface,{useCallback:useCallback$1,useEffect:useEffect$3,useMemo:useMemo$1,useRef:useRef$4,useState:useState$1}=react__WEBPACK_IMPORTED_MODULE_0__,{setByAddingToSet:setByAddingToSet$2}=Recoil_CopyOnWrite,{isSSR:isSSR$3}=Recoil_Environment;function handleLoadable(loadable,recoilValue,storeRef){if("hasValue"===loadable.state)return loadable.contents;if("loading"===loadable.state){throw new Promise((resolve=>{const suspendedComponentResolvers=storeRef.current.getState().suspendedComponentResolvers;suspendedComponentResolvers.add(resolve),isSSR$3&&Recoil_isPromise(loadable.contents)&&loadable.contents.finally((()=>{suspendedComponentResolvers.delete(resolve)}))}))}throw"hasError"===loadable.state?loadable.contents:Recoil_err(`Invalid value of loadable atom "${recoilValue.key}"`)}function useRecoilValueLoadable_SYNC_EXTERNAL_STORE(recoilValue){const storeRef=useStoreRef$2(),componentName=Recoil_useComponentName(),getSnapshot=useCallback$1((()=>{var _storeState$nextTree2;const store=storeRef.current,storeState=store.getState(),treeState=reactMode$3().early&&null!==(_storeState$nextTree2=storeState.nextTree)&&void 0!==_storeState$nextTree2?_storeState$nextTree2:storeState.currentTree;return{loadable:getRecoilValueAsLoadable$2(store,recoilValue,treeState),key:recoilValue.key}}),[storeRef,recoilValue]),memoizePreviousSnapshot=useCallback$1((getState=>{let prevState;return()=>{var _prevState,_prevState2;const nextState=getState();return null!==(_prevState=prevState)&&void 0!==_prevState&&_prevState.loadable.is(nextState.loadable)&&(null===(_prevState2=prevState)||void 0===_prevState2?void 0:_prevState2.key)===nextState.key?prevState:(prevState=nextState,nextState)}}),[]),getMemoizedSnapshot=useMemo$1((()=>memoizePreviousSnapshot(getSnapshot)),[getSnapshot,memoizePreviousSnapshot]),subscribe=useCallback$1((notify=>{const store=storeRef.current;return subscribeToRecoilValue$1(store,recoilValue,notify,componentName).release}),[storeRef,recoilValue,componentName]);return useSyncExternalStore$1(subscribe,getMemoizedSnapshot,getMemoizedSnapshot).loadable}function useRecoilValueLoadable_MUTABLE_SOURCE(recoilValue){const storeRef=useStoreRef$2(),getLoadable=useCallback$1((()=>{var _storeState$nextTree3;const store=storeRef.current,storeState=store.getState(),treeState=reactMode$3().early&&null!==(_storeState$nextTree3=storeState.nextTree)&&void 0!==_storeState$nextTree3?_storeState$nextTree3:storeState.currentTree;return getRecoilValueAsLoadable$2(store,recoilValue,treeState)}),[storeRef,recoilValue]),getLoadableWithTesting=useCallback$1((()=>getLoadable()),[getLoadable]),componentName=Recoil_useComponentName(),subscribe=useCallback$1(((_storeState,notify)=>{const store=storeRef.current;return subscribeToRecoilValue$1(store,recoilValue,(()=>{if(!Recoil_gkx("recoil_suppress_rerender_in_callback"))return notify();const newLoadable=getLoadable();prevLoadableRef.current.is(newLoadable)||notify(),prevLoadableRef.current=newLoadable}),componentName).release}),[storeRef,recoilValue,componentName,getLoadable]),source=useRecoilMutableSource$1();if(null==source)throw Recoil_err("Recoil hooks must be used in components contained within a <RecoilRoot> component.");const loadable=useMutableSource$1(source,getLoadableWithTesting,subscribe),prevLoadableRef=useRef$4(loadable);return useEffect$3((()=>{prevLoadableRef.current=loadable})),loadable}function useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue){const storeRef=useStoreRef$2(),componentName=Recoil_useComponentName(),getLoadable=useCallback$1((()=>{var _storeState$nextTree4;const store=storeRef.current,storeState=store.getState(),treeState=reactMode$3().early&&null!==(_storeState$nextTree4=storeState.nextTree)&&void 0!==_storeState$nextTree4?_storeState$nextTree4:storeState.currentTree;return getRecoilValueAsLoadable$2(store,recoilValue,treeState)}),[storeRef,recoilValue]),getState=useCallback$1((()=>({loadable:getLoadable(),key:recoilValue.key})),[getLoadable,recoilValue.key]),updateState=useCallback$1((prevState=>{const nextState=getState();return prevState.loadable.is(nextState.loadable)&&prevState.key===nextState.key?prevState:nextState}),[getState]);useEffect$3((()=>{const subscription=subscribeToRecoilValue$1(storeRef.current,recoilValue,(_state=>{setState(updateState)}),componentName);return setState(updateState),subscription.release}),[componentName,recoilValue,storeRef,updateState]);const[state,setState]=useState$1(getState);return state.key!==recoilValue.key?getState().loadable:state.loadable}function useRecoilValueLoadable_LEGACY(recoilValue){const storeRef=useStoreRef$2(),[,forceUpdate]=useState$1([]),componentName=Recoil_useComponentName(),getLoadable=useCallback$1((()=>{var _storeState$nextTree5;const store=storeRef.current,storeState=store.getState(),treeState=reactMode$3().early&&null!==(_storeState$nextTree5=storeState.nextTree)&&void 0!==_storeState$nextTree5?_storeState$nextTree5:storeState.currentTree;return getRecoilValueAsLoadable$2(store,recoilValue,treeState)}),[storeRef,recoilValue]),loadable=getLoadable(),prevLoadableRef=useRef$4(loadable);return useEffect$3((()=>{prevLoadableRef.current=loadable})),useEffect$3((()=>{const store=storeRef.current,storeState=store.getState(),subscription=subscribeToRecoilValue$1(store,recoilValue,(_state=>{var _prevLoadableRef$curr;if(!Recoil_gkx("recoil_suppress_rerender_in_callback"))return forceUpdate([]);const newLoadable=getLoadable();null!==(_prevLoadableRef$curr=prevLoadableRef.current)&&void 0!==_prevLoadableRef$curr&&_prevLoadableRef$curr.is(newLoadable)||forceUpdate(newLoadable),prevLoadableRef.current=newLoadable}),componentName);if(storeState.nextTree)store.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{prevLoadableRef.current=null,forceUpdate([])}));else{var _prevLoadableRef$curr2;if(!Recoil_gkx("recoil_suppress_rerender_in_callback"))return forceUpdate([]);const newLoadable=getLoadable();null!==(_prevLoadableRef$curr2=prevLoadableRef.current)&&void 0!==_prevLoadableRef$curr2&&_prevLoadableRef$curr2.is(newLoadable)||forceUpdate(newLoadable),prevLoadableRef.current=newLoadable}return subscription.release}),[componentName,getLoadable,recoilValue,storeRef]),loadable}function useRecoilValueLoadable(recoilValue){return Recoil_gkx("recoil_memory_managament_2020")&&Recoil_useRetain(recoilValue),{TRANSITION_SUPPORT:useRecoilValueLoadable_TRANSITION_SUPPORT,SYNC_EXTERNAL_STORE:currentRendererSupportsUseSyncExternalStore$1()?useRecoilValueLoadable_SYNC_EXTERNAL_STORE:useRecoilValueLoadable_TRANSITION_SUPPORT,MUTABLE_SOURCE:useRecoilValueLoadable_MUTABLE_SOURCE,LEGACY:useRecoilValueLoadable_LEGACY}[reactMode$3().mode](recoilValue)}function useRecoilValue(recoilValue){const storeRef=useStoreRef$2();return handleLoadable(useRecoilValueLoadable(recoilValue),recoilValue,storeRef)}function useSetRecoilState(recoilState){const storeRef=useStoreRef$2();return useCallback$1((newValueOrUpdater=>{setRecoilValue$2(storeRef.current,recoilState,newValueOrUpdater)}),[storeRef,recoilState])}function useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue){return Recoil_gkx("recoil_memory_managament_2020")&&Recoil_useRetain(recoilValue),useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue)}function useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilValue){const storeRef=useStoreRef$2();return handleLoadable(useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue),recoilValue,storeRef)}var Recoil_Hooks={recoilComponentGetRecoilValueCount_FOR_TESTING:{current:0},useRecoilInterface:function useRecoilInterface_DEPRECATED(){const componentName=Recoil_useComponentName(),storeRef=useStoreRef$2(),[,forceUpdate]=useState$1([]),recoilValuesUsed=useRef$4(new Set);recoilValuesUsed.current=new Set;const previousSubscriptions=useRef$4(new Set),subscriptions=useRef$4(new Map),unsubscribeFrom=useCallback$1((key=>{const sub=subscriptions.current.get(key);sub&&(sub.release(),subscriptions.current.delete(key))}),[subscriptions]),updateState=useCallback$1(((_state,key)=>{subscriptions.current.has(key)&&forceUpdate([])}),[]);return useEffect$3((()=>{const store=storeRef.current;Recoil_differenceSets(recoilValuesUsed.current,previousSubscriptions.current).forEach((key=>{if(subscriptions.current.has(key))return void Recoil_expectationViolation(`Double subscription to RecoilValue "${key}"`);const sub=subscribeToRecoilValue$1(store,new AbstractRecoilValue$3(key),(state=>updateState(state,key)),componentName);subscriptions.current.set(key,sub);store.getState().nextTree?store.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{updateState(store.getState(),key)})):updateState(store.getState(),key)})),Recoil_differenceSets(previousSubscriptions.current,recoilValuesUsed.current).forEach((key=>{unsubscribeFrom(key)})),previousSubscriptions.current=recoilValuesUsed.current})),useEffect$3((()=>{const currentSubscriptions=subscriptions.current;return Recoil_differenceSets(recoilValuesUsed.current,new Set(currentSubscriptions.keys())).forEach((key=>{const sub=subscribeToRecoilValue$1(storeRef.current,new AbstractRecoilValue$3(key),(state=>updateState(state,key)),componentName);currentSubscriptions.set(key,sub)})),()=>currentSubscriptions.forEach(((_,key)=>unsubscribeFrom(key)))}),[componentName,storeRef,unsubscribeFrom,updateState]),useMemo$1((()=>{function useSetRecoilState(recoilState){return newValueOrUpdater=>{setRecoilValue$2(storeRef.current,recoilState,newValueOrUpdater)}}function useRecoilValueLoadable(recoilValue){var _storeState$nextTree;recoilValuesUsed.current.has(recoilValue.key)||(recoilValuesUsed.current=setByAddingToSet$2(recoilValuesUsed.current,recoilValue.key));const storeState=storeRef.current.getState();return getRecoilValueAsLoadable$2(storeRef.current,recoilValue,reactMode$3().early&&null!==(_storeState$nextTree=storeState.nextTree)&&void 0!==_storeState$nextTree?_storeState$nextTree:storeState.currentTree)}function useRecoilValue(recoilValue){return handleLoadable(useRecoilValueLoadable(recoilValue),recoilValue,storeRef)}return{getRecoilValue:useRecoilValue,getRecoilValueLoadable:useRecoilValueLoadable,getRecoilState:function useRecoilState(recoilState){return[useRecoilValue(recoilState),useSetRecoilState(recoilState)]},getRecoilStateLoadable:function useRecoilStateLoadable(recoilState){return[useRecoilValueLoadable(recoilState),useSetRecoilState(recoilState)]},getSetRecoilState:useSetRecoilState,getResetRecoilState:function useResetRecoilState(recoilState){return()=>setRecoilValue$2(storeRef.current,recoilState,DEFAULT_VALUE$2)}}}),[recoilValuesUsed,storeRef])},useRecoilState:function useRecoilState(recoilState){return[useRecoilValue(recoilState),useSetRecoilState(recoilState)]},useRecoilStateLoadable:function useRecoilStateLoadable(recoilState){return[useRecoilValueLoadable(recoilState),useSetRecoilState(recoilState)]},useRecoilValue,useRecoilValueLoadable,useResetRecoilState:function useResetRecoilState(recoilState){const storeRef=useStoreRef$2();return useCallback$1((()=>{setRecoilValue$2(storeRef.current,recoilState,DEFAULT_VALUE$2)}),[storeRef,recoilState])},useSetRecoilState,useSetUnvalidatedAtomValues:function useSetUnvalidatedAtomValues(){const storeRef=useStoreRef$2();return(values,transactionMetadata={})=>{batchUpdates$2((()=>{storeRef.current.addTransactionMetadata(transactionMetadata),values.forEach(((value,key)=>setUnvalidatedRecoilValue$2(storeRef.current,new AbstractRecoilValue$3(key),value)))}))}},useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:function useRecoilState_TRANSITION_SUPPORT_UNSTABLE(recoilState){return[useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilState),useSetRecoilState(recoilState)]}};var Recoil_filterMap=function filterMap(map,callback){const result=new Map;for(const[key,value]of map)callback(value,key)&&result.set(key,value);return result};var Recoil_filterSet=function filterSet(set,callback){const result=new Set;for(const value of set)callback(value)&&result.add(value);return result};var Recoil_mergeMaps=function mergeMaps(...maps){const result=new Map;for(let i=0;i<maps.length;i++){const iterator=maps[i].keys();let nextKey;for(;!(nextKey=iterator.next()).done;)result.set(nextKey.value,maps[i].get(nextKey.value))}return result};const{batchUpdates:batchUpdates$3}=Recoil_Batching,{DEFAULT_VALUE:DEFAULT_VALUE$3,getNode:getNode$4,nodes:nodes$1}=Recoil_Node,{useStoreRef:useStoreRef$3}=Recoil_RecoilRoot,{AbstractRecoilValue:AbstractRecoilValue$4,setRecoilValueLoadable:setRecoilValueLoadable$1}=Recoil_RecoilValueInterface,{SUSPENSE_TIMEOUT_MS:SUSPENSE_TIMEOUT_MS$2}=Recoil_Retention,{cloneSnapshot:cloneSnapshot$1}=Recoil_Snapshot$1,{useCallback:useCallback$2,useEffect:useEffect$4,useRef:useRef$5,useState:useState$2}=react__WEBPACK_IMPORTED_MODULE_0__,{isSSR:isSSR$4}=Recoil_Environment;function useTransactionSubscription(callback){const storeRef=useStoreRef$3();useEffect$4((()=>storeRef.current.subscribeToTransactions(callback).release),[callback,storeRef])}function externallyVisibleAtomValuesInState(state){const atomValues=state.atomValues.toMap(),persistedAtomContentsValues=Recoil_mapMap(Recoil_filterMap(atomValues,((v,k)=>{const persistence=getNode$4(k).persistence_UNSTABLE;return null!=persistence&&"none"!==persistence.type&&"hasValue"===v.state})),(v=>v.contents));return Recoil_mergeMaps(state.nonvalidatedAtoms.toMap(),persistedAtomContentsValues)}function gotoSnapshot(store,snapshot){var _storeState$nextTree;const storeState=store.getState(),prev=null!==(_storeState$nextTree=storeState.nextTree)&&void 0!==_storeState$nextTree?_storeState$nextTree:storeState.currentTree,next=snapshot.getStore_INTERNAL().getState().currentTree;batchUpdates$3((()=>{const keysToUpdate=new Set;for(const keys of[prev.atomValues.keys(),next.atomValues.keys()])for(const key of keys){var _prev$atomValues$get,_next$atomValues$get;(null===(_prev$atomValues$get=prev.atomValues.get(key))||void 0===_prev$atomValues$get?void 0:_prev$atomValues$get.contents)!==(null===(_next$atomValues$get=next.atomValues.get(key))||void 0===_next$atomValues$get?void 0:_next$atomValues$get.contents)&&getNode$4(key).shouldRestoreFromSnapshots&&keysToUpdate.add(key)}keysToUpdate.forEach((key=>{setRecoilValueLoadable$1(store,new AbstractRecoilValue$4(key),next.atomValues.has(key)?Recoil_nullthrows(next.atomValues.get(key)):DEFAULT_VALUE$3)})),store.replaceState((state=>({...state,stateID:snapshot.getID()})))}))}var Recoil_SnapshotHooks={useRecoilSnapshot:function useRecoilSnapshot(){const storeRef=useStoreRef$3(),[snapshot,setSnapshot]=useState$2((()=>cloneSnapshot$1(storeRef.current))),previousSnapshot=Recoil_usePrevious(snapshot),timeoutID=useRef$5(),releaseRef=useRef$5();if(useTransactionSubscription(useCallback$2((store=>setSnapshot(cloneSnapshot$1(store))),[])),useEffect$4((()=>{const release=snapshot.retain();var _releaseRef$current;timeoutID.current&&!isSSR$4&&(window.clearTimeout(timeoutID.current),timeoutID.current=null,null===(_releaseRef$current=releaseRef.current)||void 0===_releaseRef$current||_releaseRef$current.call(releaseRef),releaseRef.current=null);return()=>{window.setTimeout(release,10)}}),[snapshot]),previousSnapshot!==snapshot&&!isSSR$4){var _releaseRef$current2;if(timeoutID.current)window.clearTimeout(timeoutID.current),timeoutID.current=null,null===(_releaseRef$current2=releaseRef.current)||void 0===_releaseRef$current2||_releaseRef$current2.call(releaseRef),releaseRef.current=null;releaseRef.current=snapshot.retain(),timeoutID.current=window.setTimeout((()=>{var _releaseRef$current3;timeoutID.current=null,null===(_releaseRef$current3=releaseRef.current)||void 0===_releaseRef$current3||_releaseRef$current3.call(releaseRef),releaseRef.current=null}),SUSPENSE_TIMEOUT_MS$2)}return snapshot},gotoSnapshot,useGotoRecoilSnapshot:function useGotoRecoilSnapshot(){const storeRef=useStoreRef$3();return useCallback$2((snapshot=>gotoSnapshot(storeRef.current,snapshot)),[storeRef])},useRecoilTransactionObserver:function useRecoilTransactionObserver(callback){useTransactionSubscription(useCallback$2((store=>{const snapshot=cloneSnapshot$1(store,"latest"),previousSnapshot=cloneSnapshot$1(store,"previous");callback({snapshot,previousSnapshot})}),[callback]))},useTransactionObservation_DEPRECATED:function useTransactionObservation_DEPRECATED(callback){useTransactionSubscription(useCallback$2((store=>{let previousTree=store.getState().previousTree;const currentTree=store.getState().currentTree;previousTree||(Recoil_recoverableViolation("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil"),previousTree=store.getState().currentTree);const atomValues=externallyVisibleAtomValuesInState(currentTree),previousAtomValues=externallyVisibleAtomValuesInState(previousTree),atomInfo=Recoil_mapMap(nodes$1,(node=>{var _node$persistence_UNS,_node$persistence_UNS2,_node$persistence_UNS3,_node$persistence_UNS4;return{persistence_UNSTABLE:{type:null!==(_node$persistence_UNS=null===(_node$persistence_UNS2=node.persistence_UNSTABLE)||void 0===_node$persistence_UNS2?void 0:_node$persistence_UNS2.type)&&void 0!==_node$persistence_UNS?_node$persistence_UNS:"none",backButton:null!==(_node$persistence_UNS3=null===(_node$persistence_UNS4=node.persistence_UNSTABLE)||void 0===_node$persistence_UNS4?void 0:_node$persistence_UNS4.backButton)&&void 0!==_node$persistence_UNS3&&_node$persistence_UNS3}}})),modifiedAtoms=Recoil_filterSet(currentTree.dirtyAtoms,(k=>atomValues.has(k)||previousAtomValues.has(k)));callback({atomValues,previousAtomValues,atomInfo,modifiedAtoms,transactionMetadata:{...currentTree.transactionMetadata}})}),[callback]))},useTransactionSubscription_DEPRECATED:useTransactionSubscription};const{peekNodeInfo:peekNodeInfo$2}=Recoil_FunctionalCore,{useStoreRef:useStoreRef$4}=Recoil_RecoilRoot;var Recoil_useGetRecoilValueInfo=function useGetRecoilValueInfo(){const storeRef=useStoreRef$4();return({key})=>peekNodeInfo$2(storeRef.current,storeRef.current.getState().currentTree,key)};const{reactMode:reactMode$4}=Recoil_ReactMode,{RecoilRoot:RecoilRoot$1,useStoreRef:useStoreRef$5}=Recoil_RecoilRoot,{useMemo:useMemo$2}=react__WEBPACK_IMPORTED_MODULE_0__;var Recoil_useRecoilBridgeAcrossReactRoots=function useRecoilBridgeAcrossReactRoots(){"MUTABLE_SOURCE"===reactMode$4().mode&&console.warn("Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.");const store=useStoreRef$5().current;return useMemo$2((()=>function RecoilBridge({children}){return react__WEBPACK_IMPORTED_MODULE_0__.createElement(RecoilRoot$1,{store_INTERNAL:store},children)}),[store])};const{loadableWithValue:loadableWithValue$1}=Recoil_Loadable$1,{initializeNode:initializeNode$3}=Recoil_FunctionalCore,{DEFAULT_VALUE:DEFAULT_VALUE$4,getNode:getNode$5}=Recoil_Node,{copyTreeState:copyTreeState$1,getRecoilValueAsLoadable:getRecoilValueAsLoadable$3,invalidateDownstreams:invalidateDownstreams$1,writeLoadableToTreeState:writeLoadableToTreeState$1}=Recoil_RecoilValueInterface;function isAtom(recoilValue){return"atom"===getNode$5(recoilValue.key).nodeType}class TransactionInterfaceImpl{constructor(store,treeState){_defineProperty(this,"_store",void 0),_defineProperty(this,"_treeState",void 0),_defineProperty(this,"_changes",void 0),_defineProperty(this,"get",(recoilValue=>{if(this._changes.has(recoilValue.key))return this._changes.get(recoilValue.key);if(!isAtom(recoilValue))throw Recoil_err("Reading selectors within atomicUpdate is not supported");const loadable=getRecoilValueAsLoadable$3(this._store,recoilValue,this._treeState);if("hasValue"===loadable.state)return loadable.contents;throw"hasError"===loadable.state?loadable.contents:Recoil_err(`Expected Recoil atom ${recoilValue.key} to have a value, but it is in a loading state.`)})),_defineProperty(this,"set",((recoilState,valueOrUpdater)=>{if(!isAtom(recoilState))throw Recoil_err("Setting selectors within atomicUpdate is not supported");if("function"==typeof valueOrUpdater){const current=this.get(recoilState);this._changes.set(recoilState.key,valueOrUpdater(current))}else initializeNode$3(this._store,recoilState.key,"set"),this._changes.set(recoilState.key,valueOrUpdater)})),_defineProperty(this,"reset",(recoilState=>{this.set(recoilState,DEFAULT_VALUE$4)})),this._store=store,this._treeState=treeState,this._changes=new Map}newTreeState_INTERNAL(){if(0===this._changes.size)return this._treeState;const newState=copyTreeState$1(this._treeState);for(const[k,v]of this._changes)writeLoadableToTreeState$1(newState,k,loadableWithValue$1(v));return invalidateDownstreams$1(this._store,newState),newState}}var Recoil_AtomicUpdates_1=function atomicUpdater(store){return fn=>{store.replaceState((treeState=>{const changeset=new TransactionInterfaceImpl(store,treeState);return fn(changeset),changeset.newTreeState_INTERNAL()}))}},Recoil_AtomicUpdates$1=Object.freeze({__proto__:null,atomicUpdater:Recoil_AtomicUpdates_1});var Recoil_invariant=function invariant(condition,message){if(!condition)throw new Error(message)};const{atomicUpdater:atomicUpdater$1}=Recoil_AtomicUpdates$1,{batchUpdates:batchUpdates$4}=Recoil_Batching,{DEFAULT_VALUE:DEFAULT_VALUE$5}=Recoil_Node,{useStoreRef:useStoreRef$6}=Recoil_RecoilRoot,{refreshRecoilValue:refreshRecoilValue$1,setRecoilValue:setRecoilValue$3}=Recoil_RecoilValueInterface,{cloneSnapshot:cloneSnapshot$2}=Recoil_Snapshot$1,{gotoSnapshot:gotoSnapshot$1}=Recoil_SnapshotHooks,{useCallback:useCallback$3}=react__WEBPACK_IMPORTED_MODULE_0__;class Sentinel{}const SENTINEL=new Sentinel;function recoilCallback(store,fn,args,extraInterface){let releaseSnapshot,ret=SENTINEL;var _releaseSnapshot2;(batchUpdates$4((()=>{const errMsg="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if("function"!=typeof fn)throw Recoil_err(errMsg);const callbackInterface=Recoil_lazyProxy({...null!=extraInterface?extraInterface:{},set:(node,newValue)=>setRecoilValue$3(store,node,newValue),reset:node=>setRecoilValue$3(store,node,DEFAULT_VALUE$5),refresh:node=>refreshRecoilValue$1(store,node),gotoSnapshot:snapshot=>gotoSnapshot$1(store,snapshot),transact_UNSTABLE:transaction=>atomicUpdater$1(store)(transaction)},{snapshot:()=>{const snapshot=cloneSnapshot$2(store);return releaseSnapshot=snapshot.retain(),snapshot}}),callback=fn(callbackInterface);if("function"!=typeof callback)throw Recoil_err(errMsg);ret=callback(...args)})),ret instanceof Sentinel&&Recoil_invariant(!1),Recoil_isPromise(ret))?ret=ret.finally((()=>{var _releaseSnapshot;null===(_releaseSnapshot=releaseSnapshot)||void 0===_releaseSnapshot||_releaseSnapshot()})):null===(_releaseSnapshot2=releaseSnapshot)||void 0===_releaseSnapshot2||_releaseSnapshot2();return ret}var Recoil_useRecoilCallback={recoilCallback,useRecoilCallback:function useRecoilCallback(fn,deps){const storeRef=useStoreRef$6();return useCallback$3(((...args)=>recoilCallback(storeRef.current,fn,args)),null!=deps?[...deps,storeRef]:void 0)}};const{useStoreRef:useStoreRef$7}=Recoil_RecoilRoot,{refreshRecoilValue:refreshRecoilValue$2}=Recoil_RecoilValueInterface,{useCallback:useCallback$4}=react__WEBPACK_IMPORTED_MODULE_0__;var Recoil_useRecoilRefresher=function useRecoilRefresher(recoilValue){const storeRef=useStoreRef$7();return useCallback$4((()=>{const store=storeRef.current;refreshRecoilValue$2(store,recoilValue)}),[recoilValue,storeRef])};const{atomicUpdater:atomicUpdater$2}=Recoil_AtomicUpdates$1,{useStoreRef:useStoreRef$8}=Recoil_RecoilRoot,{useMemo:useMemo$3}=react__WEBPACK_IMPORTED_MODULE_0__;var Recoil_useRecoilTransaction=function useRecoilTransaction(fn,deps){const storeRef=useStoreRef$8();return useMemo$3((()=>(...args)=>{atomicUpdater$2(storeRef.current)((transactionInterface=>{fn(transactionInterface)(...args)}))}),null!=deps?[...deps,storeRef]:void 0)};var Recoil_Wrapper_1=class WrappedValue{constructor(value){_defineProperty(this,"value",void 0),this.value=value}},Recoil_Wrapper$1=Object.freeze({__proto__:null,WrappedValue:Recoil_Wrapper_1});const{isFastRefreshEnabled:isFastRefreshEnabled$2}=Recoil_ReactMode;class ChangedPathError extends Error{}var Recoil_TreeCache_1=class TreeCache{constructor(options){var _options$onHit,_options$onSet,_options$mapNodeValue;_defineProperty(this,"_name",void 0),_defineProperty(this,"_numLeafs",void 0),_defineProperty(this,"_root",void 0),_defineProperty(this,"_onHit",void 0),_defineProperty(this,"_onSet",void 0),_defineProperty(this,"_mapNodeValue",void 0),this._name=null==options?void 0:options.name,this._numLeafs=0,this._root=null,this._onHit=null!==(_options$onHit=null==options?void 0:options.onHit)&&void 0!==_options$onHit?_options$onHit:()=>{},this._onSet=null!==(_options$onSet=null==options?void 0:options.onSet)&&void 0!==_options$onSet?_options$onSet:()=>{},this._mapNodeValue=null!==(_options$mapNodeValue=null==options?void 0:options.mapNodeValue)&&void 0!==_options$mapNodeValue?_options$mapNodeValue:val=>val}size(){return this._numLeafs}root(){return this._root}get(getNodeValue,handlers){var _this$getLeafNode;return null===(_this$getLeafNode=this.getLeafNode(getNodeValue,handlers))||void 0===_this$getLeafNode?void 0:_this$getLeafNode.value}getLeafNode(getNodeValue,handlers){if(null==this._root)return;let node=this._root;for(;node;){if(null==handlers||handlers.onNodeVisit(node),"leaf"===node.type)return this._onHit(node),node;const nodeValue=this._mapNodeValue(getNodeValue(node.nodeKey));node=node.branches.get(nodeValue)}}set(route,value,handlers){const addLeaf=()=>{var _node2,_node3,_this$_root2,_handlers$onNodeVisit2;let node,branchKey;for(const[nodeKey,nodeValue]of route){var _node,_handlers$onNodeVisit,_this$_root;const root=this._root;if("leaf"===(null==root?void 0:root.type))throw this.invalidCacheError();const parent=node;if(node=parent?parent.branches.get(branchKey):root,node=null!==(_node=node)&&void 0!==_node?_node:{type:"branch",nodeKey,parent,branches:new Map,branchKey},"branch"!==node.type||node.nodeKey!==nodeKey)throw this.invalidCacheError();null==parent||parent.branches.set(branchKey,node),null==handlers||null===(_handlers$onNodeVisit=handlers.onNodeVisit)||void 0===_handlers$onNodeVisit||_handlers$onNodeVisit.call(handlers,node),branchKey=this._mapNodeValue(nodeValue),this._root=null!==(_this$_root=this._root)&&void 0!==_this$_root?_this$_root:node}const oldLeaf=node?null===(_node2=node)||void 0===_node2?void 0:_node2.branches.get(branchKey):this._root;if(null!=oldLeaf&&("leaf"!==oldLeaf.type||oldLeaf.branchKey!==branchKey))throw this.invalidCacheError();const leafNode={type:"leaf",value,parent:node,branchKey};null===(_node3=node)||void 0===_node3||_node3.branches.set(branchKey,leafNode),this._root=null!==(_this$_root2=this._root)&&void 0!==_this$_root2?_this$_root2:leafNode,this._numLeafs++,this._onSet(leafNode),null==handlers||null===(_handlers$onNodeVisit2=handlers.onNodeVisit)||void 0===_handlers$onNodeVisit2||_handlers$onNodeVisit2.call(handlers,leafNode)};try{addLeaf()}catch(error){if(!(error instanceof ChangedPathError))throw error;this.clear(),addLeaf()}}delete(leaf){const root=this.root();if(!root)return!1;if(leaf===root)return this._root=null,this._numLeafs=0,!0;let node=leaf.parent,branchKey=leaf.branchKey;for(;node;){var _node4;if(node.branches.delete(branchKey),node===root)return 0===node.branches.size?(this._root=null,this._numLeafs=0):this._numLeafs--,!0;if(node.branches.size>0)break;branchKey=null===(_node4=node)||void 0===_node4?void 0:_node4.branchKey,node=node.parent}for(;node!==root;node=node.parent)if(null==node)return!1;return this._numLeafs--,!0}clear(){this._numLeafs=0,this._root=null}invalidCacheError(){const CHANGED_PATH_ERROR_MESSAGE=isFastRefreshEnabled$2()?"Possible Fast Refresh module reload detected.  This may also be caused by an selector returning inconsistent values. Resetting cache.":"Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache.";throw Recoil_recoverableViolation(CHANGED_PATH_ERROR_MESSAGE+(null!=this._name?` - ${this._name}`:"")),new ChangedPathError}},Recoil_TreeCache$1=Object.freeze({__proto__:null,TreeCache:Recoil_TreeCache_1});var Recoil_LRUCache_1=class LRUCache{constructor(options){var _options$mapKey;_defineProperty(this,"_maxSize",void 0),_defineProperty(this,"_size",void 0),_defineProperty(this,"_head",void 0),_defineProperty(this,"_tail",void 0),_defineProperty(this,"_map",void 0),_defineProperty(this,"_keyMapper",void 0),this._maxSize=options.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=null!==(_options$mapKey=options.mapKey)&&void 0!==_options$mapKey?_options$mapKey:v=>v}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(key){return this._map.has(this._keyMapper(key))}get(key){const mappedKey=this._keyMapper(key),node=this._map.get(mappedKey);if(node)return this.set(key,node.value),node.value}set(key,val){const mappedKey=this._keyMapper(key);this._map.get(mappedKey)&&this.delete(key);const head=this.head(),node={key,right:head,left:null,value:val};head?head.left=node:this._tail=node,this._map.set(mappedKey,node),this._head=node,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const tail=this.tail();tail&&this.delete(tail.key)}delete(key){const mappedKey=this._keyMapper(key);if(!this._size||!this._map.has(mappedKey))return;const node=Recoil_nullthrows(this._map.get(mappedKey)),right=node.right,left=node.left;right&&(right.left=node.left),left&&(left.right=node.right),node===this.head()&&(this._head=right),node===this.tail()&&(this._tail=left),this._map.delete(mappedKey),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}},Recoil_LRUCache$1=Object.freeze({__proto__:null,LRUCache:Recoil_LRUCache_1});const{LRUCache:LRUCache$1}=Recoil_LRUCache$1,{TreeCache:TreeCache$1}=Recoil_TreeCache$1;var Recoil_treeCacheLRU=function treeCacheLRU({name,maxSize,mapNodeValue=v=>v}){const lruCache=new LRUCache$1({maxSize}),cache=new TreeCache$1({name,mapNodeValue,onHit:node=>{lruCache.set(node,!0)},onSet:node=>{const lruNode=lruCache.tail();lruCache.set(node,!0),lruNode&&cache.size()>maxSize&&cache.delete(lruNode.key)}});return cache};function stringify(x,opt,key){if("string"==typeof x&&!x.includes('"')&&!x.includes("\\"))return`"${x}"`;switch(typeof x){case"undefined":return"";case"boolean":return x?"true":"false";case"number":case"symbol":return String(x);case"string":return JSON.stringify(x);case"function":if(!0!==(null==opt?void 0:opt.allowFunctions))throw Recoil_err("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${x.name})__`}if(null===x)return"null";var _JSON$stringify;if("object"!=typeof x)return null!==(_JSON$stringify=JSON.stringify(x))&&void 0!==_JSON$stringify?_JSON$stringify:"";if(Recoil_isPromise(x))return"__PROMISE__";if(Array.isArray(x))return`[${x.map(((v,i)=>stringify(v,opt,i.toString())))}]`;if("function"==typeof x.toJSON)return stringify(x.toJSON(key),opt,key);if(x instanceof Map){const obj={};for(const[k,v]of x)obj["string"==typeof k?k:stringify(k,opt)]=v;return stringify(obj,opt,key)}return x instanceof Set?stringify(Array.from(x).sort(((a,b)=>stringify(a,opt).localeCompare(stringify(b,opt)))),opt,key):void 0!==Symbol&&null!=x[Symbol.iterator]&&"function"==typeof x[Symbol.iterator]?stringify(Array.from(x),opt,key):`{${Object.keys(x).filter((k=>void 0!==x[k])).sort().map((k=>`${stringify(k,opt)}:${stringify(x[k],opt,k)}`)).join(",")}}`}var Recoil_stableStringify=function stableStringify(x,opt={allowFunctions:!1}){return stringify(x,opt)};const{TreeCache:TreeCache$2}=Recoil_TreeCache$1,defaultPolicy={equality:"reference",eviction:"keep-all",maxSize:1/0};var Recoil_treeCacheFromPolicy=function treeCacheFromPolicy({equality=defaultPolicy.equality,eviction=defaultPolicy.eviction,maxSize=defaultPolicy.maxSize}=defaultPolicy,name){const valueMapper=function getValueMapper(equality){switch(equality){case"reference":return val=>val;case"value":return val=>Recoil_stableStringify(val)}throw Recoil_err(`Unrecognized equality policy ${equality}`)}(equality);return function getTreeCache(eviction,maxSize,mapNodeValue,name){switch(eviction){case"keep-all":return new TreeCache$2({name,mapNodeValue});case"lru":return Recoil_treeCacheLRU({name,maxSize:Recoil_nullthrows(maxSize),mapNodeValue});case"most-recent":return Recoil_treeCacheLRU({name,maxSize:1,mapNodeValue})}throw Recoil_err(`Unrecognized eviction policy ${eviction}`)}(eviction,maxSize,valueMapper,name)};const{isReactNative:isReactNative$1,isWindow:isWindow$1}=Recoil_Environment;var Recoil_PerformanceTimings={startPerfBlock:function startPerfBlock(_id){return()=>null}};const{isLoadable:isLoadable$1,loadableWithError:loadableWithError$1,loadableWithPromise:loadableWithPromise$1,loadableWithValue:loadableWithValue$2}=Recoil_Loadable$1,{WrappedValue:WrappedValue$1}=Recoil_Wrapper$1,{getNodeLoadable:getNodeLoadable$2,peekNodeLoadable:peekNodeLoadable$1,setNodeValue:setNodeValue$3}=Recoil_FunctionalCore,{saveDepsToStore:saveDepsToStore$1}=Recoil_Graph,{DEFAULT_VALUE:DEFAULT_VALUE$6,getConfigDeletionHandler:getConfigDeletionHandler$1,getNode:getNode$6,registerNode:registerNode$1}=Recoil_Node,{isRecoilValue:isRecoilValue$3}=Recoil_RecoilValue$1,{markRecoilValueModified:markRecoilValueModified$1}=Recoil_RecoilValueInterface,{retainedByOptionWithDefault:retainedByOptionWithDefault$1}=Recoil_Retention,{recoilCallback:recoilCallback$1}=Recoil_useRecoilCallback,{startPerfBlock:startPerfBlock$1}=Recoil_PerformanceTimings;class Canceled{}const CANCELED=new Canceled,dependencyStack=[],waitingStores=new Map,getNewExecutionID=(()=>{let executionID=0;return()=>executionID++})();function selector(options){let recoilValue=null;const{key,get,cachePolicy_UNSTABLE:cachePolicy}=options,set=null!=options.set?options.set:void 0;const discoveredDependencyNodeKeys=new Set,cache=Recoil_treeCacheFromPolicy(null!=cachePolicy?cachePolicy:{equality:"reference",eviction:"keep-all"},key),retainedBy=retainedByOptionWithDefault$1(options.retainedBy_UNSTABLE),executionInfoMap=new Map;let liveStoresCount=0;function selectorIsLive(){return!Recoil_gkx("recoil_memory_managament_2020")||liveStoresCount>0}function selectorInit(store){return store.getState().knownSelectors.add(key),liveStoresCount++,()=>{liveStoresCount--}}function selectorShouldDeleteConfigOnRelease(){return void 0!==getConfigDeletionHandler$1(key)&&!selectorIsLive()}function resolveAsync(store,state,executionID,loadable,depValues){setCache(state,loadable,depValues),notifyStoresOfResolvedAsync(store,executionID)}function notifyStoresOfResolvedAsync(store,executionID){isLatestExecution(store,executionID)&&clearExecutionInfo(store),notifyWaitingStores(executionID,!0)}function notifyWaitingStores(executionID,clearWaitlist){const stores=waitingStores.get(executionID);if(null!=stores){for(const waitingStore of stores)markRecoilValueModified$1(waitingStore,Recoil_nullthrows(recoilValue));clearWaitlist&&waitingStores.delete(executionID)}}function markStoreWaitingForResolvedAsync(store,executionID){let stores=waitingStores.get(executionID);null==stores&&waitingStores.set(executionID,stores=new Set),stores.add(store)}function wrapPendingDependencyPromise(store,promise,state,existingDeps,executionID,loadingDepsState){return promise.then((resolvedDep=>{if(!selectorIsLive())throw clearExecutionInfo(store),CANCELED;null!=loadingDepsState.loadingDepKey&&loadingDepsState.loadingDepPromise===promise?state.atomValues.set(loadingDepsState.loadingDepKey,loadableWithValue$2(resolvedDep)):store.getState().knownSelectors.forEach((nodeKey=>{state.atomValues.delete(nodeKey)}));const cachedLoadable=getLoadableFromCacheAndUpdateDeps(store,state);if(cachedLoadable&&"loading"!==cachedLoadable.state){if((isLatestExecution(store,executionID)||null==getExecutionInfo(store))&&notifyStoresOfResolvedAsync(store,executionID),"hasValue"===cachedLoadable.state)return cachedLoadable.contents;throw cachedLoadable.contents}if(!isLatestExecution(store,executionID)){const executionInfo=getInProgressExecutionInfo(store,state);if(null!=executionInfo)return executionInfo.loadingLoadable.contents}const[loadable,depValues]=evaluateSelectorGetter(store,state,executionID);if("loading"!==loadable.state&&resolveAsync(store,state,executionID,loadable,depValues),"hasError"===loadable.state)throw loadable.contents;return loadable.contents})).catch((error=>{if(error instanceof Canceled)throw CANCELED;if(!selectorIsLive())throw clearExecutionInfo(store),CANCELED;const loadable=loadableWithError$1(error);throw resolveAsync(store,state,executionID,loadable,existingDeps),error}))}function updateDeps(store,state,deps,executionID){var _store$getState,_store$getState$curre,_store$getState2,_store$getState2$next,_store$getState$nextT,_store$getState3,_store$getState3$next;(isLatestExecution(store,executionID)||state.version===(null===(_store$getState=store.getState())||void 0===_store$getState||null===(_store$getState$curre=_store$getState.currentTree)||void 0===_store$getState$curre?void 0:_store$getState$curre.version)||state.version===(null===(_store$getState2=store.getState())||void 0===_store$getState2||null===(_store$getState2$next=_store$getState2.nextTree)||void 0===_store$getState2$next?void 0:_store$getState2$next.version))&&saveDepsToStore$1(key,deps,store,null!==(_store$getState$nextT=null===(_store$getState3=store.getState())||void 0===_store$getState3||null===(_store$getState3$next=_store$getState3.nextTree)||void 0===_store$getState3$next?void 0:_store$getState3$next.version)&&void 0!==_store$getState$nextT?_store$getState$nextT:store.getState().currentTree.version);for(const nodeKey of deps)discoveredDependencyNodeKeys.add(nodeKey)}function evaluateSelectorGetter(store,state,executionID){const endPerfBlock=startPerfBlock$1(key);let duringSynchronousExecution=!0,duringAsynchronousExecution=!0;const finishEvaluation=()=>{endPerfBlock(),duringAsynchronousExecution=!1};let result,loadable,resultIsError=!1;const loadingDepsState={loadingDepKey:null,loadingDepPromise:null},depValues=new Map;function getRecoilValue({key:depKey}){const depLoadable=getNodeLoadable$2(store,state,depKey);switch(depValues.set(depKey,depLoadable),duringSynchronousExecution||(updateDeps(store,state,new Set(depValues.keys()),executionID),function notifyStoresOfNewAsyncDep(store,executionID){isLatestExecution(store,executionID)&&(Recoil_nullthrows(getExecutionInfo(store)).stateVersions.clear(),notifyWaitingStores(executionID,!1))}(store,executionID)),depLoadable.state){case"hasValue":return depLoadable.contents;case"hasError":throw depLoadable.contents;case"loading":throw loadingDepsState.loadingDepKey=depKey,loadingDepsState.loadingDepPromise=depLoadable.contents,depLoadable.contents}throw Recoil_err("Invalid Loadable state")}const getCallback=fn=>(...args)=>{if(duringAsynchronousExecution)throw Recoil_err("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return null==recoilValue&&Recoil_invariant(!1),recoilCallback$1(store,fn,args,{node:recoilValue})};try{result=get({get:getRecoilValue,getCallback}),result=isRecoilValue$3(result)?getRecoilValue(result):result,isLoadable$1(result)&&("hasError"===result.state&&(resultIsError=!0),result=result.contents),Recoil_isPromise(result)?result=function wrapResultPromise(store,promise,state,depValues,executionID,loadingDepsState){return promise.then((value=>{if(!selectorIsLive())throw clearExecutionInfo(store),CANCELED;const loadable=loadableWithValue$2(value);return resolveAsync(store,state,executionID,loadable,depValues),value})).catch((errorOrPromise=>{if(!selectorIsLive())throw clearExecutionInfo(store),CANCELED;if(Recoil_isPromise(errorOrPromise))return wrapPendingDependencyPromise(store,errorOrPromise,state,depValues,executionID,loadingDepsState);const loadable=loadableWithError$1(errorOrPromise);throw resolveAsync(store,state,executionID,loadable,depValues),errorOrPromise}))}(store,result,state,depValues,executionID,loadingDepsState).finally(finishEvaluation):finishEvaluation(),result=result instanceof WrappedValue$1?result.value:result}catch(errorOrDepPromise){result=errorOrDepPromise,Recoil_isPromise(result)?result=wrapPendingDependencyPromise(store,result,state,depValues,executionID,loadingDepsState).finally(finishEvaluation):(resultIsError=!0,finishEvaluation())}return loadable=resultIsError?loadableWithError$1(result):Recoil_isPromise(result)?loadableWithPromise$1(result):loadableWithValue$2(result),duringSynchronousExecution=!1,function updateExecutionInfoDepValues(store,executionID,depValues){if(isLatestExecution(store,executionID)){const executionInfo=getExecutionInfo(store);null!=executionInfo&&(executionInfo.depValuesDiscoveredSoFarDuringAsyncWork=depValues)}}(store,executionID,depValues),updateDeps(store,state,new Set(depValues.keys()),executionID),[loadable,depValues]}function getLoadableFromCacheAndUpdateDeps(store,state){let cachedLoadable=state.atomValues.get(key);if(null!=cachedLoadable)return cachedLoadable;const depsAfterCacheLookup=new Set;try{cachedLoadable=cache.get((nodeKey=>("string"!=typeof nodeKey&&Recoil_invariant(!1),getNodeLoadable$2(store,state,nodeKey).contents)),{onNodeVisit:node=>{"branch"===node.type&&node.nodeKey!==key&&depsAfterCacheLookup.add(node.nodeKey)}})}catch(error){throw Recoil_err(`Problem with cache lookup for selector "${key}": ${error.message}`)}var _getExecutionInfo;cachedLoadable&&(state.atomValues.set(key,cachedLoadable),updateDeps(store,state,depsAfterCacheLookup,null===(_getExecutionInfo=getExecutionInfo(store))||void 0===_getExecutionInfo?void 0:_getExecutionInfo.executionID));return cachedLoadable}function getSelectorLoadableAndUpdateDeps(store,state){const cachedVal=getLoadableFromCacheAndUpdateDeps(store,state);if(null!=cachedVal)return clearExecutionInfo(store),cachedVal;const inProgressExecutionInfo=getInProgressExecutionInfo(store,state);var _inProgressExecutionI;if(null!=inProgressExecutionInfo)return"loading"===(null===(_inProgressExecutionI=inProgressExecutionInfo.loadingLoadable)||void 0===_inProgressExecutionI?void 0:_inProgressExecutionI.state)&&markStoreWaitingForResolvedAsync(store,inProgressExecutionInfo.executionID),inProgressExecutionInfo.loadingLoadable;const newExecutionID=getNewExecutionID(),[loadable,newDepValues]=evaluateSelectorGetter(store,state,newExecutionID);return"loading"===loadable.state?(!function setExecutionInfo(store,newExecutionID,loadable,depValues,state){executionInfoMap.set(store,{depValuesDiscoveredSoFarDuringAsyncWork:depValues,executionID:newExecutionID,loadingLoadable:loadable,stateVersions:new Map([[state.version,!0]])})}(store,newExecutionID,loadable,newDepValues,state),markStoreWaitingForResolvedAsync(store,newExecutionID)):(clearExecutionInfo(store),setCache(state,loadable,newDepValues)),loadable}function getInProgressExecutionInfo(store,state){const pendingExecutions=Recoil_concatIterables([executionInfoMap.has(store)?[Recoil_nullthrows(executionInfoMap.get(store))]:[],Recoil_mapIterable(Recoil_filterIterable(executionInfoMap,(([s])=>s!==store)),(([,execInfo])=>execInfo))]);function anyDepChanged(execDepValues){for(const[depKey,execLoadable]of execDepValues)if(!getNodeLoadable$2(store,state,depKey).is(execLoadable))return!0;return!1}for(const execInfo of pendingExecutions){if(execInfo.stateVersions.get(state.version)||!anyDepChanged(execInfo.depValuesDiscoveredSoFarDuringAsyncWork))return execInfo.stateVersions.set(state.version,!0),execInfo;execInfo.stateVersions.set(state.version,!1)}}function getExecutionInfo(store){return executionInfoMap.get(store)}function clearExecutionInfo(store){executionInfoMap.delete(store)}function isLatestExecution(store,executionID){var _getExecutionInfo2;return executionID===(null===(_getExecutionInfo2=getExecutionInfo(store))||void 0===_getExecutionInfo2?void 0:_getExecutionInfo2.executionID)}function setCache(state,loadable,depValues){state.atomValues.set(key,loadable);try{cache.set(function depValuesToDepRoute(depValues){return Array.from(depValues.entries()).map((([depKey,valLoadable])=>[depKey,valLoadable.contents]))}(depValues),loadable)}catch(error){throw Recoil_err(`Problem with setting cache for selector "${key}": ${error.message}`)}}function selectorPeek(store,state){const cachedLoadable=state.atomValues.get(key);return null!=cachedLoadable?cachedLoadable:cache.get((nodeKey=>{var _peekNodeLoadable;return"string"!=typeof nodeKey&&Recoil_invariant(!1),null===(_peekNodeLoadable=peekNodeLoadable$1(store,state,nodeKey))||void 0===_peekNodeLoadable?void 0:_peekNodeLoadable.contents}))}function selectorGet(store,state){return function detectCircularDependencies(fn){if(dependencyStack.includes(key)){const message=`Recoil selector has circular dependencies: ${dependencyStack.slice(dependencyStack.indexOf(key)).join(" → ")}`;return loadableWithError$1(Recoil_err(message))}dependencyStack.push(key);try{return fn()}finally{dependencyStack.pop()}}((()=>getSelectorLoadableAndUpdateDeps(store,state)))}function invalidateSelector(state){state.atomValues.delete(key)}function clearSelectorCache(store,treeState){null==recoilValue&&Recoil_invariant(!1);for(const nodeKey of discoveredDependencyNodeKeys){var _node$clearCache;const node=getNode$6(nodeKey);null===(_node$clearCache=node.clearCache)||void 0===_node$clearCache||_node$clearCache.call(node,store,treeState)}discoveredDependencyNodeKeys.clear(),invalidateSelector(treeState),cache.clear(),markRecoilValueModified$1(store,recoilValue)}if(null!=set){return recoilValue=registerNode$1({key,nodeType:"selector",peek:selectorPeek,get:selectorGet,set:(store,state,newValue)=>{let syncSelectorSetFinished=!1;const writes=new Map;function getRecoilValue({key:depKey}){if(syncSelectorSetFinished)throw Recoil_err("Recoil: Async selector sets are not currently supported.");const loadable=getNodeLoadable$2(store,state,depKey);if("hasValue"===loadable.state)return loadable.contents;if("loading"===loadable.state){const msg=`Getting value of asynchronous atom or selector "${depKey}" in a pending state while setting selector "${key}" is not yet supported.`;throw Recoil_recoverableViolation(msg),Recoil_err(msg)}throw loadable.contents}function setRecoilState(recoilState,valueOrUpdater){if(syncSelectorSetFinished){const msg="Recoil: Async selector sets are not currently supported.";throw Recoil_recoverableViolation(msg),Recoil_err(msg)}const setValue="function"==typeof valueOrUpdater?valueOrUpdater(getRecoilValue(recoilState)):valueOrUpdater;setNodeValue$3(store,state,recoilState.key,setValue).forEach(((v,k)=>writes.set(k,v)))}const ret=set({set:setRecoilState,get:getRecoilValue,reset:function resetRecoilState(recoilState){setRecoilState(recoilState,DEFAULT_VALUE$6)}},newValue);if(void 0!==ret)throw Recoil_isPromise(ret)?Recoil_err("Recoil: Async selector sets are not currently supported."):Recoil_err("Recoil: selector set should be a void function.");return syncSelectorSetFinished=!0,writes},init:selectorInit,invalidate:invalidateSelector,clearCache:clearSelectorCache,shouldDeleteConfigOnRelease:selectorShouldDeleteConfigOnRelease,dangerouslyAllowMutability:options.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy})}return recoilValue=registerNode$1({key,nodeType:"selector",peek:selectorPeek,get:selectorGet,init:selectorInit,invalidate:invalidateSelector,clearCache:clearSelectorCache,shouldDeleteConfigOnRelease:selectorShouldDeleteConfigOnRelease,dangerouslyAllowMutability:options.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy})}selector.value=value=>new WrappedValue$1(value);var Recoil_selector=selector;const{isLoadable:isLoadable$2,loadableWithError:loadableWithError$2,loadableWithPromise:loadableWithPromise$2,loadableWithValue:loadableWithValue$3}=Recoil_Loadable$1,{WrappedValue:WrappedValue$2}=Recoil_Wrapper$1,{peekNodeInfo:peekNodeInfo$3}=Recoil_FunctionalCore,{DEFAULT_VALUE:DEFAULT_VALUE$7,DefaultValue:DefaultValue$2,getConfigDeletionHandler:getConfigDeletionHandler$2,registerNode:registerNode$2,setConfigDeletionHandler:setConfigDeletionHandler$1}=Recoil_Node,{isRecoilValue:isRecoilValue$4}=Recoil_RecoilValue$1,{getRecoilValueAsLoadable:getRecoilValueAsLoadable$4,markRecoilValueModified:markRecoilValueModified$2,setRecoilValue:setRecoilValue$4,setRecoilValueLoadable:setRecoilValueLoadable$2}=Recoil_RecoilValueInterface,{retainedByOptionWithDefault:retainedByOptionWithDefault$2}=Recoil_Retention,unwrap=x=>x instanceof WrappedValue$2?x.value:x;function baseAtom(options){const{key,persistence_UNSTABLE:persistence}=options,retainedBy=retainedByOptionWithDefault$2(options.retainedBy_UNSTABLE);let liveStoresCount=0;function unwrapPromise(promise){return loadableWithPromise$2(promise.then((value=>(defaultLoadable=loadableWithValue$3(value),value))).catch((error=>{throw defaultLoadable=loadableWithError$2(error),error})))}let cachedAnswerForUnvalidatedValue,defaultLoadable=Recoil_isPromise(options.default)?unwrapPromise(options.default):isLoadable$2(options.default)?"loading"===options.default.state?unwrapPromise(options.default.contents):options.default:loadableWithValue$3(unwrap(options.default));maybeFreezeValueOrPromise(defaultLoadable.contents);const cleanupEffectsByStore=new Map;function maybeFreezeValueOrPromise(valueOrPromise){return valueOrPromise}function peekAtom(_store,state){var _ref,_state$atomValues$get3;return null!==(_ref=null!==(_state$atomValues$get3=state.atomValues.get(key))&&void 0!==_state$atomValues$get3?_state$atomValues$get3:cachedAnswerForUnvalidatedValue)&&void 0!==_ref?_ref:defaultLoadable}const node=registerNode$2({key,nodeType:"atom",peek:peekAtom,get:function getAtom(_store,state){if(state.atomValues.has(key))return Recoil_nullthrows(state.atomValues.get(key));if(state.nonvalidatedAtoms.has(key)){if(null!=cachedAnswerForUnvalidatedValue)return cachedAnswerForUnvalidatedValue;if(null==persistence)return Recoil_expectationViolation(`Tried to restore a persisted value for atom ${key} but it has no persistence settings.`),defaultLoadable;const nonvalidatedValue=state.nonvalidatedAtoms.get(key),validatorResult=persistence.validator(nonvalidatedValue,DEFAULT_VALUE$7),validatedValueLoadable=validatorResult instanceof DefaultValue$2?defaultLoadable:loadableWithValue$3(validatorResult);return cachedAnswerForUnvalidatedValue=validatedValueLoadable,cachedAnswerForUnvalidatedValue}return defaultLoadable},set:function setAtom(_store,state,newValue){if(state.atomValues.has(key)){const existing=Recoil_nullthrows(state.atomValues.get(key));if("hasValue"===existing.state&&newValue===existing.contents)return new Map}else if(!state.nonvalidatedAtoms.has(key)&&newValue instanceof DefaultValue$2)return new Map;return cachedAnswerForUnvalidatedValue=void 0,(new Map).set(key,loadableWithValue$3(newValue))},init:function initAtom(store,initState,trigger){var _options$effects;if(liveStoresCount++,store.getState().knownAtoms.add(key),"loading"===defaultLoadable.state){const notifyDefaultSubscribers=()=>{var _store$getState$nextT3;(null!==(_store$getState$nextT3=store.getState().nextTree)&&void 0!==_store$getState$nextT3?_store$getState$nextT3:store.getState().currentTree).atomValues.has(key)||markRecoilValueModified$2(store,node)};defaultLoadable.contents.finally(notifyDefaultSubscribers)}const effects=null!==(_options$effects=options.effects)&&void 0!==_options$effects?_options$effects:options.effects_UNSTABLE;if(null!=effects){let initValue=DEFAULT_VALUE$7,isDuringInit=!0,isInitError=!1,pendingSetSelf=null;function getLoadable(recoilValue){if(isDuringInit&&recoilValue.key===key){const retValue=initValue;return retValue instanceof DefaultValue$2?peekAtom(store,initState):Recoil_isPromise(retValue)?loadableWithPromise$2(retValue.then((v=>v instanceof DefaultValue$2?defaultLoadable.toPromise():v))):loadableWithValue$3(retValue)}return getRecoilValueAsLoadable$4(store,recoilValue)}function getPromise(recoilValue){return getLoadable(recoilValue).toPromise()}function getInfo_UNSTABLE(recoilValue){var _store$getState$nextT4;const info=peekNodeInfo$3(store,null!==(_store$getState$nextT4=store.getState().nextTree)&&void 0!==_store$getState$nextT4?_store$getState$nextT4:store.getState().currentTree,recoilValue.key);return!isDuringInit||recoilValue.key!==key||initValue instanceof DefaultValue$2?info:{...info,isSet:!0,loadable:getLoadable(recoilValue)}}const setSelf=effect=>valueOrUpdater=>{if(isDuringInit){const currentLoadable=getLoadable(node),currentValue="hasValue"===currentLoadable.state?currentLoadable.contents:DEFAULT_VALUE$7;initValue="function"==typeof valueOrUpdater?valueOrUpdater(currentValue):valueOrUpdater,Recoil_isPromise(initValue)&&(initValue=initValue.then((value=>(pendingSetSelf={effect,value},value))))}else{if(Recoil_isPromise(valueOrUpdater))throw Recoil_err("Setting atoms to async values is not implemented.");"function"!=typeof valueOrUpdater&&(pendingSetSelf={effect,value:unwrap(valueOrUpdater)}),setRecoilValue$4(store,node,"function"==typeof valueOrUpdater?currentValue=>{const newValue=unwrap(valueOrUpdater(currentValue));return pendingSetSelf={effect,value:newValue},newValue}:unwrap(valueOrUpdater))}},resetSelf=effect=>()=>setSelf(effect)(DEFAULT_VALUE$7),onSet=effect=>handler=>{var _cleanupEffectsByStor2;const{release}=store.subscribeToTransactions((currentStore=>{var _currentTree$atomValu;let{currentTree,previousTree}=currentStore.getState();previousTree||(Recoil_recoverableViolation("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil"),previousTree=currentTree);const newLoadable=null!==(_currentTree$atomValu=currentTree.atomValues.get(key))&&void 0!==_currentTree$atomValu?_currentTree$atomValu:defaultLoadable;if("hasValue"===newLoadable.state){var _previousTree$atomVal,_pendingSetSelf,_pendingSetSelf2,_pendingSetSelf3;const newValue=newLoadable.contents,oldLoadable=null!==(_previousTree$atomVal=previousTree.atomValues.get(key))&&void 0!==_previousTree$atomVal?_previousTree$atomVal:defaultLoadable,oldValue="hasValue"===oldLoadable.state?oldLoadable.contents:DEFAULT_VALUE$7;(null===(_pendingSetSelf=pendingSetSelf)||void 0===_pendingSetSelf?void 0:_pendingSetSelf.effect)!==effect||(null===(_pendingSetSelf2=pendingSetSelf)||void 0===_pendingSetSelf2?void 0:_pendingSetSelf2.value)!==newValue?handler(newValue,oldValue,!currentTree.atomValues.has(key)):(null===(_pendingSetSelf3=pendingSetSelf)||void 0===_pendingSetSelf3?void 0:_pendingSetSelf3.effect)===effect&&(pendingSetSelf=null)}}),key);cleanupEffectsByStore.set(store,[...null!==(_cleanupEffectsByStor2=cleanupEffectsByStore.get(store))&&void 0!==_cleanupEffectsByStor2?_cleanupEffectsByStor2:[],release])};for(const effect of effects)try{const cleanup=effect({node,storeID:store.storeID,parentStoreID_UNSTABLE:store.parentStoreID,trigger,setSelf:setSelf(effect),resetSelf:resetSelf(effect),onSet:onSet(effect),getPromise,getLoadable,getInfo_UNSTABLE});var _cleanupEffectsByStor3;if(null!=cleanup)cleanupEffectsByStore.set(store,[...null!==(_cleanupEffectsByStor3=cleanupEffectsByStore.get(store))&&void 0!==_cleanupEffectsByStor3?_cleanupEffectsByStor3:[],cleanup])}catch(error){initValue=error,isInitError=!0}if(isDuringInit=!1,!(initValue instanceof DefaultValue$2)){var _store$getState$nextT5;const initLoadable=isInitError?loadableWithError$2(initValue):Recoil_isPromise(initValue)?loadableWithPromise$2(function wrapPendingPromise(store,promise){const wrappedPromise=promise.then((value=>{var _store$getState$nextT,_state$atomValues$get;return(null===(_state$atomValues$get=(null!==(_store$getState$nextT=store.getState().nextTree)&&void 0!==_store$getState$nextT?_store$getState$nextT:store.getState().currentTree).atomValues.get(key))||void 0===_state$atomValues$get?void 0:_state$atomValues$get.contents)===wrappedPromise&&setRecoilValue$4(store,node,value),value})).catch((error=>{var _store$getState$nextT2,_state$atomValues$get2;throw(null===(_state$atomValues$get2=(null!==(_store$getState$nextT2=store.getState().nextTree)&&void 0!==_store$getState$nextT2?_store$getState$nextT2:store.getState().currentTree).atomValues.get(key))||void 0===_state$atomValues$get2?void 0:_state$atomValues$get2.contents)===wrappedPromise&&setRecoilValueLoadable$2(store,node,loadableWithError$2(error)),error}));return wrappedPromise}(store,initValue)):loadableWithValue$3(unwrap(initValue));initLoadable.contents,initState.atomValues.set(key,initLoadable),null===(_store$getState$nextT5=store.getState().nextTree)||void 0===_store$getState$nextT5||_store$getState$nextT5.atomValues.set(key,initLoadable)}}return()=>{var _cleanupEffectsByStor;liveStoresCount--,null===(_cleanupEffectsByStor=cleanupEffectsByStore.get(store))||void 0===_cleanupEffectsByStor||_cleanupEffectsByStor.forEach((cleanup=>cleanup())),cleanupEffectsByStore.delete(store)}},invalidate:function invalidateAtom(){cachedAnswerForUnvalidatedValue=void 0},shouldDeleteConfigOnRelease:function shouldDeleteConfigOnReleaseAtom(){return void 0!==getConfigDeletionHandler$2(key)&&liveStoresCount<=0},dangerouslyAllowMutability:options.dangerouslyAllowMutability,persistence_UNSTABLE:options.persistence_UNSTABLE?{type:options.persistence_UNSTABLE.type,backButton:options.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy});return node}function atom(options){const{...restOptions}=options,optionsDefault="default"in options?options.default:new Promise((()=>{}));return isRecoilValue$4(optionsDefault)?function atomWithFallback(options){const base=atom({...options,default:DEFAULT_VALUE$7,persistence_UNSTABLE:void 0===options.persistence_UNSTABLE?void 0:{...options.persistence_UNSTABLE,validator:storedValue=>storedValue instanceof DefaultValue$2?storedValue:Recoil_nullthrows(options.persistence_UNSTABLE).validator(storedValue,DEFAULT_VALUE$7)},effects:options.effects,effects_UNSTABLE:options.effects_UNSTABLE}),sel=Recoil_selector({key:`${options.key}__withFallback`,get:({get})=>{const baseValue=get(base);return baseValue instanceof DefaultValue$2?options.default:baseValue},set:({set},newValue)=>set(base,newValue),cachePolicy_UNSTABLE:{eviction:"most-recent"},dangerouslyAllowMutability:options.dangerouslyAllowMutability});return setConfigDeletionHandler$1(sel.key,getConfigDeletionHandler$2(options.key)),sel}({...restOptions,default:optionsDefault}):baseAtom({...restOptions,default:optionsDefault})}atom.value=value=>new WrappedValue$2(value);var Recoil_atom=atom;var Recoil_MapCache_1=class MapCache{constructor(options){var _options$mapKey;_defineProperty(this,"_map",void 0),_defineProperty(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=null!==(_options$mapKey=null==options?void 0:options.mapKey)&&void 0!==_options$mapKey?_options$mapKey:v=>v}size(){return this._map.size}has(key){return this._map.has(this._keyMapper(key))}get(key){return this._map.get(this._keyMapper(key))}set(key,val){this._map.set(this._keyMapper(key),val)}delete(key){this._map.delete(this._keyMapper(key))}clear(){this._map.clear()}},Recoil_MapCache$1=Object.freeze({__proto__:null,MapCache:Recoil_MapCache_1});const{LRUCache:LRUCache$2}=Recoil_LRUCache$1,{MapCache:MapCache$1}=Recoil_MapCache$1,defaultPolicy$1={equality:"reference",eviction:"none",maxSize:1/0};var Recoil_cacheFromPolicy=function cacheFromPolicy({equality=defaultPolicy$1.equality,eviction=defaultPolicy$1.eviction,maxSize=defaultPolicy$1.maxSize}=defaultPolicy$1){const valueMapper=function getValueMapper$1(equality){switch(equality){case"reference":return val=>val;case"value":return val=>Recoil_stableStringify(val)}throw Recoil_err(`Unrecognized equality policy ${equality}`)}(equality);return function getCache(eviction,maxSize,mapKey){switch(eviction){case"keep-all":return new MapCache$1({mapKey});case"lru":return new LRUCache$2({mapKey,maxSize:Recoil_nullthrows(maxSize)});case"most-recent":return new LRUCache$2({mapKey,maxSize:1})}throw Recoil_err(`Unrecognized eviction policy ${eviction}`)}(eviction,maxSize,valueMapper)};const{setConfigDeletionHandler:setConfigDeletionHandler$2}=Recoil_Node;var Recoil_atomFamily=function atomFamily(options){var _options$cachePolicyF,_options$cachePolicyF2;const atomCache=Recoil_cacheFromPolicy({equality:null!==(_options$cachePolicyF=null===(_options$cachePolicyF2=options.cachePolicyForParams_UNSTABLE)||void 0===_options$cachePolicyF2?void 0:_options$cachePolicyF2.equality)&&void 0!==_options$cachePolicyF?_options$cachePolicyF:"value",eviction:"keep-all"});return params=>{var _stableStringify,_options$effects;const cachedAtom=atomCache.get(params);if(null!=cachedAtom)return cachedAtom;const{cachePolicyForParams_UNSTABLE,...atomOptions}=options,optionsDefault="default"in options?options.default:new Promise((()=>{})),newAtom=Recoil_atom({...atomOptions,key:`${options.key}__${null!==(_stableStringify=Recoil_stableStringify(params))&&void 0!==_stableStringify?_stableStringify:"void"}`,default:"function"==typeof optionsDefault?optionsDefault(params):optionsDefault,retainedBy_UNSTABLE:"function"==typeof options.retainedBy_UNSTABLE?options.retainedBy_UNSTABLE(params):options.retainedBy_UNSTABLE,effects:"function"==typeof options.effects?options.effects(params):"function"==typeof options.effects_UNSTABLE?options.effects_UNSTABLE(params):null!==(_options$effects=options.effects)&&void 0!==_options$effects?_options$effects:options.effects_UNSTABLE});return atomCache.set(params,newAtom),setConfigDeletionHandler$2(newAtom.key,(()=>{atomCache.delete(params)})),newAtom}};const{setConfigDeletionHandler:setConfigDeletionHandler$3}=Recoil_Node;let nextIndex=0;var Recoil_selectorFamily=function selectorFamily(options){var _options$cachePolicyF,_options$cachePolicyF2;const selectorCache=Recoil_cacheFromPolicy({equality:null!==(_options$cachePolicyF=null===(_options$cachePolicyF2=options.cachePolicyForParams_UNSTABLE)||void 0===_options$cachePolicyF2?void 0:_options$cachePolicyF2.equality)&&void 0!==_options$cachePolicyF?_options$cachePolicyF:"value",eviction:"keep-all"});return params=>{var _stableStringify;let cachedSelector;try{cachedSelector=selectorCache.get(params)}catch(error){throw Recoil_err(`Problem with cache lookup for selector ${options.key}: ${error.message}`)}if(null!=cachedSelector)return cachedSelector;const myKey=`${options.key}__selectorFamily/${null!==(_stableStringify=Recoil_stableStringify(params,{allowFunctions:!0}))&&void 0!==_stableStringify?_stableStringify:"void"}/${nextIndex++}`,myGet=callbacks=>options.get(params)(callbacks),myCachePolicy=options.cachePolicy_UNSTABLE,retainedBy="function"==typeof options.retainedBy_UNSTABLE?options.retainedBy_UNSTABLE(params):options.retainedBy_UNSTABLE;let newSelector;if(null!=options.set){const set=options.set;newSelector=Recoil_selector({key:myKey,get:myGet,set:(callbacks,newValue)=>set(params)(callbacks,newValue),cachePolicy_UNSTABLE:myCachePolicy,dangerouslyAllowMutability:options.dangerouslyAllowMutability,retainedBy_UNSTABLE:retainedBy})}else newSelector=Recoil_selector({key:myKey,get:myGet,cachePolicy_UNSTABLE:myCachePolicy,dangerouslyAllowMutability:options.dangerouslyAllowMutability,retainedBy_UNSTABLE:retainedBy});return selectorCache.set(params,newSelector),setConfigDeletionHandler$3(newSelector.key,(()=>{selectorCache.delete(params)})),newSelector}};const constantSelector=Recoil_selectorFamily({key:"__constant",get:constant=>()=>constant,cachePolicyForParams_UNSTABLE:{equality:"reference"}});var Recoil_constSelector=function constSelector(constant){return constantSelector(constant)};const throwingSelector=Recoil_selectorFamily({key:"__error",get:message=>()=>{throw Recoil_err(message)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});var Recoil_errorSelector=function errorSelector(message){return throwingSelector(message)};var Recoil_readOnlySelector=function readOnlySelector(atom){return atom};const{loadableWithError:loadableWithError$3,loadableWithPromise:loadableWithPromise$3,loadableWithValue:loadableWithValue$4}=Recoil_Loadable$1;function concurrentRequests(getRecoilValue,deps){const results=Array(deps.length).fill(void 0),exceptions=Array(deps.length).fill(void 0);for(const[i,dep]of deps.entries())try{results[i]=getRecoilValue(dep)}catch(e){exceptions[i]=e}return[results,exceptions]}function isError(exp){return null!=exp&&!Recoil_isPromise(exp)}function unwrapDependencies(dependencies){return Array.isArray(dependencies)?dependencies:Object.getOwnPropertyNames(dependencies).map((key=>dependencies[key]))}function wrapResults(dependencies,results){return Array.isArray(dependencies)?results:Object.getOwnPropertyNames(dependencies).reduce(((out,key,idx)=>({...out,[key]:results[idx]})),{})}function wrapLoadables(dependencies,results,exceptions){return wrapResults(dependencies,exceptions.map(((exception,idx)=>null==exception?loadableWithValue$4(results[idx]):Recoil_isPromise(exception)?loadableWithPromise$3(exception):loadableWithError$3(exception))))}var Recoil_WaitFor={waitForNone:Recoil_selectorFamily({key:"__waitForNone",get:dependencies=>({get})=>{const deps=unwrapDependencies(dependencies),[results,exceptions]=concurrentRequests(get,deps);return wrapLoadables(dependencies,results,exceptions)},dangerouslyAllowMutability:!0}),waitForAny:Recoil_selectorFamily({key:"__waitForAny",get:dependencies=>({get})=>{const deps=unwrapDependencies(dependencies),[results,exceptions]=concurrentRequests(get,deps);return exceptions.some((exp=>!Recoil_isPromise(exp)))?wrapLoadables(dependencies,results,exceptions):new Promise((resolve=>{for(const[i,exp]of exceptions.entries())Recoil_isPromise(exp)&&exp.then((result=>{results[i]=result,exceptions[i]=void 0,resolve(wrapLoadables(dependencies,results,exceptions))})).catch((error=>{exceptions[i]=error,resolve(wrapLoadables(dependencies,results,exceptions))}))}))},dangerouslyAllowMutability:!0}),waitForAll:Recoil_selectorFamily({key:"__waitForAll",get:dependencies=>({get})=>{const deps=unwrapDependencies(dependencies),[results,exceptions]=concurrentRequests(get,deps);if(exceptions.every((exp=>null==exp)))return wrapResults(dependencies,results);const error=exceptions.find(isError);if(null!=error)throw error;return Promise.all(exceptions).then((exceptionResults=>wrapResults(dependencies,function combineAsyncResultsWithSyncResults(syncResults,asyncResults){return asyncResults.map(((result,idx)=>void 0===result?syncResults[idx]:result))}(results,exceptionResults))))},dangerouslyAllowMutability:!0}),waitForAllSettled:Recoil_selectorFamily({key:"__waitForAllSettled",get:dependencies=>({get})=>{const deps=unwrapDependencies(dependencies),[results,exceptions]=concurrentRequests(get,deps);return exceptions.every((exp=>!Recoil_isPromise(exp)))?wrapLoadables(dependencies,results,exceptions):Promise.all(exceptions.map(((exp,i)=>Recoil_isPromise(exp)?exp.then((result=>{results[i]=result,exceptions[i]=void 0})).catch((error=>{results[i]=void 0,exceptions[i]=error})):null))).then((()=>wrapLoadables(dependencies,results,exceptions)))},dangerouslyAllowMutability:!0}),noWait:Recoil_selectorFamily({key:"__noWait",get:dependency=>({get})=>{try{return Recoil_selector.value(loadableWithValue$4(get(dependency)))}catch(exception){return Recoil_selector.value(Recoil_isPromise(exception)?loadableWithPromise$3(exception):loadableWithError$3(exception))}},dangerouslyAllowMutability:!0})};const{RecoilLoadable}=Recoil_Loadable$1,{DefaultValue:DefaultValue$3}=Recoil_Node,{RecoilRoot:RecoilRoot$2,useRecoilStoreID:useRecoilStoreID$1}=Recoil_RecoilRoot,{isRecoilValue:isRecoilValue$5}=Recoil_RecoilValue$1,{retentionZone:retentionZone$1}=Recoil_RetentionZone,{freshSnapshot:freshSnapshot$2}=Recoil_Snapshot$1,{useRecoilState:useRecoilState$1,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,useRecoilStateLoadable:useRecoilStateLoadable$1,useRecoilValue:useRecoilValue$1,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,useRecoilValueLoadable:useRecoilValueLoadable$1,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,useResetRecoilState:useResetRecoilState$1,useSetRecoilState:useSetRecoilState$1}=Recoil_Hooks,{useGotoRecoilSnapshot:useGotoRecoilSnapshot$1,useRecoilSnapshot:useRecoilSnapshot$1,useRecoilTransactionObserver:useRecoilTransactionObserver$1}=Recoil_SnapshotHooks,{useRecoilCallback:useRecoilCallback$1}=Recoil_useRecoilCallback,{noWait:noWait$1,waitForAll:waitForAll$1,waitForAllSettled:waitForAllSettled$1,waitForAny:waitForAny$1,waitForNone:waitForNone$1}=Recoil_WaitFor;var Recoil_index={DefaultValue:DefaultValue$3,isRecoilValue:isRecoilValue$5,RecoilLoadable,RecoilEnv:Recoil_RecoilEnv,RecoilRoot:RecoilRoot$2,useRecoilStoreID:useRecoilStoreID$1,useRecoilBridgeAcrossReactRoots_UNSTABLE:Recoil_useRecoilBridgeAcrossReactRoots,atom:Recoil_atom,selector:Recoil_selector,atomFamily:Recoil_atomFamily,selectorFamily:Recoil_selectorFamily,constSelector:Recoil_constSelector,errorSelector:Recoil_errorSelector,readOnlySelector:Recoil_readOnlySelector,noWait:noWait$1,waitForNone:waitForNone$1,waitForAny:waitForAny$1,waitForAll:waitForAll$1,waitForAllSettled:waitForAllSettled$1,useRecoilValue:useRecoilValue$1,useRecoilValueLoadable:useRecoilValueLoadable$1,useRecoilState:useRecoilState$1,useRecoilStateLoadable:useRecoilStateLoadable$1,useSetRecoilState:useSetRecoilState$1,useResetRecoilState:useResetRecoilState$1,useGetRecoilValueInfo_UNSTABLE:Recoil_useGetRecoilValueInfo,useRecoilRefresher_UNSTABLE:Recoil_useRecoilRefresher,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,useRecoilCallback:useRecoilCallback$1,useRecoilTransaction_UNSTABLE:Recoil_useRecoilTransaction,useGotoRecoilSnapshot:useGotoRecoilSnapshot$1,useRecoilSnapshot:useRecoilSnapshot$1,useRecoilTransactionObserver_UNSTABLE:useRecoilTransactionObserver$1,snapshot_UNSTABLE:freshSnapshot$2,useRetain:Recoil_useRetain,retentionZone:retentionZone$1},Recoil_index_5=Recoil_index.RecoilRoot,Recoil_index_8=Recoil_index.atom,Recoil_index_20=Recoil_index.useRecoilValue,Recoil_index_22=Recoil_index.useRecoilState},"./node_modules/swr/dist/core/index.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{Ay:()=>useSWR,Tk:()=>mutate,iX:()=>useSWRConfig});var react=__webpack_require__("./node_modules/next/dist/compiled/react/index.js"),shim=__webpack_require__("./node_modules/use-sync-external-store/shim/index.js");const noop=()=>{},UNDEFINED=noop(),OBJECT=Object,isUndefined=v=>v===UNDEFINED,isFunction=v=>"function"==typeof v,mergeObjects=(a,b)=>({...a,...b}),table=new WeakMap;let counter=0;const stableHash=arg=>{const type=typeof arg,constructor=arg&&arg.constructor,isDate=constructor==Date;let result,index;if(OBJECT(arg)!==arg||isDate||constructor==RegExp)result=isDate?arg.toJSON():"symbol"==type?arg.toString():"string"==type?JSON.stringify(arg):""+arg;else{if(result=table.get(arg),result)return result;if(result=++counter+"~",table.set(arg,result),constructor==Array){for(result="@",index=0;index<arg.length;index++)result+=stableHash(arg[index])+",";table.set(arg,result)}if(constructor==OBJECT){result="#";const keys=OBJECT.keys(arg).sort();for(;!isUndefined(index=keys.pop());)isUndefined(arg[index])||(result+=index+":"+stableHash(arg[index])+",");table.set(arg,result)}}return result},SWRGlobalState=new WeakMap,EMPTY_CACHE={},INITIAL_CACHE={},isWindowDefined="undefined"!=typeof window,isDocumentDefined="undefined"!=typeof document,createCacheHelper=(cache,key)=>{const state=SWRGlobalState.get(cache);return[()=>!isUndefined(key)&&cache.get(key)||EMPTY_CACHE,info=>{if(!isUndefined(key)){const prev=cache.get(key);key in INITIAL_CACHE||(INITIAL_CACHE[key]=prev),state[5](key,mergeObjects(prev,info),prev||EMPTY_CACHE)}},state[6],()=>!isUndefined(key)&&key in INITIAL_CACHE?INITIAL_CACHE[key]:!isUndefined(key)&&cache.get(key)||EMPTY_CACHE]};let online=!0;const[onWindowEvent,offWindowEvent]=isWindowDefined&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[noop,noop],preset={isOnline:()=>online,isVisible:()=>{const visibilityState=isDocumentDefined&&document.visibilityState;return isUndefined(visibilityState)||"hidden"!==visibilityState}},defaultConfigOptions={initFocus:callback=>(isDocumentDefined&&document.addEventListener("visibilitychange",callback),onWindowEvent("focus",callback),()=>{isDocumentDefined&&document.removeEventListener("visibilitychange",callback),offWindowEvent("focus",callback)}),initReconnect:callback=>{const onOnline=()=>{online=!0,callback()},onOffline=()=>{online=!1};return onWindowEvent("online",onOnline),onWindowEvent("offline",onOffline),()=>{offWindowEvent("online",onOnline),offWindowEvent("offline",onOffline)}}},IS_REACT_LEGACY=!react.useId,IS_SERVER=!isWindowDefined||"Deno"in window,rAF=f=>isWindowDefined&&void 0!==window.requestAnimationFrame?window.requestAnimationFrame(f):setTimeout(f,1),useIsomorphicLayoutEffect=IS_SERVER?react.useEffect:react.useLayoutEffect,navigatorConnection="undefined"!=typeof navigator&&navigator.connection,slowConnection=!IS_SERVER&&navigatorConnection&&(["slow-2g","2g"].includes(navigatorConnection.effectiveType)||navigatorConnection.saveData),_internal_serialize=key=>{if(isFunction(key))try{key=key()}catch(err){key=""}const args=key;return[key="string"==typeof key?key:(Array.isArray(key)?key.length:key)?stableHash(key):"",args]};let __timestamp=0;const getTimestamp=()=>++__timestamp;var events_ERROR_REVALIDATE_EVENT=3,events_FOCUS_EVENT=0,events_MUTATE_EVENT=2,events_RECONNECT_EVENT=1;async function internalMutate(...args){const[cache,_key,_data,_opts]=args,options=mergeObjects({populateCache:!0,throwOnError:!0},"boolean"==typeof _opts?{revalidate:_opts}:_opts||{});let populateCache=options.populateCache;const rollbackOnErrorOption=options.rollbackOnError;let optimisticData=options.optimisticData;const throwOnError=options.throwOnError;if(isFunction(_key)){const keyFilter=_key,matchedKeys=[],it=cache.keys();for(const key of it)!/^\$(inf|sub)\$/.test(key)&&keyFilter(cache.get(key)._k)&&matchedKeys.push(key);return Promise.all(matchedKeys.map(mutateByKey))}return mutateByKey(_key);async function mutateByKey(_k){const[key]=_internal_serialize(_k);if(!key)return;const[get,set]=createCacheHelper(cache,key),[EVENT_REVALIDATORS,MUTATION,FETCH,PRELOAD]=SWRGlobalState.get(cache),startRevalidate=()=>{const revalidators=EVENT_REVALIDATORS[key];return(isFunction(options.revalidate)?options.revalidate(get().data,_k):!1!==options.revalidate)&&(delete FETCH[key],delete PRELOAD[key],revalidators&&revalidators[0])?revalidators[0](2).then((()=>get().data)):get().data};if(args.length<3)return startRevalidate();let error,data=_data;const beforeMutationTs=getTimestamp();MUTATION[key]=[beforeMutationTs,0];const hasOptimisticData=!isUndefined(optimisticData),state=get(),displayedData=state.data,currentData=state._c,committedData=isUndefined(currentData)?displayedData:currentData;if(hasOptimisticData&&(optimisticData=isFunction(optimisticData)?optimisticData(committedData,displayedData):optimisticData,set({data:optimisticData,_c:committedData})),isFunction(data))try{data=data(committedData)}catch(err){error=err}if(data&&isFunction(data.then)){if(data=await data.catch((err=>{error=err})),beforeMutationTs!==MUTATION[key][0]){if(error)throw error;return data}error&&hasOptimisticData&&(error=>"function"==typeof rollbackOnErrorOption?rollbackOnErrorOption(error):!1!==rollbackOnErrorOption)(error)&&(populateCache=!0,set({data:committedData,_c:UNDEFINED}))}if(populateCache&&!error)if(isFunction(populateCache)){const populateCachedData=populateCache(data,committedData);set({data:populateCachedData,error:UNDEFINED,_c:UNDEFINED})}else set({data,error:UNDEFINED,_c:UNDEFINED});if(MUTATION[key][1]=getTimestamp(),Promise.resolve(startRevalidate()).then((()=>{set({_c:UNDEFINED})})),!error)return data;if(throwOnError)throw error}}const revalidateAllKeys=(revalidators,type)=>{for(const key in revalidators)revalidators[key][0]&&revalidators[key][0](type)},initCache=(provider,options)=>{if(!SWRGlobalState.has(provider)){const opts=mergeObjects(defaultConfigOptions,options),EVENT_REVALIDATORS={},mutate=internalMutate.bind(UNDEFINED,provider);let unmount=noop;const subscriptions={},subscribe=(key,callback)=>{const subs=subscriptions[key]||[];return subscriptions[key]=subs,subs.push(callback),()=>subs.splice(subs.indexOf(callback),1)},setter=(key,value,prev)=>{provider.set(key,value);const subs=subscriptions[key];if(subs)for(const fn of subs)fn(value,prev)},initProvider=()=>{if(!SWRGlobalState.has(provider)&&(SWRGlobalState.set(provider,[EVENT_REVALIDATORS,{},{},{},mutate,setter,subscribe]),!IS_SERVER)){const releaseFocus=opts.initFocus(setTimeout.bind(UNDEFINED,revalidateAllKeys.bind(UNDEFINED,EVENT_REVALIDATORS,0))),releaseReconnect=opts.initReconnect(setTimeout.bind(UNDEFINED,revalidateAllKeys.bind(UNDEFINED,EVENT_REVALIDATORS,1)));unmount=()=>{releaseFocus&&releaseFocus(),releaseReconnect&&releaseReconnect(),SWRGlobalState.delete(provider)}}};return initProvider(),[provider,mutate,initProvider,unmount]}return[provider,SWRGlobalState.get(provider)[4]]},[cache,mutate]=initCache(new Map),defaultConfig=mergeObjects({onLoadingSlow:noop,onSuccess:noop,onError:noop,onErrorRetry:(_,__,config,revalidate,opts)=>{const maxRetryCount=config.errorRetryCount,currentRetryCount=opts.retryCount,timeout=~~((Math.random()+.5)*(1<<(currentRetryCount<8?currentRetryCount:8)))*config.errorRetryInterval;!isUndefined(maxRetryCount)&&currentRetryCount>maxRetryCount||setTimeout(revalidate,timeout,opts)},onDiscarded:noop,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:slowConnection?1e4:5e3,focusThrottleInterval:5e3,dedupingInterval:2e3,loadingTimeout:slowConnection?5e3:3e3,compare:(currentData,newData)=>stableHash(currentData)==stableHash(newData),isPaused:()=>!1,cache,mutate,fallback:{}},preset),mergeConfigs=(a,b)=>{const v=mergeObjects(a,b);if(b){const{use:u1,fallback:f1}=a,{use:u2,fallback:f2}=b;u1&&u2&&(v.use=u1.concat(u2)),f1&&f2&&(v.fallback=mergeObjects(f1,f2))}return v},SWRConfigContext=(0,react.createContext)({}),enableDevtools=isWindowDefined&&window.__SWR_DEVTOOLS_USE__,use=enableDevtools?window.__SWR_DEVTOOLS_USE__:[],normalize=args=>isFunction(args[1])?[args[0],args[1],args[2]||{}]:[args[0],null,(null===args[1]?args[2]:args[1])||{}],useSWRConfig=()=>mergeObjects(defaultConfig,(0,react.useContext)(SWRConfigContext)),BUILT_IN_MIDDLEWARE=use.concat((useSWRNext=>(key_,fetcher_,config)=>useSWRNext(key_,fetcher_&&((...args)=>{const[key]=_internal_serialize(key_),[,,,PRELOAD]=SWRGlobalState.get(cache);if(key.startsWith("$inf$"))return fetcher_(...args);const req=PRELOAD[key];return isUndefined(req)?fetcher_(...args):(delete PRELOAD[key],req)}),config)));enableDevtools&&(window.__SWR_DEVTOOLS_REACT__=react);const core_use=react.use||(promise=>{if("pending"===promise.status)throw promise;if("fulfilled"===promise.status)return promise.value;throw"rejected"===promise.status?promise.reason:(promise.status="pending",promise.then((v=>{promise.status="fulfilled",promise.value=v}),(e=>{promise.status="rejected",promise.reason=e})),promise)}),WITH_DEDUPE={dedupe:!0},useSWR=(OBJECT.defineProperty((props=>{const{value}=props,parentConfig=(0,react.useContext)(SWRConfigContext),isFunctionalConfig=isFunction(value),config=(0,react.useMemo)((()=>isFunctionalConfig?value(parentConfig):value),[isFunctionalConfig,parentConfig,value]),extendedConfig=(0,react.useMemo)((()=>isFunctionalConfig?config:mergeConfigs(parentConfig,config)),[isFunctionalConfig,parentConfig,config]),provider=config&&config.provider,cacheContextRef=(0,react.useRef)(UNDEFINED);provider&&!cacheContextRef.current&&(cacheContextRef.current=initCache(provider(extendedConfig.cache||cache),config));const cacheContext=cacheContextRef.current;return cacheContext&&(extendedConfig.cache=cacheContext[0],extendedConfig.mutate=cacheContext[1]),useIsomorphicLayoutEffect((()=>{if(cacheContext)return cacheContext[2]&&cacheContext[2](),cacheContext[3]}),[]),(0,react.createElement)(SWRConfigContext.Provider,mergeObjects(props,{value:extendedConfig}))}),"defaultValue",{value:defaultConfig}),hook=(_key,fetcher,config)=>{const{cache,compare,suspense,fallbackData,revalidateOnMount,revalidateIfStale,refreshInterval,refreshWhenHidden,refreshWhenOffline,keepPreviousData}=config,[EVENT_REVALIDATORS,MUTATION,FETCH,PRELOAD]=SWRGlobalState.get(cache),[key,fnArg]=_internal_serialize(_key),initialMountedRef=(0,react.useRef)(!1),unmountedRef=(0,react.useRef)(!1),keyRef=(0,react.useRef)(key),fetcherRef=(0,react.useRef)(fetcher),configRef=(0,react.useRef)(config),getConfig=()=>configRef.current,isActive=()=>getConfig().isVisible()&&getConfig().isOnline(),[getCache,setCache,subscribeCache,getInitialCache]=createCacheHelper(cache,key),stateDependencies=(0,react.useRef)({}).current,fallback=isUndefined(fallbackData)?config.fallback[key]:fallbackData,isEqual=(prev,current)=>{for(const _ in stateDependencies){const t=_;if("data"===t){if(!compare(prev[t],current[t])){if(!isUndefined(prev[t]))return!1;if(!compare(returnedData,current[t]))return!1}}else if(current[t]!==prev[t])return!1}return!0},getSnapshot=(0,react.useMemo)((()=>{const shouldStartRequest=!!key&&!!fetcher&&(isUndefined(revalidateOnMount)?!getConfig().isPaused()&&!suspense&&(!!isUndefined(revalidateIfStale)||revalidateIfStale):revalidateOnMount),getSelectedCache=state=>{const snapshot=mergeObjects(state);return delete snapshot._k,shouldStartRequest?{isValidating:!0,isLoading:!0,...snapshot}:snapshot},cachedData=getCache(),initialData=getInitialCache(),clientSnapshot=getSelectedCache(cachedData),serverSnapshot=cachedData===initialData?clientSnapshot:getSelectedCache(initialData);let memorizedSnapshot=clientSnapshot;return[()=>{const newSnapshot=getSelectedCache(getCache());return isEqual(newSnapshot,memorizedSnapshot)?(memorizedSnapshot.data=newSnapshot.data,memorizedSnapshot.isLoading=newSnapshot.isLoading,memorizedSnapshot.isValidating=newSnapshot.isValidating,memorizedSnapshot.error=newSnapshot.error,memorizedSnapshot):(memorizedSnapshot=newSnapshot,newSnapshot)},()=>serverSnapshot]}),[cache,key]),cached=(0,shim.useSyncExternalStore)((0,react.useCallback)((callback=>subscribeCache(key,((current,prev)=>{isEqual(prev,current)||callback()}))),[cache,key]),getSnapshot[0],getSnapshot[1]),isInitialMount=!initialMountedRef.current,hasRevalidator=EVENT_REVALIDATORS[key]&&EVENT_REVALIDATORS[key].length>0,cachedData=cached.data,data=isUndefined(cachedData)?fallback:cachedData,error=cached.error,laggyDataRef=(0,react.useRef)(data),returnedData=keepPreviousData?isUndefined(cachedData)?laggyDataRef.current:cachedData:data,shouldDoInitialRevalidation=!(hasRevalidator&&!isUndefined(error))&&(isInitialMount&&!isUndefined(revalidateOnMount)?revalidateOnMount:!getConfig().isPaused()&&(suspense?!isUndefined(data)&&revalidateIfStale:isUndefined(data)||revalidateIfStale)),defaultValidatingState=!!(key&&fetcher&&isInitialMount&&shouldDoInitialRevalidation),isValidating=isUndefined(cached.isValidating)?defaultValidatingState:cached.isValidating,isLoading=isUndefined(cached.isLoading)?defaultValidatingState:cached.isLoading,revalidate=(0,react.useCallback)((async revalidateOpts=>{const currentFetcher=fetcherRef.current;if(!key||!currentFetcher||unmountedRef.current||getConfig().isPaused())return!1;let newData,startAt,loading=!0;const opts=revalidateOpts||{},shouldStartNewRequest=!FETCH[key]||!opts.dedupe,callbackSafeguard=()=>IS_REACT_LEGACY?!unmountedRef.current&&key===keyRef.current&&initialMountedRef.current:key===keyRef.current,finalState={isValidating:!1,isLoading:!1},finishRequestAndUpdateState=()=>{setCache(finalState)},cleanupState=()=>{const requestInfo=FETCH[key];requestInfo&&requestInfo[1]===startAt&&delete FETCH[key]},initialState={isValidating:!0};isUndefined(getCache().data)&&(initialState.isLoading=!0);try{if(shouldStartNewRequest&&(setCache(initialState),config.loadingTimeout&&isUndefined(getCache().data)&&setTimeout((()=>{loading&&callbackSafeguard()&&getConfig().onLoadingSlow(key,config)}),config.loadingTimeout),FETCH[key]=[currentFetcher(fnArg),getTimestamp()]),[newData,startAt]=FETCH[key],newData=await newData,shouldStartNewRequest&&setTimeout(cleanupState,config.dedupingInterval),!FETCH[key]||FETCH[key][1]!==startAt)return shouldStartNewRequest&&callbackSafeguard()&&getConfig().onDiscarded(key),!1;finalState.error=UNDEFINED;const mutationInfo=MUTATION[key];if(!isUndefined(mutationInfo)&&(startAt<=mutationInfo[0]||startAt<=mutationInfo[1]||0===mutationInfo[1]))return finishRequestAndUpdateState(),shouldStartNewRequest&&callbackSafeguard()&&getConfig().onDiscarded(key),!1;const cacheData=getCache().data;finalState.data=compare(cacheData,newData)?cacheData:newData,shouldStartNewRequest&&callbackSafeguard()&&getConfig().onSuccess(newData,key,config)}catch(err){cleanupState();const currentConfig=getConfig(),{shouldRetryOnError}=currentConfig;currentConfig.isPaused()||(finalState.error=err,shouldStartNewRequest&&callbackSafeguard()&&(currentConfig.onError(err,key,currentConfig),(!0===shouldRetryOnError||isFunction(shouldRetryOnError)&&shouldRetryOnError(err))&&(getConfig().revalidateOnFocus&&getConfig().revalidateOnReconnect&&!isActive()||currentConfig.onErrorRetry(err,key,currentConfig,(_opts=>{const revalidators=EVENT_REVALIDATORS[key];revalidators&&revalidators[0]&&revalidators[0](events_ERROR_REVALIDATE_EVENT,_opts)}),{retryCount:(opts.retryCount||0)+1,dedupe:!0}))))}return loading=!1,finishRequestAndUpdateState(),!0}),[key,cache]),boundMutate=(0,react.useCallback)(((...args)=>internalMutate(cache,keyRef.current,...args)),[]);if(useIsomorphicLayoutEffect((()=>{fetcherRef.current=fetcher,configRef.current=config,isUndefined(cachedData)||(laggyDataRef.current=cachedData)})),useIsomorphicLayoutEffect((()=>{if(!key)return;const softRevalidate=revalidate.bind(UNDEFINED,WITH_DEDUPE);let nextFocusRevalidatedAt=0;const unsubEvents=((key,callbacks,callback)=>{const keyedRevalidators=callbacks[key]||(callbacks[key]=[]);return keyedRevalidators.push(callback),()=>{const index=keyedRevalidators.indexOf(callback);index>=0&&(keyedRevalidators[index]=keyedRevalidators[keyedRevalidators.length-1],keyedRevalidators.pop())}})(key,EVENT_REVALIDATORS,((type,opts={})=>{if(type==events_FOCUS_EVENT){const now=Date.now();getConfig().revalidateOnFocus&&now>nextFocusRevalidatedAt&&isActive()&&(nextFocusRevalidatedAt=now+getConfig().focusThrottleInterval,softRevalidate())}else if(type==events_RECONNECT_EVENT)getConfig().revalidateOnReconnect&&isActive()&&softRevalidate();else{if(type==events_MUTATE_EVENT)return revalidate();if(type==events_ERROR_REVALIDATE_EVENT)return revalidate(opts)}}));return unmountedRef.current=!1,keyRef.current=key,initialMountedRef.current=!0,setCache({_k:fnArg}),shouldDoInitialRevalidation&&(isUndefined(data)||IS_SERVER?softRevalidate():rAF(softRevalidate)),()=>{unmountedRef.current=!0,unsubEvents()}}),[key]),useIsomorphicLayoutEffect((()=>{let timer;function next(){const interval=isFunction(refreshInterval)?refreshInterval(getCache().data):refreshInterval;interval&&-1!==timer&&(timer=setTimeout(execute,interval))}function execute(){getCache().error||!refreshWhenHidden&&!getConfig().isVisible()||!refreshWhenOffline&&!getConfig().isOnline()?next():revalidate(WITH_DEDUPE).then(next)}return next(),()=>{timer&&(clearTimeout(timer),timer=-1)}}),[refreshInterval,refreshWhenHidden,refreshWhenOffline,key]),(0,react.useDebugValue)(returnedData),suspense&&isUndefined(data)&&key){if(!IS_REACT_LEGACY&&IS_SERVER)throw new Error("Fallback data is required when using suspense in SSR.");fetcherRef.current=fetcher,configRef.current=config,unmountedRef.current=!1;const req=PRELOAD[key];if(!isUndefined(req)){const promise=boundMutate(req);core_use(promise)}if(!isUndefined(error))throw error;{const promise=revalidate(WITH_DEDUPE);isUndefined(returnedData)||(promise.status="fulfilled",promise.value=!0),core_use(promise)}}return{mutate:boundMutate,get data(){return stateDependencies.data=!0,returnedData},get error(){return stateDependencies.error=!0,error},get isValidating(){return stateDependencies.isValidating=!0,isValidating},get isLoading(){return stateDependencies.isLoading=!0,isLoading}}},function useSWRArgs(...args){const fallbackConfig=useSWRConfig(),[key,fn,_config]=normalize(args),config=mergeConfigs(fallbackConfig,_config);let next=hook;const{use}=config,middleware=(use||[]).concat(BUILT_IN_MIDDLEWARE);for(let i=middleware.length;i--;)next=middleware[i](next);return next(key,fn||config.fetcher||null,config)});var hook},"./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";var e=__webpack_require__("./node_modules/next/dist/compiled/react/index.js");var k="function"==typeof Object.is?Object.is:function h(a,b){return a===b&&(0!==a||1/a==1/b)||a!=a&&b!=b},l=e.useState,m=e.useEffect,n=e.useLayoutEffect,p=e.useDebugValue;function r(a){var b=a.getSnapshot;a=a.value;try{var d=b();return!k(a,d)}catch(f){return!0}}var u="undefined"==typeof window||void 0===window.document||void 0===window.document.createElement?function t(a,b){return b()}:function q(a,b){var d=b(),f=l({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];return n((function(){c.value=d,c.getSnapshot=b,r(c)&&g({inst:c})}),[a,d,b]),m((function(){return r(c)&&g({inst:c}),a((function(){r(c)&&g({inst:c})}))}),[a]),p(d),d};exports.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:u},"./node_modules/use-sync-external-store/shim/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";module.exports=__webpack_require__("./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js")},"./node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs":(__unused_webpack_module,exports)=>{"use strict";function _getRequireWildcardCache(nodeInterop){if("function"!=typeof WeakMap)return null;var cacheBabelInterop=new WeakMap,cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop)}exports._=exports._interop_require_wildcard=function _interop_require_wildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule)return obj;if(null===obj||"object"!=typeof obj&&"function"!=typeof obj)return{default:obj};var cache=_getRequireWildcardCache(nodeInterop);if(cache&&cache.has(obj))return cache.get(obj);var newObj={__proto__:null},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj)if("default"!==key&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,desc):newObj[key]=obj[key]}newObj.default=obj,cache&&cache.set(obj,newObj);return newObj}}}]);
//# sourceMappingURL=108.2e512e03.iframe.bundle.js.map